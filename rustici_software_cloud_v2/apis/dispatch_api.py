# coding: utf-8

"""
    SCORM Cloud Rest API

    REST API used for SCORM Cloud integrations.

    OpenAPI spec version: 2.0
    Contact: systems@rusticisoftware.com
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


from __future__ import absolute_import

import sys
import os
import re

# python 2 and python 3 compatibility library
from six import iteritems

from ..configuration import Configuration
from ..api_client import ApiClient


class DispatchApi(object):
    """
    NOTE: This class is auto generated by the swagger code generator program.
    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        config = Configuration()
        if api_client:
            self.api_client = api_client
        else:
            if not config.api_client:
                config.api_client = ApiClient()
            self.api_client = config.api_client

    def create_destinations(self, destinations_list, **kwargs):
        """
        DestinationsByTenant
        Create multiple destinations.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.create_destinations(destinations_list, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param DestinationListSchema destinations_list:  (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.create_destinations_with_http_info(destinations_list, **kwargs)
        else:
            (data) = self.create_destinations_with_http_info(destinations_list, **kwargs)
            return data

    def create_destinations_with_http_info(self, destinations_list, **kwargs):
        """
        DestinationsByTenant
        Create multiple destinations.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.create_destinations_with_http_info(destinations_list, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param DestinationListSchema destinations_list:  (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['destinations_list']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_destinations" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'destinations_list' is set
        if ('destinations_list' not in params) or (params['destinations_list'] is None):
            raise ValueError("Missing the required parameter `destinations_list` when calling `create_destinations`")


        collection_formats = {}

        resource_path = '/dispatch/destinations'.replace('{format}', 'json')
        path_params = {}

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'destinations_list' in params:
            body_params = params['destinations_list']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['APP_NORMAL', 'OAUTH']

        return self.api_client.call_api(resource_path, 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def create_dispatches(self, dispatch_list, **kwargs):
        """
        Create dispatches.
        Create multiple dispatches at once. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.create_dispatches(dispatch_list, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param CreateDispatchListSchema dispatch_list: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.create_dispatches_with_http_info(dispatch_list, **kwargs)
        else:
            (data) = self.create_dispatches_with_http_info(dispatch_list, **kwargs)
            return data

    def create_dispatches_with_http_info(self, dispatch_list, **kwargs):
        """
        Create dispatches.
        Create multiple dispatches at once. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.create_dispatches_with_http_info(dispatch_list, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param CreateDispatchListSchema dispatch_list: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['dispatch_list']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_dispatches" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'dispatch_list' is set
        if ('dispatch_list' not in params) or (params['dispatch_list'] is None):
            raise ValueError("Missing the required parameter `dispatch_list` when calling `create_dispatches`")


        collection_formats = {}

        resource_path = '/dispatch/dispatches'.replace('{format}', 'json')
        path_params = {}

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'dispatch_list' in params:
            body_params = params['dispatch_list']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['APP_NORMAL', 'OAUTH']

        return self.api_client.call_api(resource_path, 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def delete_destination(self, destination_id, **kwargs):
        """
        Delete destination 
        Delete the destination with `destinationId` 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_destination(destination_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str destination_id: Identifier for the destination (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.delete_destination_with_http_info(destination_id, **kwargs)
        else:
            (data) = self.delete_destination_with_http_info(destination_id, **kwargs)
            return data

    def delete_destination_with_http_info(self, destination_id, **kwargs):
        """
        Delete destination 
        Delete the destination with `destinationId` 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_destination_with_http_info(destination_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str destination_id: Identifier for the destination (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['destination_id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_destination" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'destination_id' is set
        if ('destination_id' not in params) or (params['destination_id'] is None):
            raise ValueError("Missing the required parameter `destination_id` when calling `delete_destination`")


        collection_formats = {}

        resource_path = '/dispatch/destinations/{destinationId}'.replace('{format}', 'json')
        path_params = {}
        if 'destination_id' in params:
            path_params['destinationId'] = params['destination_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['APP_NORMAL', 'OAUTH']

        return self.api_client.call_api(resource_path, 'DELETE',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def delete_destination_dispatches(self, destination_id, **kwargs):
        """
        Delete dispatches in destination 
        Delete the dispatches in a destination 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_destination_dispatches(destination_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str destination_id: Identifier for the destination (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.delete_destination_dispatches_with_http_info(destination_id, **kwargs)
        else:
            (data) = self.delete_destination_dispatches_with_http_info(destination_id, **kwargs)
            return data

    def delete_destination_dispatches_with_http_info(self, destination_id, **kwargs):
        """
        Delete dispatches in destination 
        Delete the dispatches in a destination 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_destination_dispatches_with_http_info(destination_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str destination_id: Identifier for the destination (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['destination_id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_destination_dispatches" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'destination_id' is set
        if ('destination_id' not in params) or (params['destination_id'] is None):
            raise ValueError("Missing the required parameter `destination_id` when calling `delete_destination_dispatches`")


        collection_formats = {}

        resource_path = '/dispatch/destinations/{destinationId}/dispatches'.replace('{format}', 'json')
        path_params = {}
        if 'destination_id' in params:
            path_params['destinationId'] = params['destination_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['APP_NORMAL', 'OAUTH']

        return self.api_client.call_api(resource_path, 'DELETE',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def delete_destination_tags(self, destination_id, tags, **kwargs):
        """
        Delete the tags for this destination 
        Delete the tags for this destination 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_destination_tags(destination_id, tags, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str destination_id: Identifier for the destination (required)
        :param TagListSchema tags: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.delete_destination_tags_with_http_info(destination_id, tags, **kwargs)
        else:
            (data) = self.delete_destination_tags_with_http_info(destination_id, tags, **kwargs)
            return data

    def delete_destination_tags_with_http_info(self, destination_id, tags, **kwargs):
        """
        Delete the tags for this destination 
        Delete the tags for this destination 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_destination_tags_with_http_info(destination_id, tags, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str destination_id: Identifier for the destination (required)
        :param TagListSchema tags: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['destination_id', 'tags']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_destination_tags" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'destination_id' is set
        if ('destination_id' not in params) or (params['destination_id'] is None):
            raise ValueError("Missing the required parameter `destination_id` when calling `delete_destination_tags`")
        # verify the required parameter 'tags' is set
        if ('tags' not in params) or (params['tags'] is None):
            raise ValueError("Missing the required parameter `tags` when calling `delete_destination_tags`")


        collection_formats = {}

        resource_path = '/dispatch/destinations/{destinationId}/tags'.replace('{format}', 'json')
        path_params = {}
        if 'destination_id' in params:
            path_params['destinationId'] = params['destination_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'tags' in params:
            body_params = params['tags']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['APP_NORMAL', 'OAUTH']

        return self.api_client.call_api(resource_path, 'DELETE',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def delete_dispatch(self, dispatch_id, **kwargs):
        """
        Delete the dispatch with `dispatchId`. 
        Delete the dispatch with `dispatchId`. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_dispatch(dispatch_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str dispatch_id: Identifier for the dispatch (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.delete_dispatch_with_http_info(dispatch_id, **kwargs)
        else:
            (data) = self.delete_dispatch_with_http_info(dispatch_id, **kwargs)
            return data

    def delete_dispatch_with_http_info(self, dispatch_id, **kwargs):
        """
        Delete the dispatch with `dispatchId`. 
        Delete the dispatch with `dispatchId`. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_dispatch_with_http_info(dispatch_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str dispatch_id: Identifier for the dispatch (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['dispatch_id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_dispatch" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'dispatch_id' is set
        if ('dispatch_id' not in params) or (params['dispatch_id'] is None):
            raise ValueError("Missing the required parameter `dispatch_id` when calling `delete_dispatch`")


        collection_formats = {}

        resource_path = '/dispatch/dispatches/{dispatchId}'.replace('{format}', 'json')
        path_params = {}
        if 'dispatch_id' in params:
            path_params['dispatchId'] = params['dispatch_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['APP_NORMAL', 'OAUTH']

        return self.api_client.call_api(resource_path, 'DELETE',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def delete_dispatch_postback_info(self, dispatch_id, **kwargs):
        """
        DispatchesByTenantAndDispatchId
        Delete the postback info dispatch with 'dispatchId'. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_dispatch_postback_info(dispatch_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str dispatch_id: Identifier for the dispatch (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.delete_dispatch_postback_info_with_http_info(dispatch_id, **kwargs)
        else:
            (data) = self.delete_dispatch_postback_info_with_http_info(dispatch_id, **kwargs)
            return data

    def delete_dispatch_postback_info_with_http_info(self, dispatch_id, **kwargs):
        """
        DispatchesByTenantAndDispatchId
        Delete the postback info dispatch with 'dispatchId'. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_dispatch_postback_info_with_http_info(dispatch_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str dispatch_id: Identifier for the dispatch (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['dispatch_id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_dispatch_postback_info" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'dispatch_id' is set
        if ('dispatch_id' not in params) or (params['dispatch_id'] is None):
            raise ValueError("Missing the required parameter `dispatch_id` when calling `delete_dispatch_postback_info`")


        collection_formats = {}

        resource_path = '/dispatch/dispatches/{dispatchId}/postback'.replace('{format}', 'json')
        path_params = {}
        if 'dispatch_id' in params:
            path_params['dispatchId'] = params['dispatch_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['APP_NORMAL', 'OAUTH']

        return self.api_client.call_api(resource_path, 'DELETE',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def delete_dispatch_tags(self, dispatch_id, tags, **kwargs):
        """
        Delete the tags for this dispatch. 
        Delete the tags for this dispatch. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_dispatch_tags(dispatch_id, tags, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str dispatch_id: Identifier for the dispatch (required)
        :param TagListSchema tags: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.delete_dispatch_tags_with_http_info(dispatch_id, tags, **kwargs)
        else:
            (data) = self.delete_dispatch_tags_with_http_info(dispatch_id, tags, **kwargs)
            return data

    def delete_dispatch_tags_with_http_info(self, dispatch_id, tags, **kwargs):
        """
        Delete the tags for this dispatch. 
        Delete the tags for this dispatch. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_dispatch_tags_with_http_info(dispatch_id, tags, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str dispatch_id: Identifier for the dispatch (required)
        :param TagListSchema tags: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['dispatch_id', 'tags']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_dispatch_tags" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'dispatch_id' is set
        if ('dispatch_id' not in params) or (params['dispatch_id'] is None):
            raise ValueError("Missing the required parameter `dispatch_id` when calling `delete_dispatch_tags`")
        # verify the required parameter 'tags' is set
        if ('tags' not in params) or (params['tags'] is None):
            raise ValueError("Missing the required parameter `tags` when calling `delete_dispatch_tags`")


        collection_formats = {}

        resource_path = '/dispatch/dispatches/{dispatchId}/tags'.replace('{format}', 'json')
        path_params = {}
        if 'dispatch_id' in params:
            path_params['dispatchId'] = params['dispatch_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'tags' in params:
            body_params = params['tags']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['APP_NORMAL', 'OAUTH']

        return self.api_client.call_api(resource_path, 'DELETE',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def enable_registration_instancing(self, destination_id, enabled, **kwargs):
        """
        DestinationsDispatchesRegistrationInstancing
        Enable or disable registration instancing.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.enable_registration_instancing(destination_id, enabled, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str destination_id: Identifier for the destination (required)
        :param EnabledSchema enabled:  (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.enable_registration_instancing_with_http_info(destination_id, enabled, **kwargs)
        else:
            (data) = self.enable_registration_instancing_with_http_info(destination_id, enabled, **kwargs)
            return data

    def enable_registration_instancing_with_http_info(self, destination_id, enabled, **kwargs):
        """
        DestinationsDispatchesRegistrationInstancing
        Enable or disable registration instancing.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.enable_registration_instancing_with_http_info(destination_id, enabled, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str destination_id: Identifier for the destination (required)
        :param EnabledSchema enabled:  (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['destination_id', 'enabled']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method enable_registration_instancing" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'destination_id' is set
        if ('destination_id' not in params) or (params['destination_id'] is None):
            raise ValueError("Missing the required parameter `destination_id` when calling `enable_registration_instancing`")
        # verify the required parameter 'enabled' is set
        if ('enabled' not in params) or (params['enabled'] is None):
            raise ValueError("Missing the required parameter `enabled` when calling `enable_registration_instancing`")


        collection_formats = {}

        resource_path = '/dispatch/destinations/{destinationId}/dispatches/registrationInstancing'.replace('{format}', 'json')
        path_params = {}
        if 'destination_id' in params:
            path_params['destinationId'] = params['destination_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'enabled' in params:
            body_params = params['enabled']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['APP_NORMAL', 'OAUTH']

        return self.api_client.call_api(resource_path, 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_destination(self, destination_id, **kwargs):
        """
        Get destination information by destinationId.
        Gets detailed information about a destination belonging to a destinationId.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_destination(destination_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str destination_id: Identifier for the destination (required)
        :return: DestinationSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_destination_with_http_info(destination_id, **kwargs)
        else:
            (data) = self.get_destination_with_http_info(destination_id, **kwargs)
            return data

    def get_destination_with_http_info(self, destination_id, **kwargs):
        """
        Get destination information by destinationId.
        Gets detailed information about a destination belonging to a destinationId.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_destination_with_http_info(destination_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str destination_id: Identifier for the destination (required)
        :return: DestinationSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['destination_id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_destination" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'destination_id' is set
        if ('destination_id' not in params) or (params['destination_id'] is None):
            raise ValueError("Missing the required parameter `destination_id` when calling `get_destination`")


        collection_formats = {}

        resource_path = '/dispatch/destinations/{destinationId}'.replace('{format}', 'json')
        path_params = {}
        if 'destination_id' in params:
            path_params['destinationId'] = params['destination_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['APP_NORMAL', 'OAUTH']

        return self.api_client.call_api(resource_path, 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='DestinationSchema',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_destination_dispatch_registration_count(self, destination_id, **kwargs):
        """
        DestinationsDispatchesRegistrationCount
        Get an aggregate count of all related dispatch registrations.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_destination_dispatch_registration_count(destination_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str destination_id: Identifier for the destination (required)
        :return: IntegerResultSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_destination_dispatch_registration_count_with_http_info(destination_id, **kwargs)
        else:
            (data) = self.get_destination_dispatch_registration_count_with_http_info(destination_id, **kwargs)
            return data

    def get_destination_dispatch_registration_count_with_http_info(self, destination_id, **kwargs):
        """
        DestinationsDispatchesRegistrationCount
        Get an aggregate count of all related dispatch registrations.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_destination_dispatch_registration_count_with_http_info(destination_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str destination_id: Identifier for the destination (required)
        :return: IntegerResultSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['destination_id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_destination_dispatch_registration_count" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'destination_id' is set
        if ('destination_id' not in params) or (params['destination_id'] is None):
            raise ValueError("Missing the required parameter `destination_id` when calling `get_destination_dispatch_registration_count`")


        collection_formats = {}

        resource_path = '/dispatch/destinations/{destinationId}/dispatches/registrationCount'.replace('{format}', 'json')
        path_params = {}
        if 'destination_id' in params:
            path_params['destinationId'] = params['destination_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['APP_NORMAL', 'OAUTH']

        return self.api_client.call_api(resource_path, 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='IntegerResultSchema',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_destination_dispatch_zip(self, destination_id, **kwargs):
        """
        Get a ZIP of related dispatches.
        Returns a zip file containing all of the dispatch packages for a destination.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_destination_dispatch_zip(destination_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str destination_id: Identifier for the destination (required)
        :param str type: The type of dispatch package to export (SCORM12 only supported in cloud today)
        :param str css_url:
        :param list[str] tags:
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_destination_dispatch_zip_with_http_info(destination_id, **kwargs)
        else:
            (data) = self.get_destination_dispatch_zip_with_http_info(destination_id, **kwargs)
            return data

    def get_destination_dispatch_zip_with_http_info(self, destination_id, **kwargs):
        """
        Get a ZIP of related dispatches.
        Returns a zip file containing all of the dispatch packages for a destination.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_destination_dispatch_zip_with_http_info(destination_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str destination_id: Identifier for the destination (required)
        :param str type: The type of dispatch package to export (SCORM12 only supported in cloud today)
        :param str css_url:
        :param list[str] tags:
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['destination_id', 'type', 'css_url', 'tags']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_destination_dispatch_zip" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'destination_id' is set
        if ('destination_id' not in params) or (params['destination_id'] is None):
            raise ValueError("Missing the required parameter `destination_id` when calling `get_destination_dispatch_zip`")


        collection_formats = {}

        resource_path = '/dispatch/destinations/{destinationId}/dispatches/zip'.replace('{format}', 'json')
        path_params = {}
        if 'destination_id' in params:
            path_params['destinationId'] = params['destination_id']

        query_params = {}
        if 'type' in params:
            query_params['type'] = params['type']
        if 'css_url' in params:
            query_params['cssUrl'] = params['css_url']
        if 'tags' in params:
            query_params['tags'] = params['tags']
            collection_formats['tags'] = 'csv'

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/zip'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['APP_NORMAL', 'OAUTH']

        return self.api_client.call_api(resource_path, 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='file',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_destination_dispatches(self, destination_id, **kwargs):
        """
        Get a list of dispatches in this destination
        Get a list of related dispatches.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_destination_dispatches(destination_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str destination_id: Identifier for the destination (required)
        :param str course_id: Only retreive resources having `courseId` 
        :param str more: Value for this parameter will be provided in the 'more' property of registration lists, where needed. An opaque value, construction and parsing may change without notice.
        :param datetime since: Only items updated since the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used.
        :param datetime until: Only items updated before the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used.
        :param list[str] tags:
        :param str datetime_filter: A string describing what the since/until parameters will be applied to. Options are: 'created' or 'updated'.  If not provided, it will default to `updated`.
        :param str order_by:
        :return: DispatchListSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_destination_dispatches_with_http_info(destination_id, **kwargs)
        else:
            (data) = self.get_destination_dispatches_with_http_info(destination_id, **kwargs)
            return data

    def get_destination_dispatches_with_http_info(self, destination_id, **kwargs):
        """
        Get a list of dispatches in this destination
        Get a list of related dispatches.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_destination_dispatches_with_http_info(destination_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str destination_id: Identifier for the destination (required)
        :param str course_id: Only retreive resources having `courseId` 
        :param str more: Value for this parameter will be provided in the 'more' property of registration lists, where needed. An opaque value, construction and parsing may change without notice.
        :param datetime since: Only items updated since the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used.
        :param datetime until: Only items updated before the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used.
        :param list[str] tags:
        :param str datetime_filter: A string describing what the since/until parameters will be applied to. Options are: 'created' or 'updated'.  If not provided, it will default to `updated`.
        :param str order_by:
        :return: DispatchListSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['destination_id', 'course_id', 'more', 'since', 'until', 'tags', 'datetime_filter', 'order_by']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_destination_dispatches" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'destination_id' is set
        if ('destination_id' not in params) or (params['destination_id'] is None):
            raise ValueError("Missing the required parameter `destination_id` when calling `get_destination_dispatches`")


        collection_formats = {}

        resource_path = '/dispatch/destinations/{destinationId}/dispatches'.replace('{format}', 'json')
        path_params = {}
        if 'destination_id' in params:
            path_params['destinationId'] = params['destination_id']

        query_params = {}
        if 'course_id' in params:
            query_params['courseId'] = params['course_id']
        if 'more' in params:
            query_params['more'] = params['more']
        if 'since' in params:
            query_params['since'] = params['since']
        if 'until' in params:
            query_params['until'] = params['until']
        if 'tags' in params:
            query_params['tags'] = params['tags']
            collection_formats['tags'] = 'csv'
        if 'datetime_filter' in params:
            query_params['datetimeFilter'] = params['datetime_filter']
        if 'order_by' in params:
            query_params['orderBy'] = params['order_by']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['APP_NORMAL', 'OAUTH']

        return self.api_client.call_api(resource_path, 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='DispatchListSchema',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_destination_hash_user_info(self, destination_id, **kwargs):
        """
        True if the destination is set to hash user info, or false if it is disabled.
        True if the destination is set to hash user info, or false if it is disabled.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_destination_hash_user_info(destination_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str destination_id: Identifier for the destination (required)
        :return: EnabledSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_destination_hash_user_info_with_http_info(destination_id, **kwargs)
        else:
            (data) = self.get_destination_hash_user_info_with_http_info(destination_id, **kwargs)
            return data

    def get_destination_hash_user_info_with_http_info(self, destination_id, **kwargs):
        """
        True if the destination is set to hash user info, or false if it is disabled.
        True if the destination is set to hash user info, or false if it is disabled.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_destination_hash_user_info_with_http_info(destination_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str destination_id: Identifier for the destination (required)
        :return: EnabledSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['destination_id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_destination_hash_user_info" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'destination_id' is set
        if ('destination_id' not in params) or (params['destination_id'] is None):
            raise ValueError("Missing the required parameter `destination_id` when calling `get_destination_hash_user_info`")


        collection_formats = {}

        resource_path = '/dispatch/destinations/{destinationId}/dispatches/hashUserInfo'.replace('{format}', 'json')
        path_params = {}
        if 'destination_id' in params:
            path_params['destinationId'] = params['destination_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['APP_NORMAL', 'OAUTH']

        return self.api_client.call_api(resource_path, 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='EnabledSchema',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_destination_tags(self, destination_id, **kwargs):
        """
        Get the tags for this destination 
        Get the tags for this destination 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_destination_tags(destination_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str destination_id: Identifier for the destination (required)
        :return: TagListSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_destination_tags_with_http_info(destination_id, **kwargs)
        else:
            (data) = self.get_destination_tags_with_http_info(destination_id, **kwargs)
            return data

    def get_destination_tags_with_http_info(self, destination_id, **kwargs):
        """
        Get the tags for this destination 
        Get the tags for this destination 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_destination_tags_with_http_info(destination_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str destination_id: Identifier for the destination (required)
        :return: TagListSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['destination_id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_destination_tags" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'destination_id' is set
        if ('destination_id' not in params) or (params['destination_id'] is None):
            raise ValueError("Missing the required parameter `destination_id` when calling `get_destination_tags`")


        collection_formats = {}

        resource_path = '/dispatch/destinations/{destinationId}/tags'.replace('{format}', 'json')
        path_params = {}
        if 'destination_id' in params:
            path_params['destinationId'] = params['destination_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['APP_NORMAL', 'OAUTH']

        return self.api_client.call_api(resource_path, 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='TagListSchema',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_destinations(self, **kwargs):
        """
        getAllDestinations
        Get a list of destinations.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_destinations(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str course_id: Only retreive resources having `courseId` 
        :param str more: Value for this parameter will be provided in the 'more' property of registration lists, where needed. An opaque value, construction and parsing may change without notice.
        :param datetime since: Only items updated since the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used.
        :param datetime until: Only items updated before the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used.
        :param list[str] tags:
        :param str datetime_filter: A string describing what the since/until parameters will be applied to. Options are: 'created' or 'updated'.  If not provided, it will default to `updated`.
        :param str order_by: Optional enum parameter for specifying the field and order by which to sort the results.  Defaults to updated_asc
        :return: DestinationListSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_destinations_with_http_info(**kwargs)
        else:
            (data) = self.get_destinations_with_http_info(**kwargs)
            return data

    def get_destinations_with_http_info(self, **kwargs):
        """
        getAllDestinations
        Get a list of destinations.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_destinations_with_http_info(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str course_id: Only retreive resources having `courseId` 
        :param str more: Value for this parameter will be provided in the 'more' property of registration lists, where needed. An opaque value, construction and parsing may change without notice.
        :param datetime since: Only items updated since the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used.
        :param datetime until: Only items updated before the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used.
        :param list[str] tags:
        :param str datetime_filter: A string describing what the since/until parameters will be applied to. Options are: 'created' or 'updated'.  If not provided, it will default to `updated`.
        :param str order_by: Optional enum parameter for specifying the field and order by which to sort the results.  Defaults to updated_asc
        :return: DestinationListSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['course_id', 'more', 'since', 'until', 'tags', 'datetime_filter', 'order_by']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_destinations" % key
                )
            params[key] = val
        del params['kwargs']


        collection_formats = {}

        resource_path = '/dispatch/destinations'.replace('{format}', 'json')
        path_params = {}

        query_params = {}
        if 'course_id' in params:
            query_params['courseId'] = params['course_id']
        if 'more' in params:
            query_params['more'] = params['more']
        if 'since' in params:
            query_params['since'] = params['since']
        if 'until' in params:
            query_params['until'] = params['until']
        if 'tags' in params:
            query_params['tags'] = params['tags']
            collection_formats['tags'] = 'csv'
        if 'datetime_filter' in params:
            query_params['datetimeFilter'] = params['datetime_filter']
        if 'order_by' in params:
            query_params['orderBy'] = params['order_by']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['APP_NORMAL', 'OAUTH']

        return self.api_client.call_api(resource_path, 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='DestinationListSchema',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_dispatch(self, dispatch_id, **kwargs):
        """
        Get dispatch by id.
        Get the dispatch with `dispatchId`. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_dispatch(dispatch_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str dispatch_id: Identifier for the dispatch (required)
        :return: DispatchSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_dispatch_with_http_info(dispatch_id, **kwargs)
        else:
            (data) = self.get_dispatch_with_http_info(dispatch_id, **kwargs)
            return data

    def get_dispatch_with_http_info(self, dispatch_id, **kwargs):
        """
        Get dispatch by id.
        Get the dispatch with `dispatchId`. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_dispatch_with_http_info(dispatch_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str dispatch_id: Identifier for the dispatch (required)
        :return: DispatchSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['dispatch_id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_dispatch" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'dispatch_id' is set
        if ('dispatch_id' not in params) or (params['dispatch_id'] is None):
            raise ValueError("Missing the required parameter `dispatch_id` when calling `get_dispatch`")


        collection_formats = {}

        resource_path = '/dispatch/dispatches/{dispatchId}'.replace('{format}', 'json')
        path_params = {}
        if 'dispatch_id' in params:
            path_params['dispatchId'] = params['dispatch_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['APP_NORMAL', 'OAUTH']

        return self.api_client.call_api(resource_path, 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='DispatchSchema',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_dispatch_enabled(self, dispatch_id, **kwargs):
        """
        Get the `enabled` status for `dispatchId`. 
        Get the `enabled` status for `dispatchId`.  True if the dispatch is enabled, or false if it is disabled. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_dispatch_enabled(dispatch_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str dispatch_id: Identifier for the dispatch (required)
        :return: EnabledSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_dispatch_enabled_with_http_info(dispatch_id, **kwargs)
        else:
            (data) = self.get_dispatch_enabled_with_http_info(dispatch_id, **kwargs)
            return data

    def get_dispatch_enabled_with_http_info(self, dispatch_id, **kwargs):
        """
        Get the `enabled` status for `dispatchId`. 
        Get the `enabled` status for `dispatchId`.  True if the dispatch is enabled, or false if it is disabled. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_dispatch_enabled_with_http_info(dispatch_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str dispatch_id: Identifier for the dispatch (required)
        :return: EnabledSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['dispatch_id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_dispatch_enabled" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'dispatch_id' is set
        if ('dispatch_id' not in params) or (params['dispatch_id'] is None):
            raise ValueError("Missing the required parameter `dispatch_id` when calling `get_dispatch_enabled`")


        collection_formats = {}

        resource_path = '/dispatch/dispatches/{dispatchId}/enabled'.replace('{format}', 'json')
        path_params = {}
        if 'dispatch_id' in params:
            path_params['dispatchId'] = params['dispatch_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['APP_NORMAL', 'OAUTH']

        return self.api_client.call_api(resource_path, 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='EnabledSchema',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_dispatch_hash_user_info(self, dispatch_id, **kwargs):
        """
        Get if this dispatch has PII hashing enabled.
        Get if this dispatch has PII hashing enabled. True if the dispatch is set to hash user info, or false if it is disabled. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_dispatch_hash_user_info(dispatch_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str dispatch_id: Identifier for the dispatch (required)
        :return: EnabledSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_dispatch_hash_user_info_with_http_info(dispatch_id, **kwargs)
        else:
            (data) = self.get_dispatch_hash_user_info_with_http_info(dispatch_id, **kwargs)
            return data

    def get_dispatch_hash_user_info_with_http_info(self, dispatch_id, **kwargs):
        """
        Get if this dispatch has PII hashing enabled.
        Get if this dispatch has PII hashing enabled. True if the dispatch is set to hash user info, or false if it is disabled. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_dispatch_hash_user_info_with_http_info(dispatch_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str dispatch_id: Identifier for the dispatch (required)
        :return: EnabledSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['dispatch_id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_dispatch_hash_user_info" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'dispatch_id' is set
        if ('dispatch_id' not in params) or (params['dispatch_id'] is None):
            raise ValueError("Missing the required parameter `dispatch_id` when calling `get_dispatch_hash_user_info`")


        collection_formats = {}

        resource_path = '/dispatch/dispatches/{dispatchId}/hashUserInfo'.replace('{format}', 'json')
        path_params = {}
        if 'dispatch_id' in params:
            path_params['dispatchId'] = params['dispatch_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['APP_NORMAL', 'OAUTH']

        return self.api_client.call_api(resource_path, 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='EnabledSchema',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_dispatch_registration_count(self, dispatch_id, **kwargs):
        """
        Get the registration count for `dispatchId`. 
        Get the registration count for this dispatch, and the date and time of the last count reset, if any. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_dispatch_registration_count(dispatch_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str dispatch_id: Identifier for the dispatch (required)
        :return: DispatchRegistrationCountSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_dispatch_registration_count_with_http_info(dispatch_id, **kwargs)
        else:
            (data) = self.get_dispatch_registration_count_with_http_info(dispatch_id, **kwargs)
            return data

    def get_dispatch_registration_count_with_http_info(self, dispatch_id, **kwargs):
        """
        Get the registration count for `dispatchId`. 
        Get the registration count for this dispatch, and the date and time of the last count reset, if any. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_dispatch_registration_count_with_http_info(dispatch_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str dispatch_id: Identifier for the dispatch (required)
        :return: DispatchRegistrationCountSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['dispatch_id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_dispatch_registration_count" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'dispatch_id' is set
        if ('dispatch_id' not in params) or (params['dispatch_id'] is None):
            raise ValueError("Missing the required parameter `dispatch_id` when calling `get_dispatch_registration_count`")


        collection_formats = {}

        resource_path = '/dispatch/dispatches/{dispatchId}/registrationCount'.replace('{format}', 'json')
        path_params = {}
        if 'dispatch_id' in params:
            path_params['dispatchId'] = params['dispatch_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['APP_NORMAL', 'OAUTH']

        return self.api_client.call_api(resource_path, 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='DispatchRegistrationCountSchema',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_dispatch_tags(self, dispatch_id, **kwargs):
        """
        Get the tags for this dispatch. 
        Get the tags for this dispatch. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_dispatch_tags(dispatch_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str dispatch_id: Identifier for the dispatch (required)
        :return: TagListSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_dispatch_tags_with_http_info(dispatch_id, **kwargs)
        else:
            (data) = self.get_dispatch_tags_with_http_info(dispatch_id, **kwargs)
            return data

    def get_dispatch_tags_with_http_info(self, dispatch_id, **kwargs):
        """
        Get the tags for this dispatch. 
        Get the tags for this dispatch. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_dispatch_tags_with_http_info(dispatch_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str dispatch_id: Identifier for the dispatch (required)
        :return: TagListSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['dispatch_id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_dispatch_tags" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'dispatch_id' is set
        if ('dispatch_id' not in params) or (params['dispatch_id'] is None):
            raise ValueError("Missing the required parameter `dispatch_id` when calling `get_dispatch_tags`")


        collection_formats = {}

        resource_path = '/dispatch/dispatches/{dispatchId}/tags'.replace('{format}', 'json')
        path_params = {}
        if 'dispatch_id' in params:
            path_params['dispatchId'] = params['dispatch_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['APP_NORMAL', 'OAUTH']

        return self.api_client.call_api(resource_path, 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='TagListSchema',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_dispatch_zip(self, dispatch_id, **kwargs):
        """
        Get the ZIP for the dispatchId.
        Get the ZIP for the dispatch with `dispatchId` 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_dispatch_zip(dispatch_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str dispatch_id: Identifier for the dispatch (required)
        :param str type: The type of dispatch package to export (SCORM12 only supported in cloud today)
        :param str css_url:
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_dispatch_zip_with_http_info(dispatch_id, **kwargs)
        else:
            (data) = self.get_dispatch_zip_with_http_info(dispatch_id, **kwargs)
            return data

    def get_dispatch_zip_with_http_info(self, dispatch_id, **kwargs):
        """
        Get the ZIP for the dispatchId.
        Get the ZIP for the dispatch with `dispatchId` 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_dispatch_zip_with_http_info(dispatch_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str dispatch_id: Identifier for the dispatch (required)
        :param str type: The type of dispatch package to export (SCORM12 only supported in cloud today)
        :param str css_url:
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['dispatch_id', 'type', 'css_url']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_dispatch_zip" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'dispatch_id' is set
        if ('dispatch_id' not in params) or (params['dispatch_id'] is None):
            raise ValueError("Missing the required parameter `dispatch_id` when calling `get_dispatch_zip`")


        collection_formats = {}

        resource_path = '/dispatch/dispatches/{dispatchId}/zip'.replace('{format}', 'json')
        path_params = {}
        if 'dispatch_id' in params:
            path_params['dispatchId'] = params['dispatch_id']

        query_params = {}
        if 'type' in params:
            query_params['type'] = params['type']
        if 'css_url' in params:
            query_params['cssUrl'] = params['css_url']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/zip'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['APP_NORMAL', 'OAUTH']

        return self.api_client.call_api(resource_path, 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='file',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_dispatches(self, **kwargs):
        """
        All Dispatches in the system for an AppId
        Get a list of dispatches.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_dispatches(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str course_id: Only retreive resources having `courseId` 
        :param str more: Value for this parameter will be provided in the 'more' property of registration lists, where needed. An opaque value, construction and parsing may change without notice.
        :param datetime since: Only items updated since the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used.
        :param datetime until: Only items updated before the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used.
        :param list[str] tags:
        :param str datetime_filter: A string describing what the since/until parameters will be applied to. Options are: 'created' or 'updated'.  If not provided, it will default to `updated`.
        :param str order_by: Optional enum parameter for specifying the field and order by which to sort the results.  Defaults to updated_asc
        :return: DispatchListSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_dispatches_with_http_info(**kwargs)
        else:
            (data) = self.get_dispatches_with_http_info(**kwargs)
            return data

    def get_dispatches_with_http_info(self, **kwargs):
        """
        All Dispatches in the system for an AppId
        Get a list of dispatches.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_dispatches_with_http_info(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str course_id: Only retreive resources having `courseId` 
        :param str more: Value for this parameter will be provided in the 'more' property of registration lists, where needed. An opaque value, construction and parsing may change without notice.
        :param datetime since: Only items updated since the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used.
        :param datetime until: Only items updated before the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used.
        :param list[str] tags:
        :param str datetime_filter: A string describing what the since/until parameters will be applied to. Options are: 'created' or 'updated'.  If not provided, it will default to `updated`.
        :param str order_by: Optional enum parameter for specifying the field and order by which to sort the results.  Defaults to updated_asc
        :return: DispatchListSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['course_id', 'more', 'since', 'until', 'tags', 'datetime_filter', 'order_by']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_dispatches" % key
                )
            params[key] = val
        del params['kwargs']


        collection_formats = {}

        resource_path = '/dispatch/dispatches'.replace('{format}', 'json')
        path_params = {}

        query_params = {}
        if 'course_id' in params:
            query_params['courseId'] = params['course_id']
        if 'more' in params:
            query_params['more'] = params['more']
        if 'since' in params:
            query_params['since'] = params['since']
        if 'until' in params:
            query_params['until'] = params['until']
        if 'tags' in params:
            query_params['tags'] = params['tags']
            collection_formats['tags'] = 'csv'
        if 'datetime_filter' in params:
            query_params['datetimeFilter'] = params['datetime_filter']
        if 'order_by' in params:
            query_params['orderBy'] = params['order_by']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['APP_NORMAL', 'OAUTH']

        return self.api_client.call_api(resource_path, 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='DispatchListSchema',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def put_destination_tags(self, destination_id, tags, **kwargs):
        """
        Set the tags for this destination 
        Set the tags for this destination 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_destination_tags(destination_id, tags, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str destination_id: Identifier for the destination (required)
        :param TagListSchema tags: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.put_destination_tags_with_http_info(destination_id, tags, **kwargs)
        else:
            (data) = self.put_destination_tags_with_http_info(destination_id, tags, **kwargs)
            return data

    def put_destination_tags_with_http_info(self, destination_id, tags, **kwargs):
        """
        Set the tags for this destination 
        Set the tags for this destination 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_destination_tags_with_http_info(destination_id, tags, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str destination_id: Identifier for the destination (required)
        :param TagListSchema tags: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['destination_id', 'tags']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_destination_tags" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'destination_id' is set
        if ('destination_id' not in params) or (params['destination_id'] is None):
            raise ValueError("Missing the required parameter `destination_id` when calling `put_destination_tags`")
        # verify the required parameter 'tags' is set
        if ('tags' not in params) or (params['tags'] is None):
            raise ValueError("Missing the required parameter `tags` when calling `put_destination_tags`")


        collection_formats = {}

        resource_path = '/dispatch/destinations/{destinationId}/tags'.replace('{format}', 'json')
        path_params = {}
        if 'destination_id' in params:
            path_params['destinationId'] = params['destination_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'tags' in params:
            body_params = params['tags']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['APP_NORMAL', 'OAUTH']

        return self.api_client.call_api(resource_path, 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def put_destination_tags_batch(self, batch, **kwargs):
        """
        Sets all of the provided tags on all of the provided destinations
        Sets all of the provided tags on all of the provided destinations
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_destination_tags_batch(batch, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param BatchTagsSchema batch: Object representing an array of ids to apply an array of tags to. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.put_destination_tags_batch_with_http_info(batch, **kwargs)
        else:
            (data) = self.put_destination_tags_batch_with_http_info(batch, **kwargs)
            return data

    def put_destination_tags_batch_with_http_info(self, batch, **kwargs):
        """
        Sets all of the provided tags on all of the provided destinations
        Sets all of the provided tags on all of the provided destinations
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_destination_tags_batch_with_http_info(batch, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param BatchTagsSchema batch: Object representing an array of ids to apply an array of tags to. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['batch']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_destination_tags_batch" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'batch' is set
        if ('batch' not in params) or (params['batch'] is None):
            raise ValueError("Missing the required parameter `batch` when calling `put_destination_tags_batch`")


        collection_formats = {}

        resource_path = '/dispatch/destinations/tags'.replace('{format}', 'json')
        path_params = {}

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'batch' in params:
            body_params = params['batch']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['APP_NORMAL', 'OAUTH']

        return self.api_client.call_api(resource_path, 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def put_dispatch_tags(self, dispatch_id, tags, **kwargs):
        """
        Set the tags for this dispatch. 
        Set the tags for this dispatch. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_dispatch_tags(dispatch_id, tags, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str dispatch_id: Identifier for the dispatch (required)
        :param TagListSchema tags: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.put_dispatch_tags_with_http_info(dispatch_id, tags, **kwargs)
        else:
            (data) = self.put_dispatch_tags_with_http_info(dispatch_id, tags, **kwargs)
            return data

    def put_dispatch_tags_with_http_info(self, dispatch_id, tags, **kwargs):
        """
        Set the tags for this dispatch. 
        Set the tags for this dispatch. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_dispatch_tags_with_http_info(dispatch_id, tags, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str dispatch_id: Identifier for the dispatch (required)
        :param TagListSchema tags: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['dispatch_id', 'tags']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_dispatch_tags" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'dispatch_id' is set
        if ('dispatch_id' not in params) or (params['dispatch_id'] is None):
            raise ValueError("Missing the required parameter `dispatch_id` when calling `put_dispatch_tags`")
        # verify the required parameter 'tags' is set
        if ('tags' not in params) or (params['tags'] is None):
            raise ValueError("Missing the required parameter `tags` when calling `put_dispatch_tags`")


        collection_formats = {}

        resource_path = '/dispatch/dispatches/{dispatchId}/tags'.replace('{format}', 'json')
        path_params = {}
        if 'dispatch_id' in params:
            path_params['dispatchId'] = params['dispatch_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'tags' in params:
            body_params = params['tags']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['APP_NORMAL', 'OAUTH']

        return self.api_client.call_api(resource_path, 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def put_dispatch_tags_batch(self, batch, **kwargs):
        """
        Sets all of the provided tags on all of the provided dispatches 
        Sets all of the provided tags on all of the provided dispatches 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_dispatch_tags_batch(batch, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param BatchTagsSchema batch: Object representing an array of ids to apply an array of tags to. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.put_dispatch_tags_batch_with_http_info(batch, **kwargs)
        else:
            (data) = self.put_dispatch_tags_batch_with_http_info(batch, **kwargs)
            return data

    def put_dispatch_tags_batch_with_http_info(self, batch, **kwargs):
        """
        Sets all of the provided tags on all of the provided dispatches 
        Sets all of the provided tags on all of the provided dispatches 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_dispatch_tags_batch_with_http_info(batch, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param BatchTagsSchema batch: Object representing an array of ids to apply an array of tags to. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['batch']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_dispatch_tags_batch" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'batch' is set
        if ('batch' not in params) or (params['batch'] is None):
            raise ValueError("Missing the required parameter `batch` when calling `put_dispatch_tags_batch`")


        collection_formats = {}

        resource_path = '/dispatch/dispatches/tags'.replace('{format}', 'json')
        path_params = {}

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'batch' in params:
            body_params = params['batch']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['APP_NORMAL', 'OAUTH']

        return self.api_client.call_api(resource_path, 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def reset_destination_dispatch_registration_count(self, destination_id, **kwargs):
        """
        DestinationsDispatchesRegistrationCount
        Reset registration counts for all related dispatches.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.reset_destination_dispatch_registration_count(destination_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str destination_id: Identifier for the destination (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.reset_destination_dispatch_registration_count_with_http_info(destination_id, **kwargs)
        else:
            (data) = self.reset_destination_dispatch_registration_count_with_http_info(destination_id, **kwargs)
            return data

    def reset_destination_dispatch_registration_count_with_http_info(self, destination_id, **kwargs):
        """
        DestinationsDispatchesRegistrationCount
        Reset registration counts for all related dispatches.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.reset_destination_dispatch_registration_count_with_http_info(destination_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str destination_id: Identifier for the destination (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['destination_id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method reset_destination_dispatch_registration_count" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'destination_id' is set
        if ('destination_id' not in params) or (params['destination_id'] is None):
            raise ValueError("Missing the required parameter `destination_id` when calling `reset_destination_dispatch_registration_count`")


        collection_formats = {}

        resource_path = '/dispatch/destinations/{destinationId}/dispatches/registrationCount'.replace('{format}', 'json')
        path_params = {}
        if 'destination_id' in params:
            path_params['destinationId'] = params['destination_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['APP_NORMAL', 'OAUTH']

        return self.api_client.call_api(resource_path, 'DELETE',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def reset_dispatch_registration_count(self, dispatch_id, **kwargs):
        """
        Reset registration count. 
        Reset the registration count for this dispatch. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.reset_dispatch_registration_count(dispatch_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str dispatch_id: Identifier for the dispatch (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.reset_dispatch_registration_count_with_http_info(dispatch_id, **kwargs)
        else:
            (data) = self.reset_dispatch_registration_count_with_http_info(dispatch_id, **kwargs)
            return data

    def reset_dispatch_registration_count_with_http_info(self, dispatch_id, **kwargs):
        """
        Reset registration count. 
        Reset the registration count for this dispatch. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.reset_dispatch_registration_count_with_http_info(dispatch_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str dispatch_id: Identifier for the dispatch (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['dispatch_id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method reset_dispatch_registration_count" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'dispatch_id' is set
        if ('dispatch_id' not in params) or (params['dispatch_id'] is None):
            raise ValueError("Missing the required parameter `dispatch_id` when calling `reset_dispatch_registration_count`")


        collection_formats = {}

        resource_path = '/dispatch/dispatches/{dispatchId}/registrationCount'.replace('{format}', 'json')
        path_params = {}
        if 'dispatch_id' in params:
            path_params['dispatchId'] = params['dispatch_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['APP_NORMAL', 'OAUTH']

        return self.api_client.call_api(resource_path, 'DELETE',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def set_destination(self, destination_id, destination, **kwargs):
        """
        Creates or updates the destination identified by the `destinationId` provided in the path. If the destination is being created, a name should be provided in the DestinationSchema, else an error will be thrown.  You may also optionally supply the e-mail address of the user to be associated with this destination.  This e-mail address should correspond to a SCORM Cloud user account. If you do not supply an e-mail address upon the creation of a destination, the owner of the Realm will be used.  This can, of course, also be changed via calling this method to update an existing destination. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.set_destination(destination_id, destination, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str destination_id: Identifier for the destination (required)
        :param DestinationSchema destination: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.set_destination_with_http_info(destination_id, destination, **kwargs)
        else:
            (data) = self.set_destination_with_http_info(destination_id, destination, **kwargs)
            return data

    def set_destination_with_http_info(self, destination_id, destination, **kwargs):
        """
        Creates or updates the destination identified by the `destinationId` provided in the path. If the destination is being created, a name should be provided in the DestinationSchema, else an error will be thrown.  You may also optionally supply the e-mail address of the user to be associated with this destination.  This e-mail address should correspond to a SCORM Cloud user account. If you do not supply an e-mail address upon the creation of a destination, the owner of the Realm will be used.  This can, of course, also be changed via calling this method to update an existing destination. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.set_destination_with_http_info(destination_id, destination, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str destination_id: Identifier for the destination (required)
        :param DestinationSchema destination: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['destination_id', 'destination']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method set_destination" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'destination_id' is set
        if ('destination_id' not in params) or (params['destination_id'] is None):
            raise ValueError("Missing the required parameter `destination_id` when calling `set_destination`")
        # verify the required parameter 'destination' is set
        if ('destination' not in params) or (params['destination'] is None):
            raise ValueError("Missing the required parameter `destination` when calling `set_destination`")


        collection_formats = {}

        resource_path = '/dispatch/destinations/{destinationId}'.replace('{format}', 'json')
        path_params = {}
        if 'destination_id' in params:
            path_params['destinationId'] = params['destination_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'destination' in params:
            body_params = params['destination']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['APP_NORMAL', 'OAUTH']

        return self.api_client.call_api(resource_path, 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def set_destination_dispatch_enabled(self, destination_id, enabled, **kwargs):
        """
        DestinationsDispatchesEnabledByTenant
        Enable or disable all related dispatches.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.set_destination_dispatch_enabled(destination_id, enabled, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str destination_id: Identifier for the destination (required)
        :param EnabledSchema enabled:  (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.set_destination_dispatch_enabled_with_http_info(destination_id, enabled, **kwargs)
        else:
            (data) = self.set_destination_dispatch_enabled_with_http_info(destination_id, enabled, **kwargs)
            return data

    def set_destination_dispatch_enabled_with_http_info(self, destination_id, enabled, **kwargs):
        """
        DestinationsDispatchesEnabledByTenant
        Enable or disable all related dispatches.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.set_destination_dispatch_enabled_with_http_info(destination_id, enabled, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str destination_id: Identifier for the destination (required)
        :param EnabledSchema enabled:  (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['destination_id', 'enabled']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method set_destination_dispatch_enabled" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'destination_id' is set
        if ('destination_id' not in params) or (params['destination_id'] is None):
            raise ValueError("Missing the required parameter `destination_id` when calling `set_destination_dispatch_enabled`")
        # verify the required parameter 'enabled' is set
        if ('enabled' not in params) or (params['enabled'] is None):
            raise ValueError("Missing the required parameter `enabled` when calling `set_destination_dispatch_enabled`")


        collection_formats = {}

        resource_path = '/dispatch/destinations/{destinationId}/dispatches/enabled'.replace('{format}', 'json')
        path_params = {}
        if 'destination_id' in params:
            path_params['destinationId'] = params['destination_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'enabled' in params:
            body_params = params['enabled']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['APP_NORMAL', 'OAUTH']

        return self.api_client.call_api(resource_path, 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def set_dispatch_enabled(self, dispatch_id, enabled, **kwargs):
        """
        Set the `enabled` status for `dispatchId`. 
        Set the `enabled` status for `dispatchId`. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.set_dispatch_enabled(dispatch_id, enabled, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str dispatch_id: Identifier for the dispatch (required)
        :param EnabledSchema enabled:  (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.set_dispatch_enabled_with_http_info(dispatch_id, enabled, **kwargs)
        else:
            (data) = self.set_dispatch_enabled_with_http_info(dispatch_id, enabled, **kwargs)
            return data

    def set_dispatch_enabled_with_http_info(self, dispatch_id, enabled, **kwargs):
        """
        Set the `enabled` status for `dispatchId`. 
        Set the `enabled` status for `dispatchId`. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.set_dispatch_enabled_with_http_info(dispatch_id, enabled, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str dispatch_id: Identifier for the dispatch (required)
        :param EnabledSchema enabled:  (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['dispatch_id', 'enabled']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method set_dispatch_enabled" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'dispatch_id' is set
        if ('dispatch_id' not in params) or (params['dispatch_id'] is None):
            raise ValueError("Missing the required parameter `dispatch_id` when calling `set_dispatch_enabled`")
        # verify the required parameter 'enabled' is set
        if ('enabled' not in params) or (params['enabled'] is None):
            raise ValueError("Missing the required parameter `enabled` when calling `set_dispatch_enabled`")


        collection_formats = {}

        resource_path = '/dispatch/dispatches/{dispatchId}/enabled'.replace('{format}', 'json')
        path_params = {}
        if 'dispatch_id' in params:
            path_params['dispatchId'] = params['dispatch_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'enabled' in params:
            body_params = params['enabled']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['APP_NORMAL', 'OAUTH']

        return self.api_client.call_api(resource_path, 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def update_destination_hash_user_info(self, destination_id, enabled, **kwargs):
        """
        Enable or disable hashing of the user info for the destination.
        Enable or disable hashing of the user info for the destination.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.update_destination_hash_user_info(destination_id, enabled, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str destination_id: Identifier for the destination (required)
        :param EnabledSchema enabled: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.update_destination_hash_user_info_with_http_info(destination_id, enabled, **kwargs)
        else:
            (data) = self.update_destination_hash_user_info_with_http_info(destination_id, enabled, **kwargs)
            return data

    def update_destination_hash_user_info_with_http_info(self, destination_id, enabled, **kwargs):
        """
        Enable or disable hashing of the user info for the destination.
        Enable or disable hashing of the user info for the destination.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.update_destination_hash_user_info_with_http_info(destination_id, enabled, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str destination_id: Identifier for the destination (required)
        :param EnabledSchema enabled: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['destination_id', 'enabled']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_destination_hash_user_info" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'destination_id' is set
        if ('destination_id' not in params) or (params['destination_id'] is None):
            raise ValueError("Missing the required parameter `destination_id` when calling `update_destination_hash_user_info`")
        # verify the required parameter 'enabled' is set
        if ('enabled' not in params) or (params['enabled'] is None):
            raise ValueError("Missing the required parameter `enabled` when calling `update_destination_hash_user_info`")


        collection_formats = {}

        resource_path = '/dispatch/destinations/{destinationId}/dispatches/hashUserInfo'.replace('{format}', 'json')
        path_params = {}
        if 'destination_id' in params:
            path_params['destinationId'] = params['destination_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'enabled' in params:
            body_params = params['enabled']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['APP_NORMAL', 'OAUTH']

        return self.api_client.call_api(resource_path, 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def update_dispatch(self, dispatch_id, dispatch_properties, **kwargs):
        """
        Update the dispatch with `dispatchId`. 
        Update the dispatch with `dispatchId`. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.update_dispatch(dispatch_id, dispatch_properties, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str dispatch_id: Identifier for the dispatch (required)
        :param UpdateDispatchSchema dispatch_properties: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.update_dispatch_with_http_info(dispatch_id, dispatch_properties, **kwargs)
        else:
            (data) = self.update_dispatch_with_http_info(dispatch_id, dispatch_properties, **kwargs)
            return data

    def update_dispatch_with_http_info(self, dispatch_id, dispatch_properties, **kwargs):
        """
        Update the dispatch with `dispatchId`. 
        Update the dispatch with `dispatchId`. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.update_dispatch_with_http_info(dispatch_id, dispatch_properties, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str dispatch_id: Identifier for the dispatch (required)
        :param UpdateDispatchSchema dispatch_properties: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['dispatch_id', 'dispatch_properties']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_dispatch" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'dispatch_id' is set
        if ('dispatch_id' not in params) or (params['dispatch_id'] is None):
            raise ValueError("Missing the required parameter `dispatch_id` when calling `update_dispatch`")
        # verify the required parameter 'dispatch_properties' is set
        if ('dispatch_properties' not in params) or (params['dispatch_properties'] is None):
            raise ValueError("Missing the required parameter `dispatch_properties` when calling `update_dispatch`")


        collection_formats = {}

        resource_path = '/dispatch/dispatches/{dispatchId}'.replace('{format}', 'json')
        path_params = {}
        if 'dispatch_id' in params:
            path_params['dispatchId'] = params['dispatch_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'dispatch_properties' in params:
            body_params = params['dispatch_properties']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['APP_NORMAL', 'OAUTH']

        return self.api_client.call_api(resource_path, 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def update_dispatch_hash_user_info(self, dispatch_id, enabled, **kwargs):
        """
        Enable or disable hashing of the user info for the dispatch.
        Enable or disable hashing of the user info for the dispatch.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.update_dispatch_hash_user_info(dispatch_id, enabled, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str dispatch_id: Identifier for the dispatch (required)
        :param EnabledSchema enabled: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.update_dispatch_hash_user_info_with_http_info(dispatch_id, enabled, **kwargs)
        else:
            (data) = self.update_dispatch_hash_user_info_with_http_info(dispatch_id, enabled, **kwargs)
            return data

    def update_dispatch_hash_user_info_with_http_info(self, dispatch_id, enabled, **kwargs):
        """
        Enable or disable hashing of the user info for the dispatch.
        Enable or disable hashing of the user info for the dispatch.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.update_dispatch_hash_user_info_with_http_info(dispatch_id, enabled, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str dispatch_id: Identifier for the dispatch (required)
        :param EnabledSchema enabled: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['dispatch_id', 'enabled']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_dispatch_hash_user_info" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'dispatch_id' is set
        if ('dispatch_id' not in params) or (params['dispatch_id'] is None):
            raise ValueError("Missing the required parameter `dispatch_id` when calling `update_dispatch_hash_user_info`")
        # verify the required parameter 'enabled' is set
        if ('enabled' not in params) or (params['enabled'] is None):
            raise ValueError("Missing the required parameter `enabled` when calling `update_dispatch_hash_user_info`")


        collection_formats = {}

        resource_path = '/dispatch/dispatches/{dispatchId}/hashUserInfo'.replace('{format}', 'json')
        path_params = {}
        if 'dispatch_id' in params:
            path_params['dispatchId'] = params['dispatch_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'enabled' in params:
            body_params = params['enabled']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['APP_NORMAL', 'OAUTH']

        return self.api_client.call_api(resource_path, 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)
