# coding: utf-8

"""
    SCORM Cloud Rest API

    REST API used for SCORM Cloud integrations.  # noqa: E501

    OpenAPI spec version: 2.0
    Contact: systems@rusticisoftware.com
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from rustici_software_cloud_v2.api_client import ApiClient


class InvitationsApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def create_private_invitation(self, private_invitation_request, **kwargs):  # noqa: E501
        """Create a Private Invitation to a Course   # noqa: E501

        Creates a private invitation job which sends emails with a link to the course.  Invitations are meant as a way to provide access to your content.  Registrations will be created from the provided email addresses.  The email job will asynchronously send emails to those addresses inviting them to the course.  When the learners visit the link in the email, the course will be launched with the already created registration.  The private invitation ID can be used with GetPrivateInvitationJobStatus to view the status of the email job.  >**Info:** >While invitations are a way to provide access to your content, the majority of use cases would be better suited by creating a registration and building a launch link with the registration endpoints instead.  Invitations build upon registrations by grouping a set of registrations together and adding access control measures to said group. Invitations could be used to pass yearly compliance training to an entire company.  Invitations also have an associated expiration date which determines when the course will no longer be launchable.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_private_invitation(private_invitation_request, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param CreatePrivateInvitationSchema private_invitation_request:  (required)
        :return: InvitationSummarySchema
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_private_invitation_with_http_info(private_invitation_request, **kwargs)  # noqa: E501
        else:
            (data) = self.create_private_invitation_with_http_info(private_invitation_request, **kwargs)  # noqa: E501
            return data

    def create_private_invitation_with_http_info(self, private_invitation_request, **kwargs):  # noqa: E501
        """Create a Private Invitation to a Course   # noqa: E501

        Creates a private invitation job which sends emails with a link to the course.  Invitations are meant as a way to provide access to your content.  Registrations will be created from the provided email addresses.  The email job will asynchronously send emails to those addresses inviting them to the course.  When the learners visit the link in the email, the course will be launched with the already created registration.  The private invitation ID can be used with GetPrivateInvitationJobStatus to view the status of the email job.  >**Info:** >While invitations are a way to provide access to your content, the majority of use cases would be better suited by creating a registration and building a launch link with the registration endpoints instead.  Invitations build upon registrations by grouping a set of registrations together and adding access control measures to said group. Invitations could be used to pass yearly compliance training to an entire company.  Invitations also have an associated expiration date which determines when the course will no longer be launchable.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_private_invitation_with_http_info(private_invitation_request, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param CreatePrivateInvitationSchema private_invitation_request:  (required)
        :return: InvitationSummarySchema
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['private_invitation_request']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_private_invitation" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'private_invitation_request' is set
        if ('private_invitation_request' not in params or
                params['private_invitation_request'] is None):
            raise ValueError("Missing the required parameter `private_invitation_request` when calling `create_private_invitation`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'private_invitation_request' in params:
            body_params = params['private_invitation_request']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APP_NORMAL', 'OAUTH']  # noqa: E501

        return self.api_client.call_api(
            '/invitations/private', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InvitationSummarySchema',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_public_invitation(self, public_invitation_request, **kwargs):  # noqa: E501
        """Create a Public Invitation to a Course   # noqa: E501

        Creates an invitation link to the course which can then be publicly distributed.  Invitations are meant as a way to provide access to your content.  When a learner visits the link, they will be prompted for name and email, a registration will be created from the information provided, and they will be redirected to the course.  Since anyone visiting the link will create a registration, it is highly advised that you set the `registrationCap` parameter when calling this method.  >**Info:** >While invitations are a way to provide access to your content, the majority of use cases would be better suited by creating a registration and building a launch link with the registration endpoints instead.  Invitations build upon registrations by grouping a set of registrations together and adding access control measures to said group. Invitations could be used to pass yearly compliance training to an entire company.  Invitations also have an associated expiration date which determines when the course will no longer be launchable.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_public_invitation(public_invitation_request, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param CreatePublicInvitationSchema public_invitation_request: A description of the public invitation to be created. (required)
        :return: PublicInvitationSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_public_invitation_with_http_info(public_invitation_request, **kwargs)  # noqa: E501
        else:
            (data) = self.create_public_invitation_with_http_info(public_invitation_request, **kwargs)  # noqa: E501
            return data

    def create_public_invitation_with_http_info(self, public_invitation_request, **kwargs):  # noqa: E501
        """Create a Public Invitation to a Course   # noqa: E501

        Creates an invitation link to the course which can then be publicly distributed.  Invitations are meant as a way to provide access to your content.  When a learner visits the link, they will be prompted for name and email, a registration will be created from the information provided, and they will be redirected to the course.  Since anyone visiting the link will create a registration, it is highly advised that you set the `registrationCap` parameter when calling this method.  >**Info:** >While invitations are a way to provide access to your content, the majority of use cases would be better suited by creating a registration and building a launch link with the registration endpoints instead.  Invitations build upon registrations by grouping a set of registrations together and adding access control measures to said group. Invitations could be used to pass yearly compliance training to an entire company.  Invitations also have an associated expiration date which determines when the course will no longer be launchable.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_public_invitation_with_http_info(public_invitation_request, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param CreatePublicInvitationSchema public_invitation_request: A description of the public invitation to be created. (required)
        :return: PublicInvitationSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['public_invitation_request']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_public_invitation" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'public_invitation_request' is set
        if ('public_invitation_request' not in params or
                params['public_invitation_request'] is None):
            raise ValueError("Missing the required parameter `public_invitation_request` when calling `create_public_invitation`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'public_invitation_request' in params:
            body_params = params['public_invitation_request']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APP_NORMAL', 'OAUTH']  # noqa: E501

        return self.api_client.call_api(
            '/invitations/public', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PublicInvitationSchema',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_invitation_tags(self, invitation_id, tags, **kwargs):  # noqa: E501
        """Delete tags from an Invitation   # noqa: E501

        Deletes the specified tags from the invitation.  Deleting tags that do not exist will still result in a success.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_invitation_tags(invitation_id, tags, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str invitation_id: (required)
        :param TagListSchema tags: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_invitation_tags_with_http_info(invitation_id, tags, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_invitation_tags_with_http_info(invitation_id, tags, **kwargs)  # noqa: E501
            return data

    def delete_invitation_tags_with_http_info(self, invitation_id, tags, **kwargs):  # noqa: E501
        """Delete tags from an Invitation   # noqa: E501

        Deletes the specified tags from the invitation.  Deleting tags that do not exist will still result in a success.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_invitation_tags_with_http_info(invitation_id, tags, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str invitation_id: (required)
        :param TagListSchema tags: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['invitation_id', 'tags']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_invitation_tags" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'invitation_id' is set
        if ('invitation_id' not in params or
                params['invitation_id'] is None):
            raise ValueError("Missing the required parameter `invitation_id` when calling `delete_invitation_tags`")  # noqa: E501
        # verify the required parameter 'tags' is set
        if ('tags' not in params or
                params['tags'] is None):
            raise ValueError("Missing the required parameter `tags` when calling `delete_invitation_tags`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'invitation_id' in params:
            path_params['invitationId'] = params['invitation_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'tags' in params:
            body_params = params['tags']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APP_NORMAL', 'OAUTH']  # noqa: E501

        return self.api_client.call_api(
            '/invitations/{invitationId}/tags', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_all_invitations(self, **kwargs):  # noqa: E501
        """Get a list of Invitations   # noqa: E501

        Returns a list of invitations (both public and private).  Can be filtered using the request parameters to provide a subset of results.  >**Note:** >This request is paginated and will only provide a limited amount of resources at a time.  If there are more results to be collected, a `more` token provided with the response which can be passed to get the next page of results.  When passing this token, no other filter parameters can be sent as part of the request.  The resources will continue to respect the filters passed in by the original request.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_invitations(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: Only retrieve resources having `courseId`
        :param datetime since: Filter by ISO 8601 TimeStamp inclusive (defaults to UTC)
        :param datetime until: Filter by ISO 8601 TimeStamp inclusive (defaults to UTC)
        :param str datetime_filter: Specifies field that `since` and `until` parameters are applied against
        :param list[str] tags: Filter items matching any tag provided (not all)
        :param str filter: Optional string which filters results by a specified field (described by filterBy).
        :param str filter_by: Optional enum parameter for specifying the field on which to run the filter. 
        :param str order_by: Optional enum parameter for specifying the field and order by which to sort the results. 
        :param str more: Pagination token returned as `more` property of multi page list requests
        :return: InvitationSummaryList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_all_invitations_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_all_invitations_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_all_invitations_with_http_info(self, **kwargs):  # noqa: E501
        """Get a list of Invitations   # noqa: E501

        Returns a list of invitations (both public and private).  Can be filtered using the request parameters to provide a subset of results.  >**Note:** >This request is paginated and will only provide a limited amount of resources at a time.  If there are more results to be collected, a `more` token provided with the response which can be passed to get the next page of results.  When passing this token, no other filter parameters can be sent as part of the request.  The resources will continue to respect the filters passed in by the original request.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_invitations_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: Only retrieve resources having `courseId`
        :param datetime since: Filter by ISO 8601 TimeStamp inclusive (defaults to UTC)
        :param datetime until: Filter by ISO 8601 TimeStamp inclusive (defaults to UTC)
        :param str datetime_filter: Specifies field that `since` and `until` parameters are applied against
        :param list[str] tags: Filter items matching any tag provided (not all)
        :param str filter: Optional string which filters results by a specified field (described by filterBy).
        :param str filter_by: Optional enum parameter for specifying the field on which to run the filter. 
        :param str order_by: Optional enum parameter for specifying the field and order by which to sort the results. 
        :param str more: Pagination token returned as `more` property of multi page list requests
        :return: InvitationSummaryList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['course_id', 'since', 'until', 'datetime_filter', 'tags', 'filter', 'filter_by', 'order_by', 'more']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_all_invitations" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'course_id' in params:
            query_params.append(('courseId', params['course_id']))  # noqa: E501
        if 'since' in params:
            query_params.append(('since', params['since']))  # noqa: E501
        if 'until' in params:
            query_params.append(('until', params['until']))  # noqa: E501
        if 'datetime_filter' in params:
            query_params.append(('datetimeFilter', params['datetime_filter']))  # noqa: E501
        if 'tags' in params:
            query_params.append(('tags', params['tags']))  # noqa: E501
            collection_formats['tags'] = 'csv'  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501
        if 'filter_by' in params:
            query_params.append(('filterBy', params['filter_by']))  # noqa: E501
        if 'order_by' in params:
            query_params.append(('orderBy', params['order_by']))  # noqa: E501
        if 'more' in params:
            query_params.append(('more', params['more']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APP_NORMAL', 'OAUTH']  # noqa: E501

        return self.api_client.call_api(
            '/invitations', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InvitationSummaryList',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_invitation_tags(self, invitation_id, **kwargs):  # noqa: E501
        """Get tags for an Invitation   # noqa: E501

        Returns the tags for the invitation.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_invitation_tags(invitation_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str invitation_id: (required)
        :return: TagListSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_invitation_tags_with_http_info(invitation_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_invitation_tags_with_http_info(invitation_id, **kwargs)  # noqa: E501
            return data

    def get_invitation_tags_with_http_info(self, invitation_id, **kwargs):  # noqa: E501
        """Get tags for an Invitation   # noqa: E501

        Returns the tags for the invitation.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_invitation_tags_with_http_info(invitation_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str invitation_id: (required)
        :return: TagListSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['invitation_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_invitation_tags" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'invitation_id' is set
        if ('invitation_id' not in params or
                params['invitation_id'] is None):
            raise ValueError("Missing the required parameter `invitation_id` when calling `get_invitation_tags`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'invitation_id' in params:
            path_params['invitationId'] = params['invitation_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APP_NORMAL', 'OAUTH']  # noqa: E501

        return self.api_client.call_api(
            '/invitations/{invitationId}/tags', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TagListSchema',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_private_invitation(self, invitation_id, **kwargs):  # noqa: E501
        """Get detailed information about a Private Invitation   # noqa: E501

        Returns detailed information about the private invitation.  This includes the email sent, course ID, and whether new the invitation can still be launched or not.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_private_invitation(invitation_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str invitation_id: (required)
        :param bool include_registration_count: Include the registration count in the results
        :return: PrivateInvitationSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_private_invitation_with_http_info(invitation_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_private_invitation_with_http_info(invitation_id, **kwargs)  # noqa: E501
            return data

    def get_private_invitation_with_http_info(self, invitation_id, **kwargs):  # noqa: E501
        """Get detailed information about a Private Invitation   # noqa: E501

        Returns detailed information about the private invitation.  This includes the email sent, course ID, and whether new the invitation can still be launched or not.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_private_invitation_with_http_info(invitation_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str invitation_id: (required)
        :param bool include_registration_count: Include the registration count in the results
        :return: PrivateInvitationSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['invitation_id', 'include_registration_count']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_private_invitation" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'invitation_id' is set
        if ('invitation_id' not in params or
                params['invitation_id'] is None):
            raise ValueError("Missing the required parameter `invitation_id` when calling `get_private_invitation`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'invitation_id' in params:
            path_params['invitationId'] = params['invitation_id']  # noqa: E501

        query_params = []
        if 'include_registration_count' in params:
            query_params.append(('includeRegistrationCount', params['include_registration_count']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APP_NORMAL', 'OAUTH']  # noqa: E501

        return self.api_client.call_api(
            '/invitations/private/{invitationId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PrivateInvitationSchema',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_private_invitation_job_status(self, invitation_id, **kwargs):  # noqa: E501
        """Get email job status for a Private Invitation   # noqa: E501

        Check the status of a private invitation email job.  This can be called incrementally to check the progress of the emails.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_private_invitation_job_status(invitation_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str invitation_id: (required)
        :return: InvitationJobStatusSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_private_invitation_job_status_with_http_info(invitation_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_private_invitation_job_status_with_http_info(invitation_id, **kwargs)  # noqa: E501
            return data

    def get_private_invitation_job_status_with_http_info(self, invitation_id, **kwargs):  # noqa: E501
        """Get email job status for a Private Invitation   # noqa: E501

        Check the status of a private invitation email job.  This can be called incrementally to check the progress of the emails.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_private_invitation_job_status_with_http_info(invitation_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str invitation_id: (required)
        :return: InvitationJobStatusSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['invitation_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_private_invitation_job_status" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'invitation_id' is set
        if ('invitation_id' not in params or
                params['invitation_id'] is None):
            raise ValueError("Missing the required parameter `invitation_id` when calling `get_private_invitation_job_status`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'invitation_id' in params:
            path_params['invitationId'] = params['invitation_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APP_NORMAL', 'OAUTH']  # noqa: E501

        return self.api_client.call_api(
            '/invitations/private/{invitationId}/jobStatus', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InvitationJobStatusSchema',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_private_invitations(self, **kwargs):  # noqa: E501
        """Get a list of Private Invitations   # noqa: E501

        Returns a list of private invitations.  Can be filtered using the request parameters to provide a subset of results.  >**Note:** >This request is paginated and will only provide a limited amount of resources at a time.  If there are more results to be collected, a `more` token provided with the response which can be passed to get the next page of results.  When passing this token, no other filter parameters can be sent as part of the request.  The resources will continue to respect the filters passed in by the original request.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_private_invitations(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: Only retrieve resources having `courseId`
        :param datetime since: Filter by ISO 8601 TimeStamp inclusive (defaults to UTC)
        :param datetime until: Filter by ISO 8601 TimeStamp inclusive (defaults to UTC)
        :param str datetime_filter: Specifies field that `since` and `until` parameters are applied against
        :param list[str] tags: Filter items matching any tag provided (not all)
        :param str filter: Optional string which filters results by a specified field (described by filterBy).
        :param str filter_by: Optional enum parameter for specifying the field on which to run the filter. 
        :param str order_by: Optional enum parameter for specifying the field and order by which to sort the results. 
        :param str more: Pagination token returned as `more` property of multi page list requests
        :return: PrivateInvitationList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_private_invitations_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_private_invitations_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_private_invitations_with_http_info(self, **kwargs):  # noqa: E501
        """Get a list of Private Invitations   # noqa: E501

        Returns a list of private invitations.  Can be filtered using the request parameters to provide a subset of results.  >**Note:** >This request is paginated and will only provide a limited amount of resources at a time.  If there are more results to be collected, a `more` token provided with the response which can be passed to get the next page of results.  When passing this token, no other filter parameters can be sent as part of the request.  The resources will continue to respect the filters passed in by the original request.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_private_invitations_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: Only retrieve resources having `courseId`
        :param datetime since: Filter by ISO 8601 TimeStamp inclusive (defaults to UTC)
        :param datetime until: Filter by ISO 8601 TimeStamp inclusive (defaults to UTC)
        :param str datetime_filter: Specifies field that `since` and `until` parameters are applied against
        :param list[str] tags: Filter items matching any tag provided (not all)
        :param str filter: Optional string which filters results by a specified field (described by filterBy).
        :param str filter_by: Optional enum parameter for specifying the field on which to run the filter. 
        :param str order_by: Optional enum parameter for specifying the field and order by which to sort the results. 
        :param str more: Pagination token returned as `more` property of multi page list requests
        :return: PrivateInvitationList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['course_id', 'since', 'until', 'datetime_filter', 'tags', 'filter', 'filter_by', 'order_by', 'more']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_private_invitations" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'course_id' in params:
            query_params.append(('courseId', params['course_id']))  # noqa: E501
        if 'since' in params:
            query_params.append(('since', params['since']))  # noqa: E501
        if 'until' in params:
            query_params.append(('until', params['until']))  # noqa: E501
        if 'datetime_filter' in params:
            query_params.append(('datetimeFilter', params['datetime_filter']))  # noqa: E501
        if 'tags' in params:
            query_params.append(('tags', params['tags']))  # noqa: E501
            collection_formats['tags'] = 'csv'  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501
        if 'filter_by' in params:
            query_params.append(('filterBy', params['filter_by']))  # noqa: E501
        if 'order_by' in params:
            query_params.append(('orderBy', params['order_by']))  # noqa: E501
        if 'more' in params:
            query_params.append(('more', params['more']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APP_NORMAL', 'OAUTH']  # noqa: E501

        return self.api_client.call_api(
            '/invitations/private', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PrivateInvitationList',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_private_user_invitations(self, invitation_id, **kwargs):  # noqa: E501
        """Get a list of Private User Invitations   # noqa: E501

        Get a list of user who were invited to view the course.  Can be filtered using the request parameters to provide a subset of results.  >**Note:** >This request is paginated and will only provide a limited amount of resources at a time.  If there are more results to be collected, a `more` token provided with the response which can be passed to get the next page of results.  When passing this token, no other filter parameters can be sent as part of the request.  The resources will continue to respect the filters passed in by the original request.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_private_user_invitations(invitation_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str invitation_id: (required)
        :param datetime since: Filter by ISO 8601 TimeStamp inclusive (defaults to UTC)
        :param datetime until: Filter by ISO 8601 TimeStamp inclusive (defaults to UTC)
        :param str datetime_filter: Specifies field that `since` and `until` parameters are applied against
        :param str filter: Optional string which filters results by a specified field (described by filterBy).
        :param str filter_by: Optional enum parameter for specifying the field on which to run the filter. 
        :param str order_by: Optional enum parameter for specifying the field and order by which to sort the results. 
        :param str more: Pagination token returned as `more` property of multi page list requests
        :param bool include_registration_report: Optional flag to include basic registration information
        :return: UserInvitationList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_private_user_invitations_with_http_info(invitation_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_private_user_invitations_with_http_info(invitation_id, **kwargs)  # noqa: E501
            return data

    def get_private_user_invitations_with_http_info(self, invitation_id, **kwargs):  # noqa: E501
        """Get a list of Private User Invitations   # noqa: E501

        Get a list of user who were invited to view the course.  Can be filtered using the request parameters to provide a subset of results.  >**Note:** >This request is paginated and will only provide a limited amount of resources at a time.  If there are more results to be collected, a `more` token provided with the response which can be passed to get the next page of results.  When passing this token, no other filter parameters can be sent as part of the request.  The resources will continue to respect the filters passed in by the original request.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_private_user_invitations_with_http_info(invitation_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str invitation_id: (required)
        :param datetime since: Filter by ISO 8601 TimeStamp inclusive (defaults to UTC)
        :param datetime until: Filter by ISO 8601 TimeStamp inclusive (defaults to UTC)
        :param str datetime_filter: Specifies field that `since` and `until` parameters are applied against
        :param str filter: Optional string which filters results by a specified field (described by filterBy).
        :param str filter_by: Optional enum parameter for specifying the field on which to run the filter. 
        :param str order_by: Optional enum parameter for specifying the field and order by which to sort the results. 
        :param str more: Pagination token returned as `more` property of multi page list requests
        :param bool include_registration_report: Optional flag to include basic registration information
        :return: UserInvitationList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['invitation_id', 'since', 'until', 'datetime_filter', 'filter', 'filter_by', 'order_by', 'more', 'include_registration_report']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_private_user_invitations" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'invitation_id' is set
        if ('invitation_id' not in params or
                params['invitation_id'] is None):
            raise ValueError("Missing the required parameter `invitation_id` when calling `get_private_user_invitations`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'invitation_id' in params:
            path_params['invitationId'] = params['invitation_id']  # noqa: E501

        query_params = []
        if 'since' in params:
            query_params.append(('since', params['since']))  # noqa: E501
        if 'until' in params:
            query_params.append(('until', params['until']))  # noqa: E501
        if 'datetime_filter' in params:
            query_params.append(('datetimeFilter', params['datetime_filter']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501
        if 'filter_by' in params:
            query_params.append(('filterBy', params['filter_by']))  # noqa: E501
        if 'order_by' in params:
            query_params.append(('orderBy', params['order_by']))  # noqa: E501
        if 'more' in params:
            query_params.append(('more', params['more']))  # noqa: E501
        if 'include_registration_report' in params:
            query_params.append(('includeRegistrationReport', params['include_registration_report']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APP_NORMAL', 'OAUTH']  # noqa: E501

        return self.api_client.call_api(
            '/invitations/private/{invitationId}/userInvitations', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='UserInvitationList',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_public_invitation(self, invitation_id, **kwargs):  # noqa: E501
        """Get detailed information about a Public Invitation   # noqa: E501

        Returns detailed information about the public invitation.  This includes url, registration cap, and whether new learners can accept the invitation or not.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_public_invitation(invitation_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str invitation_id: (required)
        :param bool include_registration_count: Include the registration count in the results
        :return: PublicInvitationSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_public_invitation_with_http_info(invitation_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_public_invitation_with_http_info(invitation_id, **kwargs)  # noqa: E501
            return data

    def get_public_invitation_with_http_info(self, invitation_id, **kwargs):  # noqa: E501
        """Get detailed information about a Public Invitation   # noqa: E501

        Returns detailed information about the public invitation.  This includes url, registration cap, and whether new learners can accept the invitation or not.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_public_invitation_with_http_info(invitation_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str invitation_id: (required)
        :param bool include_registration_count: Include the registration count in the results
        :return: PublicInvitationSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['invitation_id', 'include_registration_count']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_public_invitation" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'invitation_id' is set
        if ('invitation_id' not in params or
                params['invitation_id'] is None):
            raise ValueError("Missing the required parameter `invitation_id` when calling `get_public_invitation`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'invitation_id' in params:
            path_params['invitationId'] = params['invitation_id']  # noqa: E501

        query_params = []
        if 'include_registration_count' in params:
            query_params.append(('includeRegistrationCount', params['include_registration_count']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APP_NORMAL', 'OAUTH']  # noqa: E501

        return self.api_client.call_api(
            '/invitations/public/{invitationId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PublicInvitationSchema',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_public_invitations(self, **kwargs):  # noqa: E501
        """Get a list of Public Invitations   # noqa: E501

        Returns a list of public invitations.  Can be filtered using the request parameters to provide a subset of results.  >**Note:** >This request is paginated and will only provide a limited amount of resources at a time.  If there are more results to be collected, a `more` token provided with the response which can be passed to get the next page of results.  When passing this token, no other filter parameters can be sent as part of the request.  The resources will continue to respect the filters passed in by the original request.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_public_invitations(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: Only retrieve resources having `courseId`
        :param datetime since: Filter by ISO 8601 TimeStamp inclusive (defaults to UTC)
        :param datetime until: Filter by ISO 8601 TimeStamp inclusive (defaults to UTC)
        :param str datetime_filter: Specifies field that `since` and `until` parameters are applied against
        :param list[str] tags: Filter items matching any tag provided (not all)
        :param str filter: Optional string which filters results by a specified field (described by filterBy).
        :param str filter_by: Optional enum parameter for specifying the field on which to run the filter. 
        :param str order_by: Optional enum parameter for specifying the field and order by which to sort the results. 
        :param str more: Pagination token returned as `more` property of multi page list requests
        :return: PublicInvitationList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_public_invitations_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_public_invitations_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_public_invitations_with_http_info(self, **kwargs):  # noqa: E501
        """Get a list of Public Invitations   # noqa: E501

        Returns a list of public invitations.  Can be filtered using the request parameters to provide a subset of results.  >**Note:** >This request is paginated and will only provide a limited amount of resources at a time.  If there are more results to be collected, a `more` token provided with the response which can be passed to get the next page of results.  When passing this token, no other filter parameters can be sent as part of the request.  The resources will continue to respect the filters passed in by the original request.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_public_invitations_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: Only retrieve resources having `courseId`
        :param datetime since: Filter by ISO 8601 TimeStamp inclusive (defaults to UTC)
        :param datetime until: Filter by ISO 8601 TimeStamp inclusive (defaults to UTC)
        :param str datetime_filter: Specifies field that `since` and `until` parameters are applied against
        :param list[str] tags: Filter items matching any tag provided (not all)
        :param str filter: Optional string which filters results by a specified field (described by filterBy).
        :param str filter_by: Optional enum parameter for specifying the field on which to run the filter. 
        :param str order_by: Optional enum parameter for specifying the field and order by which to sort the results. 
        :param str more: Pagination token returned as `more` property of multi page list requests
        :return: PublicInvitationList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['course_id', 'since', 'until', 'datetime_filter', 'tags', 'filter', 'filter_by', 'order_by', 'more']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_public_invitations" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'course_id' in params:
            query_params.append(('courseId', params['course_id']))  # noqa: E501
        if 'since' in params:
            query_params.append(('since', params['since']))  # noqa: E501
        if 'until' in params:
            query_params.append(('until', params['until']))  # noqa: E501
        if 'datetime_filter' in params:
            query_params.append(('datetimeFilter', params['datetime_filter']))  # noqa: E501
        if 'tags' in params:
            query_params.append(('tags', params['tags']))  # noqa: E501
            collection_formats['tags'] = 'csv'  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501
        if 'filter_by' in params:
            query_params.append(('filterBy', params['filter_by']))  # noqa: E501
        if 'order_by' in params:
            query_params.append(('orderBy', params['order_by']))  # noqa: E501
        if 'more' in params:
            query_params.append(('more', params['more']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APP_NORMAL', 'OAUTH']  # noqa: E501

        return self.api_client.call_api(
            '/invitations/public', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PublicInvitationList',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_public_user_invitations(self, invitation_id, **kwargs):  # noqa: E501
        """Get a list of Public User Invitations   # noqa: E501

        Returns a list of users who have visited the public invitation link.  Can be filtered using the request parameters to provide a subset of results.  >**Note:** >This request is paginated and will only provide a limited amount of resources at a time.  If there are more results to be collected, a `more` token provided with the response which can be passed to get the next page of results.  When passing this token, no other filter parameters can be sent as part of the request.  The resources will continue to respect the filters passed in by the original request.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_public_user_invitations(invitation_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str invitation_id: (required)
        :param datetime since: Filter by ISO 8601 TimeStamp inclusive (defaults to UTC)
        :param datetime until: Filter by ISO 8601 TimeStamp inclusive (defaults to UTC)
        :param str datetime_filter: Specifies field that `since` and `until` parameters are applied against
        :param str filter: Optional string which filters results by a specified field (described by filterBy).
        :param str filter_by: Optional enum parameter for specifying the field on which to run the filter. 
        :param str order_by: Optional enum parameter for specifying the field and order by which to sort the results. 
        :param str more: Pagination token returned as `more` property of multi page list requests
        :param bool include_registration_report: Optional flag to include basic registration information
        :return: UserInvitationList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_public_user_invitations_with_http_info(invitation_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_public_user_invitations_with_http_info(invitation_id, **kwargs)  # noqa: E501
            return data

    def get_public_user_invitations_with_http_info(self, invitation_id, **kwargs):  # noqa: E501
        """Get a list of Public User Invitations   # noqa: E501

        Returns a list of users who have visited the public invitation link.  Can be filtered using the request parameters to provide a subset of results.  >**Note:** >This request is paginated and will only provide a limited amount of resources at a time.  If there are more results to be collected, a `more` token provided with the response which can be passed to get the next page of results.  When passing this token, no other filter parameters can be sent as part of the request.  The resources will continue to respect the filters passed in by the original request.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_public_user_invitations_with_http_info(invitation_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str invitation_id: (required)
        :param datetime since: Filter by ISO 8601 TimeStamp inclusive (defaults to UTC)
        :param datetime until: Filter by ISO 8601 TimeStamp inclusive (defaults to UTC)
        :param str datetime_filter: Specifies field that `since` and `until` parameters are applied against
        :param str filter: Optional string which filters results by a specified field (described by filterBy).
        :param str filter_by: Optional enum parameter for specifying the field on which to run the filter. 
        :param str order_by: Optional enum parameter for specifying the field and order by which to sort the results. 
        :param str more: Pagination token returned as `more` property of multi page list requests
        :param bool include_registration_report: Optional flag to include basic registration information
        :return: UserInvitationList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['invitation_id', 'since', 'until', 'datetime_filter', 'filter', 'filter_by', 'order_by', 'more', 'include_registration_report']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_public_user_invitations" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'invitation_id' is set
        if ('invitation_id' not in params or
                params['invitation_id'] is None):
            raise ValueError("Missing the required parameter `invitation_id` when calling `get_public_user_invitations`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'invitation_id' in params:
            path_params['invitationId'] = params['invitation_id']  # noqa: E501

        query_params = []
        if 'since' in params:
            query_params.append(('since', params['since']))  # noqa: E501
        if 'until' in params:
            query_params.append(('until', params['until']))  # noqa: E501
        if 'datetime_filter' in params:
            query_params.append(('datetimeFilter', params['datetime_filter']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501
        if 'filter_by' in params:
            query_params.append(('filterBy', params['filter_by']))  # noqa: E501
        if 'order_by' in params:
            query_params.append(('orderBy', params['order_by']))  # noqa: E501
        if 'more' in params:
            query_params.append(('more', params['more']))  # noqa: E501
        if 'include_registration_report' in params:
            query_params.append(('includeRegistrationReport', params['include_registration_report']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APP_NORMAL', 'OAUTH']  # noqa: E501

        return self.api_client.call_api(
            '/invitations/public/{invitationId}/userInvitations', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='UserInvitationList',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def put_invitation_tags(self, invitation_id, tags, **kwargs):  # noqa: E501
        """Add tags to an Invitation   # noqa: E501

        Applies the provided tags to the invitation.  Tags are used to easily identify resources.  Adding tags can enable more refined searches when making calls to certain endpoints (e.g. GetInvitations).   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_invitation_tags(invitation_id, tags, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str invitation_id: (required)
        :param TagListSchema tags: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.put_invitation_tags_with_http_info(invitation_id, tags, **kwargs)  # noqa: E501
        else:
            (data) = self.put_invitation_tags_with_http_info(invitation_id, tags, **kwargs)  # noqa: E501
            return data

    def put_invitation_tags_with_http_info(self, invitation_id, tags, **kwargs):  # noqa: E501
        """Add tags to an Invitation   # noqa: E501

        Applies the provided tags to the invitation.  Tags are used to easily identify resources.  Adding tags can enable more refined searches when making calls to certain endpoints (e.g. GetInvitations).   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_invitation_tags_with_http_info(invitation_id, tags, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str invitation_id: (required)
        :param TagListSchema tags: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['invitation_id', 'tags']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_invitation_tags" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'invitation_id' is set
        if ('invitation_id' not in params or
                params['invitation_id'] is None):
            raise ValueError("Missing the required parameter `invitation_id` when calling `put_invitation_tags`")  # noqa: E501
        # verify the required parameter 'tags' is set
        if ('tags' not in params or
                params['tags'] is None):
            raise ValueError("Missing the required parameter `tags` when calling `put_invitation_tags`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'invitation_id' in params:
            path_params['invitationId'] = params['invitation_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'tags' in params:
            body_params = params['tags']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APP_NORMAL', 'OAUTH']  # noqa: E501

        return self.api_client.call_api(
            '/invitations/{invitationId}/tags', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def put_invitation_tags_batch(self, batch, **kwargs):  # noqa: E501
        """Add a group of tags to a group of Invitations   # noqa: E501

        Applies all of the provided tags on all of the provided invitations.  Both public and private invitations may be tagged via this operation.  Tags are used to easily identify resources.  Adding tags can enable more refined searches when making calls to certain endpoints (e.g. GetInvitations).   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_invitation_tags_batch(batch, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param BatchTagsSchema batch: Array of ids, and array of tags for bulk tag operations (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.put_invitation_tags_batch_with_http_info(batch, **kwargs)  # noqa: E501
        else:
            (data) = self.put_invitation_tags_batch_with_http_info(batch, **kwargs)  # noqa: E501
            return data

    def put_invitation_tags_batch_with_http_info(self, batch, **kwargs):  # noqa: E501
        """Add a group of tags to a group of Invitations   # noqa: E501

        Applies all of the provided tags on all of the provided invitations.  Both public and private invitations may be tagged via this operation.  Tags are used to easily identify resources.  Adding tags can enable more refined searches when making calls to certain endpoints (e.g. GetInvitations).   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_invitation_tags_batch_with_http_info(batch, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param BatchTagsSchema batch: Array of ids, and array of tags for bulk tag operations (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['batch']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_invitation_tags_batch" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'batch' is set
        if ('batch' not in params or
                params['batch'] is None):
            raise ValueError("Missing the required parameter `batch` when calling `put_invitation_tags_batch`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'batch' in params:
            body_params = params['batch']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APP_NORMAL', 'OAUTH']  # noqa: E501

        return self.api_client.call_api(
            '/invitations/tags', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_private_invitation(self, invitation_id, invitation_update_schema, **kwargs):  # noqa: E501
        """Update information about a Private Invitation   # noqa: E501

        Updates information about the private invitation, such as the expiration date and registration cap.  Only non-null values that are provided will be updated.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_private_invitation(invitation_id, invitation_update_schema, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str invitation_id: (required)
        :param PrivateInvitationUpdateSchema invitation_update_schema: Object with values to be updated.  Any value not specified above will be ignored.  (required)
        :return: PrivateInvitationSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_private_invitation_with_http_info(invitation_id, invitation_update_schema, **kwargs)  # noqa: E501
        else:
            (data) = self.update_private_invitation_with_http_info(invitation_id, invitation_update_schema, **kwargs)  # noqa: E501
            return data

    def update_private_invitation_with_http_info(self, invitation_id, invitation_update_schema, **kwargs):  # noqa: E501
        """Update information about a Private Invitation   # noqa: E501

        Updates information about the private invitation, such as the expiration date and registration cap.  Only non-null values that are provided will be updated.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_private_invitation_with_http_info(invitation_id, invitation_update_schema, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str invitation_id: (required)
        :param PrivateInvitationUpdateSchema invitation_update_schema: Object with values to be updated.  Any value not specified above will be ignored.  (required)
        :return: PrivateInvitationSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['invitation_id', 'invitation_update_schema']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_private_invitation" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'invitation_id' is set
        if ('invitation_id' not in params or
                params['invitation_id'] is None):
            raise ValueError("Missing the required parameter `invitation_id` when calling `update_private_invitation`")  # noqa: E501
        # verify the required parameter 'invitation_update_schema' is set
        if ('invitation_update_schema' not in params or
                params['invitation_update_schema'] is None):
            raise ValueError("Missing the required parameter `invitation_update_schema` when calling `update_private_invitation`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'invitation_id' in params:
            path_params['invitationId'] = params['invitation_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'invitation_update_schema' in params:
            body_params = params['invitation_update_schema']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APP_NORMAL', 'OAUTH']  # noqa: E501

        return self.api_client.call_api(
            '/invitations/private/{invitationId}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PrivateInvitationSchema',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_public_invitation(self, invitation_id, invitation_update_schema, **kwargs):  # noqa: E501
        """Update information about a Public Invitation   # noqa: E501

        Updates information about the public invitation, such as the expiration date and registration cap.  Only non-null values that are provided will be updated.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_public_invitation(invitation_id, invitation_update_schema, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str invitation_id: (required)
        :param PublicInvitationUpdateSchema invitation_update_schema: Object with values to be updated.  Any value not specified above will be ignored.  (required)
        :return: PublicInvitationSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_public_invitation_with_http_info(invitation_id, invitation_update_schema, **kwargs)  # noqa: E501
        else:
            (data) = self.update_public_invitation_with_http_info(invitation_id, invitation_update_schema, **kwargs)  # noqa: E501
            return data

    def update_public_invitation_with_http_info(self, invitation_id, invitation_update_schema, **kwargs):  # noqa: E501
        """Update information about a Public Invitation   # noqa: E501

        Updates information about the public invitation, such as the expiration date and registration cap.  Only non-null values that are provided will be updated.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_public_invitation_with_http_info(invitation_id, invitation_update_schema, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str invitation_id: (required)
        :param PublicInvitationUpdateSchema invitation_update_schema: Object with values to be updated.  Any value not specified above will be ignored.  (required)
        :return: PublicInvitationSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['invitation_id', 'invitation_update_schema']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_public_invitation" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'invitation_id' is set
        if ('invitation_id' not in params or
                params['invitation_id'] is None):
            raise ValueError("Missing the required parameter `invitation_id` when calling `update_public_invitation`")  # noqa: E501
        # verify the required parameter 'invitation_update_schema' is set
        if ('invitation_update_schema' not in params or
                params['invitation_update_schema'] is None):
            raise ValueError("Missing the required parameter `invitation_update_schema` when calling `update_public_invitation`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'invitation_id' in params:
            path_params['invitationId'] = params['invitation_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'invitation_update_schema' in params:
            body_params = params['invitation_update_schema']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APP_NORMAL', 'OAUTH']  # noqa: E501

        return self.api_client.call_api(
            '/invitations/public/{invitationId}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PublicInvitationSchema',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
