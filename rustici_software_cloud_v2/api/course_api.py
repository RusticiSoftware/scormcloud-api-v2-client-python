# coding: utf-8

"""
    SCORM Cloud Rest API

    REST API used for SCORM Cloud integrations.  # noqa: E501

    OpenAPI spec version: 2.0
    Contact: systems@rusticisoftware.com
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from rustici_software_cloud_v2.api_client import ApiClient


class CourseApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def build_course_preview_launch_link(self, course_id, launch_link_request, **kwargs):  # noqa: E501
        """Get a link to preview a course.   # noqa: E501

        Returns the launch link to use to preview this course.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.build_course_preview_launch_link(course_id, launch_link_request, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: (required)
        :param LaunchLinkRequestSchema launch_link_request: (required)
        :param str css_url:
        :return: LaunchLinkSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.build_course_preview_launch_link_with_http_info(course_id, launch_link_request, **kwargs)  # noqa: E501
        else:
            (data) = self.build_course_preview_launch_link_with_http_info(course_id, launch_link_request, **kwargs)  # noqa: E501
            return data

    def build_course_preview_launch_link_with_http_info(self, course_id, launch_link_request, **kwargs):  # noqa: E501
        """Get a link to preview a course.   # noqa: E501

        Returns the launch link to use to preview this course.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.build_course_preview_launch_link_with_http_info(course_id, launch_link_request, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: (required)
        :param LaunchLinkRequestSchema launch_link_request: (required)
        :param str css_url:
        :return: LaunchLinkSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['course_id', 'launch_link_request', 'css_url']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method build_course_preview_launch_link" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'course_id' is set
        if ('course_id' not in params or
                params['course_id'] is None):
            raise ValueError("Missing the required parameter `course_id` when calling `build_course_preview_launch_link`")  # noqa: E501
        # verify the required parameter 'launch_link_request' is set
        if ('launch_link_request' not in params or
                params['launch_link_request'] is None):
            raise ValueError("Missing the required parameter `launch_link_request` when calling `build_course_preview_launch_link`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'course_id' in params:
            path_params['courseId'] = params['course_id']  # noqa: E501

        query_params = []
        if 'css_url' in params:
            query_params.append(('cssUrl', params['css_url']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'launch_link_request' in params:
            body_params = params['launch_link_request']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APP_NORMAL', 'OAUTH']  # noqa: E501

        return self.api_client.call_api(
            '/courses/{courseId}/preview', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LaunchLinkSchema',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def build_course_preview_launch_link_with_version(self, course_id, version_id, launch_link_request, **kwargs):  # noqa: E501
        """Get a link to preview a particular course version.   # noqa: E501

        Returns the link to use to preview a particular version of a course.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.build_course_preview_launch_link_with_version(course_id, version_id, launch_link_request, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: (required)
        :param int version_id: The course version (required)
        :param LaunchLinkRequestSchema launch_link_request: (required)
        :return: LaunchLinkSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.build_course_preview_launch_link_with_version_with_http_info(course_id, version_id, launch_link_request, **kwargs)  # noqa: E501
        else:
            (data) = self.build_course_preview_launch_link_with_version_with_http_info(course_id, version_id, launch_link_request, **kwargs)  # noqa: E501
            return data

    def build_course_preview_launch_link_with_version_with_http_info(self, course_id, version_id, launch_link_request, **kwargs):  # noqa: E501
        """Get a link to preview a particular course version.   # noqa: E501

        Returns the link to use to preview a particular version of a course.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.build_course_preview_launch_link_with_version_with_http_info(course_id, version_id, launch_link_request, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: (required)
        :param int version_id: The course version (required)
        :param LaunchLinkRequestSchema launch_link_request: (required)
        :return: LaunchLinkSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['course_id', 'version_id', 'launch_link_request']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method build_course_preview_launch_link_with_version" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'course_id' is set
        if ('course_id' not in params or
                params['course_id'] is None):
            raise ValueError("Missing the required parameter `course_id` when calling `build_course_preview_launch_link_with_version`")  # noqa: E501
        # verify the required parameter 'version_id' is set
        if ('version_id' not in params or
                params['version_id'] is None):
            raise ValueError("Missing the required parameter `version_id` when calling `build_course_preview_launch_link_with_version`")  # noqa: E501
        # verify the required parameter 'launch_link_request' is set
        if ('launch_link_request' not in params or
                params['launch_link_request'] is None):
            raise ValueError("Missing the required parameter `launch_link_request` when calling `build_course_preview_launch_link_with_version`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'course_id' in params:
            path_params['courseId'] = params['course_id']  # noqa: E501
        if 'version_id' in params:
            path_params['versionId'] = params['version_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'launch_link_request' in params:
            body_params = params['launch_link_request']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APP_NORMAL', 'OAUTH']  # noqa: E501

        return self.api_client.call_api(
            '/courses/{courseId}/versions/{versionId}/preview', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LaunchLinkSchema',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_fetch_and_import_course_job(self, course_id, import_request, **kwargs):  # noqa: E501
        """Fetch and import a course.   # noqa: E501

        An import job will be started to fetch and import the referenced file, and the import job ID will be returned. If the import is successful, the imported course will be registered using the courseId provided.  To check the progress of the import job, GetImportJobStatus should be called with the job ID returned from this call.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_fetch_and_import_course_job(course_id, import_request, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: A unique identifier your application will use to identify the course after import. Your application is responsible both for generating this unique ID and for keeping track of the ID for later use. (required)
        :param ImportFetchRequestSchema import_request: (required)
        :param bool may_create_new_version: Is it OK to create a new version of this course? If this is set to false and the course already exists, the upload will fail. If true and the course already exists then a new version will be created. No effect if the course doesn't already exist.
        :param str postback_url: An optional parameter that specifies a URL to send a postback to when the course has finished uploading.
        :return: StringResultSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_fetch_and_import_course_job_with_http_info(course_id, import_request, **kwargs)  # noqa: E501
        else:
            (data) = self.create_fetch_and_import_course_job_with_http_info(course_id, import_request, **kwargs)  # noqa: E501
            return data

    def create_fetch_and_import_course_job_with_http_info(self, course_id, import_request, **kwargs):  # noqa: E501
        """Fetch and import a course.   # noqa: E501

        An import job will be started to fetch and import the referenced file, and the import job ID will be returned. If the import is successful, the imported course will be registered using the courseId provided.  To check the progress of the import job, GetImportJobStatus should be called with the job ID returned from this call.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_fetch_and_import_course_job_with_http_info(course_id, import_request, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: A unique identifier your application will use to identify the course after import. Your application is responsible both for generating this unique ID and for keeping track of the ID for later use. (required)
        :param ImportFetchRequestSchema import_request: (required)
        :param bool may_create_new_version: Is it OK to create a new version of this course? If this is set to false and the course already exists, the upload will fail. If true and the course already exists then a new version will be created. No effect if the course doesn't already exist.
        :param str postback_url: An optional parameter that specifies a URL to send a postback to when the course has finished uploading.
        :return: StringResultSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['course_id', 'import_request', 'may_create_new_version', 'postback_url']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_fetch_and_import_course_job" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'course_id' is set
        if ('course_id' not in params or
                params['course_id'] is None):
            raise ValueError("Missing the required parameter `course_id` when calling `create_fetch_and_import_course_job`")  # noqa: E501
        # verify the required parameter 'import_request' is set
        if ('import_request' not in params or
                params['import_request'] is None):
            raise ValueError("Missing the required parameter `import_request` when calling `create_fetch_and_import_course_job`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'course_id' in params:
            query_params.append(('courseId', params['course_id']))  # noqa: E501
        if 'may_create_new_version' in params:
            query_params.append(('mayCreateNewVersion', params['may_create_new_version']))  # noqa: E501
        if 'postback_url' in params:
            query_params.append(('postbackUrl', params['postback_url']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'import_request' in params:
            body_params = params['import_request']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APP_NORMAL', 'OAUTH']  # noqa: E501

        return self.api_client.call_api(
            '/courses/importJobs', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='StringResultSchema',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_no_upload_and_import_course_job(self, course_id, import_request, **kwargs):  # noqa: E501
        """Import a course that fetches or references an external media file   # noqa: E501

        An import job will be started to import the course by fetching the course or with a reference to an external file, and the import job ID will be returned. If the import is successful, the imported course will be registered using the courseId provided. To check the progress of the import job, GetImportJobStatus should be called with the job ID returned from this call.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_no_upload_and_import_course_job(course_id, import_request, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: A unique identifier your application will use to identify the course after import. Your application is responsible both for generating this unique ID and for keeping track of the ID for later use. (required)
        :param ImportRequestSchema import_request: (required)
        :param bool may_create_new_version: Is it OK to create a new version of this course? If this is set to false and the course already exists, the upload will fail. If true and the course already exists then a new version will be created. No effect if the course doesn't already exist.
        :param str postback_url: An optional parameter that specifies a URL to send a postback to when the course has finished uploading.
        :return: StringResultSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_no_upload_and_import_course_job_with_http_info(course_id, import_request, **kwargs)  # noqa: E501
        else:
            (data) = self.create_no_upload_and_import_course_job_with_http_info(course_id, import_request, **kwargs)  # noqa: E501
            return data

    def create_no_upload_and_import_course_job_with_http_info(self, course_id, import_request, **kwargs):  # noqa: E501
        """Import a course that fetches or references an external media file   # noqa: E501

        An import job will be started to import the course by fetching the course or with a reference to an external file, and the import job ID will be returned. If the import is successful, the imported course will be registered using the courseId provided. To check the progress of the import job, GetImportJobStatus should be called with the job ID returned from this call.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_no_upload_and_import_course_job_with_http_info(course_id, import_request, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: A unique identifier your application will use to identify the course after import. Your application is responsible both for generating this unique ID and for keeping track of the ID for later use. (required)
        :param ImportRequestSchema import_request: (required)
        :param bool may_create_new_version: Is it OK to create a new version of this course? If this is set to false and the course already exists, the upload will fail. If true and the course already exists then a new version will be created. No effect if the course doesn't already exist.
        :param str postback_url: An optional parameter that specifies a URL to send a postback to when the course has finished uploading.
        :return: StringResultSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['course_id', 'import_request', 'may_create_new_version', 'postback_url']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_no_upload_and_import_course_job" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'course_id' is set
        if ('course_id' not in params or
                params['course_id'] is None):
            raise ValueError("Missing the required parameter `course_id` when calling `create_no_upload_and_import_course_job`")  # noqa: E501
        # verify the required parameter 'import_request' is set
        if ('import_request' not in params or
                params['import_request'] is None):
            raise ValueError("Missing the required parameter `import_request` when calling `create_no_upload_and_import_course_job`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'course_id' in params:
            query_params.append(('courseId', params['course_id']))  # noqa: E501
        if 'may_create_new_version' in params:
            query_params.append(('mayCreateNewVersion', params['may_create_new_version']))  # noqa: E501
        if 'postback_url' in params:
            query_params.append(('postbackUrl', params['postback_url']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'import_request' in params:
            body_params = params['import_request']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APP_NORMAL', 'OAUTH']  # noqa: E501

        return self.api_client.call_api(
            '/courses/importJobs/noUpload', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='StringResultSchema',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_upload_and_import_course_job(self, course_id, **kwargs):  # noqa: E501
        """Upload and import a course.  # noqa: E501

        An import job will be started to import the posted file, and the import job ID will be returned. If the import is successful, the imported course will be registered using the courseId provided.  To check the progress of the import job, GetImportJobStatus should be called with the job ID returned from this call.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_upload_and_import_course_job(course_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: A unique identifier your application will use to identify the course after import. Your application is responsible both for generating this unique ID and for keeping track of the ID for later use. (required)
        :param bool may_create_new_version: Is it OK to create a new version of this course? If this is set to false and the course already exists, the upload will fail. If true and the course already exists then a new version will be created. No effect if the course doesn't already exist.
        :param str postback_url: An optional parameter that specifies a URL to send a postback to when the course has finished uploading.
        :param str uploaded_content_type: The MIME type identifier for the content to be uploaded. This is required if uploading a media file (.pdf, .mp3, or .mp4).
        :param str content_metadata: Serialized 'mediaFileMetadata' schema.
        :param file file: The zip file of the course contents to import.
        :return: StringResultSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_upload_and_import_course_job_with_http_info(course_id, **kwargs)  # noqa: E501
        else:
            (data) = self.create_upload_and_import_course_job_with_http_info(course_id, **kwargs)  # noqa: E501
            return data

    def create_upload_and_import_course_job_with_http_info(self, course_id, **kwargs):  # noqa: E501
        """Upload and import a course.  # noqa: E501

        An import job will be started to import the posted file, and the import job ID will be returned. If the import is successful, the imported course will be registered using the courseId provided.  To check the progress of the import job, GetImportJobStatus should be called with the job ID returned from this call.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_upload_and_import_course_job_with_http_info(course_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: A unique identifier your application will use to identify the course after import. Your application is responsible both for generating this unique ID and for keeping track of the ID for later use. (required)
        :param bool may_create_new_version: Is it OK to create a new version of this course? If this is set to false and the course already exists, the upload will fail. If true and the course already exists then a new version will be created. No effect if the course doesn't already exist.
        :param str postback_url: An optional parameter that specifies a URL to send a postback to when the course has finished uploading.
        :param str uploaded_content_type: The MIME type identifier for the content to be uploaded. This is required if uploading a media file (.pdf, .mp3, or .mp4).
        :param str content_metadata: Serialized 'mediaFileMetadata' schema.
        :param file file: The zip file of the course contents to import.
        :return: StringResultSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['course_id', 'may_create_new_version', 'postback_url', 'uploaded_content_type', 'content_metadata', 'file']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_upload_and_import_course_job" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'course_id' is set
        if ('course_id' not in params or
                params['course_id'] is None):
            raise ValueError("Missing the required parameter `course_id` when calling `create_upload_and_import_course_job`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'course_id' in params:
            query_params.append(('courseId', params['course_id']))  # noqa: E501
        if 'may_create_new_version' in params:
            query_params.append(('mayCreateNewVersion', params['may_create_new_version']))  # noqa: E501
        if 'postback_url' in params:
            query_params.append(('postbackUrl', params['postback_url']))  # noqa: E501

        header_params = {}
        if 'uploaded_content_type' in params:
            header_params['uploadedContentType'] = params['uploaded_content_type']  # noqa: E501

        form_params = []
        local_var_files = {}
        if 'content_metadata' in params:
            form_params.append(('contentMetadata', params['content_metadata']))  # noqa: E501
        if 'file' in params:
            local_var_files['file'] = params['file']  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APP_NORMAL', 'OAUTH']  # noqa: E501

        return self.api_client.call_api(
            '/courses/importJobs/upload', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='StringResultSchema',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_course(self, course_id, **kwargs):  # noqa: E501
        """Delete a course.   # noqa: E501

        Delete course identified by `courseId`.  When a course is deleted, so is everything connected to this course.  This includes:  - Registrations - Invitations - Dispatches - Debug Logs   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_course(course_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_course_with_http_info(course_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_course_with_http_info(course_id, **kwargs)  # noqa: E501
            return data

    def delete_course_with_http_info(self, course_id, **kwargs):  # noqa: E501
        """Delete a course.   # noqa: E501

        Delete course identified by `courseId`.  When a course is deleted, so is everything connected to this course.  This includes:  - Registrations - Invitations - Dispatches - Debug Logs   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_course_with_http_info(course_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['course_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_course" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'course_id' is set
        if ('course_id' not in params or
                params['course_id'] is None):
            raise ValueError("Missing the required parameter `course_id` when calling `delete_course`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'course_id' in params:
            path_params['courseId'] = params['course_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APP_NORMAL', 'OAUTH']  # noqa: E501

        return self.api_client.call_api(
            '/courses/{courseId}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_course_configuration_setting(self, course_id, setting_id, **kwargs):  # noqa: E501
        """Clear a course configuration.   # noqa: E501

        Clears the value of the given `settingId` for this course.  The effective setting value will become any value set at the application level (if this value is set at the application level) or the default setting.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_course_configuration_setting(course_id, setting_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: (required)
        :param str setting_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_course_configuration_setting_with_http_info(course_id, setting_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_course_configuration_setting_with_http_info(course_id, setting_id, **kwargs)  # noqa: E501
            return data

    def delete_course_configuration_setting_with_http_info(self, course_id, setting_id, **kwargs):  # noqa: E501
        """Clear a course configuration.   # noqa: E501

        Clears the value of the given `settingId` for this course.  The effective setting value will become any value set at the application level (if this value is set at the application level) or the default setting.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_course_configuration_setting_with_http_info(course_id, setting_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: (required)
        :param str setting_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['course_id', 'setting_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_course_configuration_setting" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'course_id' is set
        if ('course_id' not in params or
                params['course_id'] is None):
            raise ValueError("Missing the required parameter `course_id` when calling `delete_course_configuration_setting`")  # noqa: E501
        # verify the required parameter 'setting_id' is set
        if ('setting_id' not in params or
                params['setting_id'] is None):
            raise ValueError("Missing the required parameter `setting_id` when calling `delete_course_configuration_setting`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'course_id' in params:
            path_params['courseId'] = params['course_id']  # noqa: E501
        if 'setting_id' in params:
            path_params['settingId'] = params['setting_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APP_NORMAL', 'OAUTH']  # noqa: E501

        return self.api_client.call_api(
            '/courses/{courseId}/configuration/{settingId}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_course_tags(self, course_id, tags, **kwargs):  # noqa: E501
        """Delete course tags.   # noqa: E501

        Delete the provided tags from this course.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_course_tags(course_id, tags, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: (required)
        :param TagListSchema tags: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_course_tags_with_http_info(course_id, tags, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_course_tags_with_http_info(course_id, tags, **kwargs)  # noqa: E501
            return data

    def delete_course_tags_with_http_info(self, course_id, tags, **kwargs):  # noqa: E501
        """Delete course tags.   # noqa: E501

        Delete the provided tags from this course.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_course_tags_with_http_info(course_id, tags, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: (required)
        :param TagListSchema tags: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['course_id', 'tags']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_course_tags" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'course_id' is set
        if ('course_id' not in params or
                params['course_id'] is None):
            raise ValueError("Missing the required parameter `course_id` when calling `delete_course_tags`")  # noqa: E501
        # verify the required parameter 'tags' is set
        if ('tags' not in params or
                params['tags'] is None):
            raise ValueError("Missing the required parameter `tags` when calling `delete_course_tags`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'course_id' in params:
            path_params['courseId'] = params['course_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'tags' in params:
            body_params = params['tags']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APP_NORMAL', 'OAUTH']  # noqa: E501

        return self.api_client.call_api(
            '/courses/{courseId}/tags', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_course_version(self, course_id, version_id, **kwargs):  # noqa: E501
        """Delete a course version.   # noqa: E501

        Delete `versionId` of `courseId`.  If this is the last remaining version of this course, the course itself will be deleted and no longer accessible.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_course_version(course_id, version_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: (required)
        :param int version_id: The course version (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_course_version_with_http_info(course_id, version_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_course_version_with_http_info(course_id, version_id, **kwargs)  # noqa: E501
            return data

    def delete_course_version_with_http_info(self, course_id, version_id, **kwargs):  # noqa: E501
        """Delete a course version.   # noqa: E501

        Delete `versionId` of `courseId`.  If this is the last remaining version of this course, the course itself will be deleted and no longer accessible.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_course_version_with_http_info(course_id, version_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: (required)
        :param int version_id: The course version (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['course_id', 'version_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_course_version" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'course_id' is set
        if ('course_id' not in params or
                params['course_id'] is None):
            raise ValueError("Missing the required parameter `course_id` when calling `delete_course_version`")  # noqa: E501
        # verify the required parameter 'version_id' is set
        if ('version_id' not in params or
                params['version_id'] is None):
            raise ValueError("Missing the required parameter `version_id` when calling `delete_course_version`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'course_id' in params:
            path_params['courseId'] = params['course_id']  # noqa: E501
        if 'version_id' in params:
            path_params['versionId'] = params['version_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APP_NORMAL', 'OAUTH']  # noqa: E501

        return self.api_client.call_api(
            '/courses/{courseId}/versions/{versionId}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_course_version_configuration_setting(self, course_id, version_id, setting_id, **kwargs):  # noqa: E501
        """Clear a configuration setting for a version of a course.   # noqa: E501

        Clears the `settingId` value for this course and version.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_course_version_configuration_setting(course_id, version_id, setting_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: (required)
        :param int version_id: The course version (required)
        :param str setting_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_course_version_configuration_setting_with_http_info(course_id, version_id, setting_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_course_version_configuration_setting_with_http_info(course_id, version_id, setting_id, **kwargs)  # noqa: E501
            return data

    def delete_course_version_configuration_setting_with_http_info(self, course_id, version_id, setting_id, **kwargs):  # noqa: E501
        """Clear a configuration setting for a version of a course.   # noqa: E501

        Clears the `settingId` value for this course and version.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_course_version_configuration_setting_with_http_info(course_id, version_id, setting_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: (required)
        :param int version_id: The course version (required)
        :param str setting_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['course_id', 'version_id', 'setting_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_course_version_configuration_setting" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'course_id' is set
        if ('course_id' not in params or
                params['course_id'] is None):
            raise ValueError("Missing the required parameter `course_id` when calling `delete_course_version_configuration_setting`")  # noqa: E501
        # verify the required parameter 'version_id' is set
        if ('version_id' not in params or
                params['version_id'] is None):
            raise ValueError("Missing the required parameter `version_id` when calling `delete_course_version_configuration_setting`")  # noqa: E501
        # verify the required parameter 'setting_id' is set
        if ('setting_id' not in params or
                params['setting_id'] is None):
            raise ValueError("Missing the required parameter `setting_id` when calling `delete_course_version_configuration_setting`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'course_id' in params:
            path_params['courseId'] = params['course_id']  # noqa: E501
        if 'version_id' in params:
            path_params['versionId'] = params['version_id']  # noqa: E501
        if 'setting_id' in params:
            path_params['settingId'] = params['setting_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APP_NORMAL', 'OAUTH']  # noqa: E501

        return self.api_client.call_api(
            '/courses/{courseId}/versions/{versionId}/configuration/{settingId}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_course(self, course_id, **kwargs):  # noqa: E501
        """Get course details.   # noqa: E501

        Get detailed information about `courseId`.  Futher detail can be obtained with the optional query parameters flags.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_course(course_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: (required)
        :param bool include_registration_count: Include the registration count in the results
        :param bool include_course_metadata: Include course metadata in the results. If the course has no metadata, adding this parameter has no effect.
        :return: CourseSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_course_with_http_info(course_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_course_with_http_info(course_id, **kwargs)  # noqa: E501
            return data

    def get_course_with_http_info(self, course_id, **kwargs):  # noqa: E501
        """Get course details.   # noqa: E501

        Get detailed information about `courseId`.  Futher detail can be obtained with the optional query parameters flags.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_course_with_http_info(course_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: (required)
        :param bool include_registration_count: Include the registration count in the results
        :param bool include_course_metadata: Include course metadata in the results. If the course has no metadata, adding this parameter has no effect.
        :return: CourseSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['course_id', 'include_registration_count', 'include_course_metadata']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_course" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'course_id' is set
        if ('course_id' not in params or
                params['course_id'] is None):
            raise ValueError("Missing the required parameter `course_id` when calling `get_course`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'course_id' in params:
            path_params['courseId'] = params['course_id']  # noqa: E501

        query_params = []
        if 'include_registration_count' in params:
            query_params.append(('includeRegistrationCount', params['include_registration_count']))  # noqa: E501
        if 'include_course_metadata' in params:
            query_params.append(('includeCourseMetadata', params['include_course_metadata']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APP_NORMAL', 'OAUTH']  # noqa: E501

        return self.api_client.call_api(
            '/courses/{courseId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CourseSchema',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_course_configuration(self, course_id, **kwargs):  # noqa: E501
        """Get course configuration.   # noqa: E501

        Returns all effective configuration settings for this course.  For any setting which is not explicitly set at the course level, the effective value will be either the value set at the application level (if there is one) or the default value for the setting.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_course_configuration(course_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: (required)
        :param bool include_metadata:
        :return: SettingListSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_course_configuration_with_http_info(course_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_course_configuration_with_http_info(course_id, **kwargs)  # noqa: E501
            return data

    def get_course_configuration_with_http_info(self, course_id, **kwargs):  # noqa: E501
        """Get course configuration.   # noqa: E501

        Returns all effective configuration settings for this course.  For any setting which is not explicitly set at the course level, the effective value will be either the value set at the application level (if there is one) or the default value for the setting.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_course_configuration_with_http_info(course_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: (required)
        :param bool include_metadata:
        :return: SettingListSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['course_id', 'include_metadata']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_course_configuration" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'course_id' is set
        if ('course_id' not in params or
                params['course_id'] is None):
            raise ValueError("Missing the required parameter `course_id` when calling `get_course_configuration`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'course_id' in params:
            path_params['courseId'] = params['course_id']  # noqa: E501

        query_params = []
        if 'include_metadata' in params:
            query_params.append(('includeMetadata', params['include_metadata']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APP_NORMAL', 'OAUTH']  # noqa: E501

        return self.api_client.call_api(
            '/courses/{courseId}/configuration', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SettingListSchema',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_course_statements(self, course_id, **kwargs):  # noqa: E501
        """Get course xAPI statements.   # noqa: E501

        Get xAPI statements for `courseId`.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_course_statements(course_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: (required)
        :param str learner_id: Only entries for the specified learner id will be included.
        :param datetime since: Only items updated since the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used.
        :param datetime until: Only items updated before the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used.
        :param str more: Value for this parameter will be provided in the 'more' property of registration lists, where needed. An opaque value, construction and parsing may change without notice.
        :return: XapiStatementResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_course_statements_with_http_info(course_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_course_statements_with_http_info(course_id, **kwargs)  # noqa: E501
            return data

    def get_course_statements_with_http_info(self, course_id, **kwargs):  # noqa: E501
        """Get course xAPI statements.   # noqa: E501

        Get xAPI statements for `courseId`.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_course_statements_with_http_info(course_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: (required)
        :param str learner_id: Only entries for the specified learner id will be included.
        :param datetime since: Only items updated since the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used.
        :param datetime until: Only items updated before the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used.
        :param str more: Value for this parameter will be provided in the 'more' property of registration lists, where needed. An opaque value, construction and parsing may change without notice.
        :return: XapiStatementResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['course_id', 'learner_id', 'since', 'until', 'more']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_course_statements" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'course_id' is set
        if ('course_id' not in params or
                params['course_id'] is None):
            raise ValueError("Missing the required parameter `course_id` when calling `get_course_statements`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'course_id' in params:
            path_params['courseId'] = params['course_id']  # noqa: E501

        query_params = []
        if 'learner_id' in params:
            query_params.append(('learnerId', params['learner_id']))  # noqa: E501
        if 'since' in params:
            query_params.append(('since', params['since']))  # noqa: E501
        if 'until' in params:
            query_params.append(('until', params['until']))  # noqa: E501
        if 'more' in params:
            query_params.append(('more', params['more']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APP_NORMAL', 'OAUTH']  # noqa: E501

        return self.api_client.call_api(
            '/courses/{courseId}/xAPIStatements', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='XapiStatementResult',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_course_tags(self, course_id, **kwargs):  # noqa: E501
        """Get course tags.   # noqa: E501

        Get a list of the tags for this course.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_course_tags(course_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: (required)
        :return: TagListSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_course_tags_with_http_info(course_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_course_tags_with_http_info(course_id, **kwargs)  # noqa: E501
            return data

    def get_course_tags_with_http_info(self, course_id, **kwargs):  # noqa: E501
        """Get course tags.   # noqa: E501

        Get a list of the tags for this course.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_course_tags_with_http_info(course_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: (required)
        :return: TagListSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['course_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_course_tags" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'course_id' is set
        if ('course_id' not in params or
                params['course_id'] is None):
            raise ValueError("Missing the required parameter `course_id` when calling `get_course_tags`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'course_id' in params:
            path_params['courseId'] = params['course_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APP_NORMAL', 'OAUTH']  # noqa: E501

        return self.api_client.call_api(
            '/courses/{courseId}/tags', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TagListSchema',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_course_version_configuration(self, course_id, version_id, **kwargs):  # noqa: E501
        """Get configuration for a version of a course.   # noqa: E501

        Returns all configuration settings for this course and version.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_course_version_configuration(course_id, version_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: (required)
        :param int version_id: The course version (required)
        :param bool include_metadata:
        :return: SettingListSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_course_version_configuration_with_http_info(course_id, version_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_course_version_configuration_with_http_info(course_id, version_id, **kwargs)  # noqa: E501
            return data

    def get_course_version_configuration_with_http_info(self, course_id, version_id, **kwargs):  # noqa: E501
        """Get configuration for a version of a course.   # noqa: E501

        Returns all configuration settings for this course and version.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_course_version_configuration_with_http_info(course_id, version_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: (required)
        :param int version_id: The course version (required)
        :param bool include_metadata:
        :return: SettingListSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['course_id', 'version_id', 'include_metadata']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_course_version_configuration" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'course_id' is set
        if ('course_id' not in params or
                params['course_id'] is None):
            raise ValueError("Missing the required parameter `course_id` when calling `get_course_version_configuration`")  # noqa: E501
        # verify the required parameter 'version_id' is set
        if ('version_id' not in params or
                params['version_id'] is None):
            raise ValueError("Missing the required parameter `version_id` when calling `get_course_version_configuration`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'course_id' in params:
            path_params['courseId'] = params['course_id']  # noqa: E501
        if 'version_id' in params:
            path_params['versionId'] = params['version_id']  # noqa: E501

        query_params = []
        if 'include_metadata' in params:
            query_params.append(('includeMetadata', params['include_metadata']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APP_NORMAL', 'OAUTH']  # noqa: E501

        return self.api_client.call_api(
            '/courses/{courseId}/versions/{versionId}/configuration', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SettingListSchema',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_course_version_info(self, course_id, version_id, **kwargs):  # noqa: E501
        """Get details on a course version.   # noqa: E501

        Get specific version `versionId` of `courseId`   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_course_version_info(course_id, version_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: (required)
        :param int version_id: The course version (required)
        :param bool include_registration_count: Include the registration count in the results
        :param bool include_course_metadata: Include course metadata in the results. If the course has no metadata, adding this parameter has no effect.
        :return: CourseSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_course_version_info_with_http_info(course_id, version_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_course_version_info_with_http_info(course_id, version_id, **kwargs)  # noqa: E501
            return data

    def get_course_version_info_with_http_info(self, course_id, version_id, **kwargs):  # noqa: E501
        """Get details on a course version.   # noqa: E501

        Get specific version `versionId` of `courseId`   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_course_version_info_with_http_info(course_id, version_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: (required)
        :param int version_id: The course version (required)
        :param bool include_registration_count: Include the registration count in the results
        :param bool include_course_metadata: Include course metadata in the results. If the course has no metadata, adding this parameter has no effect.
        :return: CourseSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['course_id', 'version_id', 'include_registration_count', 'include_course_metadata']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_course_version_info" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'course_id' is set
        if ('course_id' not in params or
                params['course_id'] is None):
            raise ValueError("Missing the required parameter `course_id` when calling `get_course_version_info`")  # noqa: E501
        # verify the required parameter 'version_id' is set
        if ('version_id' not in params or
                params['version_id'] is None):
            raise ValueError("Missing the required parameter `version_id` when calling `get_course_version_info`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'course_id' in params:
            path_params['courseId'] = params['course_id']  # noqa: E501
        if 'version_id' in params:
            path_params['versionId'] = params['version_id']  # noqa: E501

        query_params = []
        if 'include_registration_count' in params:
            query_params.append(('includeRegistrationCount', params['include_registration_count']))  # noqa: E501
        if 'include_course_metadata' in params:
            query_params.append(('includeCourseMetadata', params['include_course_metadata']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APP_NORMAL', 'OAUTH']  # noqa: E501

        return self.api_client.call_api(
            '/courses/{courseId}/versions/{versionId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CourseSchema',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_course_version_statements(self, course_id, version_id, **kwargs):  # noqa: E501
        """Get xAPI statements for a course version.   # noqa: E501

        Get xAPI statements for version `versionId` of `courseId`   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_course_version_statements(course_id, version_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: (required)
        :param int version_id: The course version (required)
        :param str learner_id: Only entries for the specified learner id will be included.
        :param datetime since: Only items updated since the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used.
        :param datetime until: Only items updated before the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used.
        :param str more: Value for this parameter will be provided in the 'more' property of registration lists, where needed. An opaque value, construction and parsing may change without notice.
        :return: XapiStatementResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_course_version_statements_with_http_info(course_id, version_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_course_version_statements_with_http_info(course_id, version_id, **kwargs)  # noqa: E501
            return data

    def get_course_version_statements_with_http_info(self, course_id, version_id, **kwargs):  # noqa: E501
        """Get xAPI statements for a course version.   # noqa: E501

        Get xAPI statements for version `versionId` of `courseId`   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_course_version_statements_with_http_info(course_id, version_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: (required)
        :param int version_id: The course version (required)
        :param str learner_id: Only entries for the specified learner id will be included.
        :param datetime since: Only items updated since the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used.
        :param datetime until: Only items updated before the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used.
        :param str more: Value for this parameter will be provided in the 'more' property of registration lists, where needed. An opaque value, construction and parsing may change without notice.
        :return: XapiStatementResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['course_id', 'version_id', 'learner_id', 'since', 'until', 'more']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_course_version_statements" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'course_id' is set
        if ('course_id' not in params or
                params['course_id'] is None):
            raise ValueError("Missing the required parameter `course_id` when calling `get_course_version_statements`")  # noqa: E501
        # verify the required parameter 'version_id' is set
        if ('version_id' not in params or
                params['version_id'] is None):
            raise ValueError("Missing the required parameter `version_id` when calling `get_course_version_statements`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'course_id' in params:
            path_params['courseId'] = params['course_id']  # noqa: E501
        if 'version_id' in params:
            path_params['versionId'] = params['version_id']  # noqa: E501

        query_params = []
        if 'learner_id' in params:
            query_params.append(('learnerId', params['learner_id']))  # noqa: E501
        if 'since' in params:
            query_params.append(('since', params['since']))  # noqa: E501
        if 'until' in params:
            query_params.append(('until', params['until']))  # noqa: E501
        if 'more' in params:
            query_params.append(('more', params['more']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APP_NORMAL', 'OAUTH']  # noqa: E501

        return self.api_client.call_api(
            '/courses/{courseId}/versions/{versionId}/xAPIStatements', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='XapiStatementResult',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_course_versions(self, course_id, **kwargs):  # noqa: E501
        """Get details on a course's versions.   # noqa: E501

        Get information about all versions of `courseId`.  This can be useful to see information such as registration counts and modification times across the versions of a course.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_course_versions(course_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: (required)
        :param datetime since: Only items updated since the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used.
        :param datetime until: Only items updated before the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used.
        :param bool include_registration_count: Include the registration count in the results
        :param bool include_course_metadata: Include course metadata in the results. If the course has no metadata, adding this parameter has no effect.
        :return: CourseListNonPagedSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_course_versions_with_http_info(course_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_course_versions_with_http_info(course_id, **kwargs)  # noqa: E501
            return data

    def get_course_versions_with_http_info(self, course_id, **kwargs):  # noqa: E501
        """Get details on a course's versions.   # noqa: E501

        Get information about all versions of `courseId`.  This can be useful to see information such as registration counts and modification times across the versions of a course.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_course_versions_with_http_info(course_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: (required)
        :param datetime since: Only items updated since the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used.
        :param datetime until: Only items updated before the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used.
        :param bool include_registration_count: Include the registration count in the results
        :param bool include_course_metadata: Include course metadata in the results. If the course has no metadata, adding this parameter has no effect.
        :return: CourseListNonPagedSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['course_id', 'since', 'until', 'include_registration_count', 'include_course_metadata']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_course_versions" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'course_id' is set
        if ('course_id' not in params or
                params['course_id'] is None):
            raise ValueError("Missing the required parameter `course_id` when calling `get_course_versions`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'course_id' in params:
            path_params['courseId'] = params['course_id']  # noqa: E501

        query_params = []
        if 'since' in params:
            query_params.append(('since', params['since']))  # noqa: E501
        if 'until' in params:
            query_params.append(('until', params['until']))  # noqa: E501
        if 'include_registration_count' in params:
            query_params.append(('includeRegistrationCount', params['include_registration_count']))  # noqa: E501
        if 'include_course_metadata' in params:
            query_params.append(('includeCourseMetadata', params['include_course_metadata']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APP_NORMAL', 'OAUTH']  # noqa: E501

        return self.api_client.call_api(
            '/courses/{courseId}/versions', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CourseListNonPagedSchema',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_courses(self, **kwargs):  # noqa: E501
        """Get all courses.   # noqa: E501

        Get all courses for the `appId` which was used to authenticate this call.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_courses(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str more: Value for this parameter will be provided in the 'more' property of registration lists, where needed. An opaque value, construction and parsing may change without notice.
        :param datetime since: Only items updated since the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used.
        :param datetime until: Only items updated before the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used.
        :param str filter: Optional string which filters results by a specified field (described by filterBy).
        :param str filter_by: Optional enum parameter for specifying the field on which to run the filter.  Defaults to course_id.
        :param str order_by: Optional enum parameter for specifying the field and order by which to sort the results.  Defaults to creation_date_desc.
        :param bool include_registration_count: Include the registration count in the results
        :param bool include_course_metadata: Include course metadata in the results. If the course has no metadata, adding this parameter has no effect.
        :param list[str] tags:
        :return: CourseListSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_courses_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_courses_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_courses_with_http_info(self, **kwargs):  # noqa: E501
        """Get all courses.   # noqa: E501

        Get all courses for the `appId` which was used to authenticate this call.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_courses_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str more: Value for this parameter will be provided in the 'more' property of registration lists, where needed. An opaque value, construction and parsing may change without notice.
        :param datetime since: Only items updated since the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used.
        :param datetime until: Only items updated before the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used.
        :param str filter: Optional string which filters results by a specified field (described by filterBy).
        :param str filter_by: Optional enum parameter for specifying the field on which to run the filter.  Defaults to course_id.
        :param str order_by: Optional enum parameter for specifying the field and order by which to sort the results.  Defaults to creation_date_desc.
        :param bool include_registration_count: Include the registration count in the results
        :param bool include_course_metadata: Include course metadata in the results. If the course has no metadata, adding this parameter has no effect.
        :param list[str] tags:
        :return: CourseListSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['more', 'since', 'until', 'filter', 'filter_by', 'order_by', 'include_registration_count', 'include_course_metadata', 'tags']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_courses" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'more' in params:
            query_params.append(('more', params['more']))  # noqa: E501
        if 'since' in params:
            query_params.append(('since', params['since']))  # noqa: E501
        if 'until' in params:
            query_params.append(('until', params['until']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501
        if 'filter_by' in params:
            query_params.append(('filterBy', params['filter_by']))  # noqa: E501
        if 'order_by' in params:
            query_params.append(('orderBy', params['order_by']))  # noqa: E501
        if 'include_registration_count' in params:
            query_params.append(('includeRegistrationCount', params['include_registration_count']))  # noqa: E501
        if 'include_course_metadata' in params:
            query_params.append(('includeCourseMetadata', params['include_course_metadata']))  # noqa: E501
        if 'tags' in params:
            query_params.append(('tags', params['tags']))  # noqa: E501
            collection_formats['tags'] = 'csv'  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APP_NORMAL', 'OAUTH']  # noqa: E501

        return self.api_client.call_api(
            '/courses', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CourseListSchema',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_import_job_status(self, import_job_id, **kwargs):  # noqa: E501
        """Get course import job status.   # noqa: E501

        Check the status of an import job.  This can be called incrementally to check to progress of a call to either of the import options.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_import_job_status(import_job_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str import_job_id: Id received when the import job was submitted to the importJobs resource. (required)
        :return: ImportJobResultSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_import_job_status_with_http_info(import_job_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_import_job_status_with_http_info(import_job_id, **kwargs)  # noqa: E501
            return data

    def get_import_job_status_with_http_info(self, import_job_id, **kwargs):  # noqa: E501
        """Get course import job status.   # noqa: E501

        Check the status of an import job.  This can be called incrementally to check to progress of a call to either of the import options.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_import_job_status_with_http_info(import_job_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str import_job_id: Id received when the import job was submitted to the importJobs resource. (required)
        :return: ImportJobResultSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['import_job_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_import_job_status" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'import_job_id' is set
        if ('import_job_id' not in params or
                params['import_job_id'] is None):
            raise ValueError("Missing the required parameter `import_job_id` when calling `get_import_job_status`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'import_job_id' in params:
            path_params['importJobId'] = params['import_job_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APP_NORMAL', 'OAUTH']  # noqa: E501

        return self.api_client.call_api(
            '/courses/importJobs/{importJobId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ImportJobResultSchema',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def put_course_tags(self, course_id, tags, **kwargs):  # noqa: E501
        """Set course tags.   # noqa: E501

        Set the tags for this course.  Note: any tags currently on this course will be overwritten with the new array of tags.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_course_tags(course_id, tags, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: (required)
        :param TagListSchema tags: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.put_course_tags_with_http_info(course_id, tags, **kwargs)  # noqa: E501
        else:
            (data) = self.put_course_tags_with_http_info(course_id, tags, **kwargs)  # noqa: E501
            return data

    def put_course_tags_with_http_info(self, course_id, tags, **kwargs):  # noqa: E501
        """Set course tags.   # noqa: E501

        Set the tags for this course.  Note: any tags currently on this course will be overwritten with the new array of tags.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_course_tags_with_http_info(course_id, tags, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: (required)
        :param TagListSchema tags: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['course_id', 'tags']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_course_tags" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'course_id' is set
        if ('course_id' not in params or
                params['course_id'] is None):
            raise ValueError("Missing the required parameter `course_id` when calling `put_course_tags`")  # noqa: E501
        # verify the required parameter 'tags' is set
        if ('tags' not in params or
                params['tags'] is None):
            raise ValueError("Missing the required parameter `tags` when calling `put_course_tags`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'course_id' in params:
            path_params['courseId'] = params['course_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'tags' in params:
            body_params = params['tags']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APP_NORMAL', 'OAUTH']  # noqa: E501

        return self.api_client.call_api(
            '/courses/{courseId}/tags', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def put_course_tags_batch(self, batch, **kwargs):  # noqa: E501
        """Set tags on courses.   # noqa: E501

        Sets all of the provided tags on all of the provided courses.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_course_tags_batch(batch, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param BatchTagsSchema batch: Object representing an array of ids to apply an array of tags to. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.put_course_tags_batch_with_http_info(batch, **kwargs)  # noqa: E501
        else:
            (data) = self.put_course_tags_batch_with_http_info(batch, **kwargs)  # noqa: E501
            return data

    def put_course_tags_batch_with_http_info(self, batch, **kwargs):  # noqa: E501
        """Set tags on courses.   # noqa: E501

        Sets all of the provided tags on all of the provided courses.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_course_tags_batch_with_http_info(batch, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param BatchTagsSchema batch: Object representing an array of ids to apply an array of tags to. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['batch']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_course_tags_batch" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'batch' is set
        if ('batch' not in params or
                params['batch'] is None):
            raise ValueError("Missing the required parameter `batch` when calling `put_course_tags_batch`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'batch' in params:
            body_params = params['batch']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APP_NORMAL', 'OAUTH']  # noqa: E501

        return self.api_client.call_api(
            '/courses/tags', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def set_course_configuration(self, course_id, configuration_settings, **kwargs):  # noqa: E501
        """Set course configuration.   # noqa: E501

        Set configuration settings for this course.  Setting a value at this level will override any value which is set at the application level.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_course_configuration(course_id, configuration_settings, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: (required)
        :param SettingsPostSchema configuration_settings: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.set_course_configuration_with_http_info(course_id, configuration_settings, **kwargs)  # noqa: E501
        else:
            (data) = self.set_course_configuration_with_http_info(course_id, configuration_settings, **kwargs)  # noqa: E501
            return data

    def set_course_configuration_with_http_info(self, course_id, configuration_settings, **kwargs):  # noqa: E501
        """Set course configuration.   # noqa: E501

        Set configuration settings for this course.  Setting a value at this level will override any value which is set at the application level.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_course_configuration_with_http_info(course_id, configuration_settings, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: (required)
        :param SettingsPostSchema configuration_settings: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['course_id', 'configuration_settings']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method set_course_configuration" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'course_id' is set
        if ('course_id' not in params or
                params['course_id'] is None):
            raise ValueError("Missing the required parameter `course_id` when calling `set_course_configuration`")  # noqa: E501
        # verify the required parameter 'configuration_settings' is set
        if ('configuration_settings' not in params or
                params['configuration_settings'] is None):
            raise ValueError("Missing the required parameter `configuration_settings` when calling `set_course_configuration`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'course_id' in params:
            path_params['courseId'] = params['course_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'configuration_settings' in params:
            body_params = params['configuration_settings']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APP_NORMAL', 'OAUTH']  # noqa: E501

        return self.api_client.call_api(
            '/courses/{courseId}/configuration', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def set_course_title(self, course_id, title, **kwargs):  # noqa: E501
        """Set the title of a course.   # noqa: E501

        Sets the course title for the provided courseId.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_course_title(course_id, title, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: (required)
        :param TitleSchema title: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.set_course_title_with_http_info(course_id, title, **kwargs)  # noqa: E501
        else:
            (data) = self.set_course_title_with_http_info(course_id, title, **kwargs)  # noqa: E501
            return data

    def set_course_title_with_http_info(self, course_id, title, **kwargs):  # noqa: E501
        """Set the title of a course.   # noqa: E501

        Sets the course title for the provided courseId.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_course_title_with_http_info(course_id, title, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: (required)
        :param TitleSchema title: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['course_id', 'title']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method set_course_title" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'course_id' is set
        if ('course_id' not in params or
                params['course_id'] is None):
            raise ValueError("Missing the required parameter `course_id` when calling `set_course_title`")  # noqa: E501
        # verify the required parameter 'title' is set
        if ('title' not in params or
                params['title'] is None):
            raise ValueError("Missing the required parameter `title` when calling `set_course_title`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'course_id' in params:
            path_params['courseId'] = params['course_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'title' in params:
            body_params = params['title']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APP_NORMAL', 'OAUTH']  # noqa: E501

        return self.api_client.call_api(
            '/courses/{courseId}/title', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def set_course_version_configuration(self, course_id, version_id, configuration_settings, **kwargs):  # noqa: E501
        """Set configuration for a version of a course.   # noqa: E501

        Set configuration settings for this course and version.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_course_version_configuration(course_id, version_id, configuration_settings, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: (required)
        :param int version_id: The course version (required)
        :param SettingsPostSchema configuration_settings: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.set_course_version_configuration_with_http_info(course_id, version_id, configuration_settings, **kwargs)  # noqa: E501
        else:
            (data) = self.set_course_version_configuration_with_http_info(course_id, version_id, configuration_settings, **kwargs)  # noqa: E501
            return data

    def set_course_version_configuration_with_http_info(self, course_id, version_id, configuration_settings, **kwargs):  # noqa: E501
        """Set configuration for a version of a course.   # noqa: E501

        Set configuration settings for this course and version.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_course_version_configuration_with_http_info(course_id, version_id, configuration_settings, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: (required)
        :param int version_id: The course version (required)
        :param SettingsPostSchema configuration_settings: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['course_id', 'version_id', 'configuration_settings']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method set_course_version_configuration" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'course_id' is set
        if ('course_id' not in params or
                params['course_id'] is None):
            raise ValueError("Missing the required parameter `course_id` when calling `set_course_version_configuration`")  # noqa: E501
        # verify the required parameter 'version_id' is set
        if ('version_id' not in params or
                params['version_id'] is None):
            raise ValueError("Missing the required parameter `version_id` when calling `set_course_version_configuration`")  # noqa: E501
        # verify the required parameter 'configuration_settings' is set
        if ('configuration_settings' not in params or
                params['configuration_settings'] is None):
            raise ValueError("Missing the required parameter `configuration_settings` when calling `set_course_version_configuration`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'course_id' in params:
            path_params['courseId'] = params['course_id']  # noqa: E501
        if 'version_id' in params:
            path_params['versionId'] = params['version_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'configuration_settings' in params:
            body_params = params['configuration_settings']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APP_NORMAL', 'OAUTH']  # noqa: E501

        return self.api_client.call_api(
            '/courses/{courseId}/versions/{versionId}/configuration', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
