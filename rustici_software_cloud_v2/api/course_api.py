# coding: utf-8

"""
    SCORM Cloud Rest API

    REST API used for SCORM Cloud integrations.  # noqa: E501

    OpenAPI spec version: 2.0
    Contact: systems@rusticisoftware.com
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from rustici_software_cloud_v2.api_client import ApiClient


class CourseApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def build_course_preview_launch_link(self, course_id, launch_link_request, **kwargs):  # noqa: E501
        """Get a launch link to preview a Course   # noqa: E501

        Returns the launch link to use to preview the course.  Course preview does not require an underlying registration. As such, no interactions will be tracked during the preview launch.  Previews are meant to be a way to confirm the course looks and acts the way it should.  >**Note:** >The cmi5 standard does not support the ability to preview a course.  A launch link can be built for a cmi5 course, but visiting the link will result in an error page.  More details can be found in this [article explaining the complications behind cmi5 preview launches](https://support.scorm.com/hc/en-us/articles/1260805676710).   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.build_course_preview_launch_link(course_id, launch_link_request, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: (required)
        :param LaunchLinkRequestSchema launch_link_request: (required)
        :return: LaunchLinkSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.build_course_preview_launch_link_with_http_info(course_id, launch_link_request, **kwargs)  # noqa: E501
        else:
            (data) = self.build_course_preview_launch_link_with_http_info(course_id, launch_link_request, **kwargs)  # noqa: E501
            return data

    def build_course_preview_launch_link_with_http_info(self, course_id, launch_link_request, **kwargs):  # noqa: E501
        """Get a launch link to preview a Course   # noqa: E501

        Returns the launch link to use to preview the course.  Course preview does not require an underlying registration. As such, no interactions will be tracked during the preview launch.  Previews are meant to be a way to confirm the course looks and acts the way it should.  >**Note:** >The cmi5 standard does not support the ability to preview a course.  A launch link can be built for a cmi5 course, but visiting the link will result in an error page.  More details can be found in this [article explaining the complications behind cmi5 preview launches](https://support.scorm.com/hc/en-us/articles/1260805676710).   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.build_course_preview_launch_link_with_http_info(course_id, launch_link_request, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: (required)
        :param LaunchLinkRequestSchema launch_link_request: (required)
        :return: LaunchLinkSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['course_id', 'launch_link_request']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method build_course_preview_launch_link" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'course_id' is set
        if ('course_id' not in params or
                params['course_id'] is None):
            raise ValueError("Missing the required parameter `course_id` when calling `build_course_preview_launch_link`")  # noqa: E501
        # verify the required parameter 'launch_link_request' is set
        if ('launch_link_request' not in params or
                params['launch_link_request'] is None):
            raise ValueError("Missing the required parameter `launch_link_request` when calling `build_course_preview_launch_link`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'course_id' in params:
            path_params['courseId'] = params['course_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'launch_link_request' in params:
            body_params = params['launch_link_request']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APP_NORMAL', 'OAUTH']  # noqa: E501

        return self.api_client.call_api(
            '/courses/{courseId}/preview', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LaunchLinkSchema',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def build_course_preview_launch_link_with_version(self, course_id, version_id, launch_link_request, **kwargs):  # noqa: E501
        """Get a launch link to preview a Course Version   # noqa: E501

        Returns the launch link to use to preview the course version.  Course preview does not require an underlying registration.  As such, no interactions will be tracked during the preview launch.  Previews are meant to be a way to confirm the course looks and acts the way it should.  >**Note:** >The cmi5 standard does not support the ability to preview a course.  A launch link can be built for a cmi5 course, but visiting the link will result in an error page.  More details can be found in this [article explaining the complications behind cmi5 preview launches](https://support.scorm.com/hc/en-us/articles/1260805676710).   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.build_course_preview_launch_link_with_version(course_id, version_id, launch_link_request, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: (required)
        :param int version_id: (required)
        :param LaunchLinkRequestSchema launch_link_request: (required)
        :return: LaunchLinkSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.build_course_preview_launch_link_with_version_with_http_info(course_id, version_id, launch_link_request, **kwargs)  # noqa: E501
        else:
            (data) = self.build_course_preview_launch_link_with_version_with_http_info(course_id, version_id, launch_link_request, **kwargs)  # noqa: E501
            return data

    def build_course_preview_launch_link_with_version_with_http_info(self, course_id, version_id, launch_link_request, **kwargs):  # noqa: E501
        """Get a launch link to preview a Course Version   # noqa: E501

        Returns the launch link to use to preview the course version.  Course preview does not require an underlying registration.  As such, no interactions will be tracked during the preview launch.  Previews are meant to be a way to confirm the course looks and acts the way it should.  >**Note:** >The cmi5 standard does not support the ability to preview a course.  A launch link can be built for a cmi5 course, but visiting the link will result in an error page.  More details can be found in this [article explaining the complications behind cmi5 preview launches](https://support.scorm.com/hc/en-us/articles/1260805676710).   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.build_course_preview_launch_link_with_version_with_http_info(course_id, version_id, launch_link_request, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: (required)
        :param int version_id: (required)
        :param LaunchLinkRequestSchema launch_link_request: (required)
        :return: LaunchLinkSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['course_id', 'version_id', 'launch_link_request']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method build_course_preview_launch_link_with_version" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'course_id' is set
        if ('course_id' not in params or
                params['course_id'] is None):
            raise ValueError("Missing the required parameter `course_id` when calling `build_course_preview_launch_link_with_version`")  # noqa: E501
        # verify the required parameter 'version_id' is set
        if ('version_id' not in params or
                params['version_id'] is None):
            raise ValueError("Missing the required parameter `version_id` when calling `build_course_preview_launch_link_with_version`")  # noqa: E501
        # verify the required parameter 'launch_link_request' is set
        if ('launch_link_request' not in params or
                params['launch_link_request'] is None):
            raise ValueError("Missing the required parameter `launch_link_request` when calling `build_course_preview_launch_link_with_version`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'course_id' in params:
            path_params['courseId'] = params['course_id']  # noqa: E501
        if 'version_id' in params:
            path_params['versionId'] = params['version_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'launch_link_request' in params:
            body_params = params['launch_link_request']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APP_NORMAL', 'OAUTH']  # noqa: E501

        return self.api_client.call_api(
            '/courses/{courseId}/versions/{versionId}/preview', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LaunchLinkSchema',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_fetch_and_import_course_job(self, course_id, import_request, **kwargs):  # noqa: E501
        """Create a Course from a package fetched from an external source   # noqa: E501

        Creates a course from a package fetched and imported from the provided url.  The package will be downloaded from the url and stored in SCORM Cloud.  An import job ID will be returned, which can be used with GetImportJobStatus to view the status of the import.  Courses represent the learning material a learner will progress through.  >**Note:** >The import job ID used for calls to GetImportJobStatus are only valid for one week after the course import finishes.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_fetch_and_import_course_job(course_id, import_request, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: A unique identifier your application will use to identify the course after import. Your application is responsible both for generating this unique ID and for keeping track of the ID for later use. (required)
        :param ImportFetchRequestSchema import_request: (required)
        :param bool may_create_new_version: Is it OK to create a new version of this course? If this is set to false and the course already exists, the upload will fail. If true and the course already exists then a new version will be created. No effect if the course doesn't already exist.
        :param str postback_url: An optional parameter that specifies a URL to send a postback to when the course has finished uploading.
        :return: StringResultSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_fetch_and_import_course_job_with_http_info(course_id, import_request, **kwargs)  # noqa: E501
        else:
            (data) = self.create_fetch_and_import_course_job_with_http_info(course_id, import_request, **kwargs)  # noqa: E501
            return data

    def create_fetch_and_import_course_job_with_http_info(self, course_id, import_request, **kwargs):  # noqa: E501
        """Create a Course from a package fetched from an external source   # noqa: E501

        Creates a course from a package fetched and imported from the provided url.  The package will be downloaded from the url and stored in SCORM Cloud.  An import job ID will be returned, which can be used with GetImportJobStatus to view the status of the import.  Courses represent the learning material a learner will progress through.  >**Note:** >The import job ID used for calls to GetImportJobStatus are only valid for one week after the course import finishes.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_fetch_and_import_course_job_with_http_info(course_id, import_request, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: A unique identifier your application will use to identify the course after import. Your application is responsible both for generating this unique ID and for keeping track of the ID for later use. (required)
        :param ImportFetchRequestSchema import_request: (required)
        :param bool may_create_new_version: Is it OK to create a new version of this course? If this is set to false and the course already exists, the upload will fail. If true and the course already exists then a new version will be created. No effect if the course doesn't already exist.
        :param str postback_url: An optional parameter that specifies a URL to send a postback to when the course has finished uploading.
        :return: StringResultSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['course_id', 'import_request', 'may_create_new_version', 'postback_url']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_fetch_and_import_course_job" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'course_id' is set
        if ('course_id' not in params or
                params['course_id'] is None):
            raise ValueError("Missing the required parameter `course_id` when calling `create_fetch_and_import_course_job`")  # noqa: E501
        # verify the required parameter 'import_request' is set
        if ('import_request' not in params or
                params['import_request'] is None):
            raise ValueError("Missing the required parameter `import_request` when calling `create_fetch_and_import_course_job`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'course_id' in params:
            query_params.append(('courseId', params['course_id']))  # noqa: E501
        if 'may_create_new_version' in params:
            query_params.append(('mayCreateNewVersion', params['may_create_new_version']))  # noqa: E501
        if 'postback_url' in params:
            query_params.append(('postbackUrl', params['postback_url']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'import_request' in params:
            body_params = params['import_request']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APP_NORMAL', 'OAUTH']  # noqa: E501

        return self.api_client.call_api(
            '/courses/importJobs', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='StringResultSchema',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_no_upload_and_import_course_job(self, course_id, import_request, **kwargs):  # noqa: E501
        """Create a Course from a fetched or referenced external media file   # noqa: E501

        Creates a course from one of two methods, fetchRequest or mediaFileReferenceRequest.  In either case, an import job ID will be returned, which can be used with GetImportJobStatus to view the status of the import.  Courses represent the learning material a learner will progress through.  - A fetchRequest performs the same actions as CreateFetchAndImportCourseJob.  A course will be created from a package fetched from the provided url.  The package will be downloaded from the url and stored in SCORM Cloud. - A mediaFileReferenceRequest will not store the file in SCORM Cloud.  Instead it will reference the media file at the time the learner needs to view the file from the provided url.  >**Note:** >The import job ID used for calls to GetImportJobStatus are only valid for one week after the course import finishes.  >**Info:** >Unless working with media files, it is typical to use one of the other two import methods. >- CreateUploadAndImportCourseJob would be used if the course is in your local file system. >- CreateFetchAndImportCourseJob would be better suited for situations where the course is uploaded remotely but is accessible via a public url.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_no_upload_and_import_course_job(course_id, import_request, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: A unique identifier your application will use to identify the course after import. Your application is responsible both for generating this unique ID and for keeping track of the ID for later use. (required)
        :param ImportRequestSchema import_request: (required)
        :param bool may_create_new_version: Is it OK to create a new version of this course? If this is set to false and the course already exists, the upload will fail. If true and the course already exists then a new version will be created. No effect if the course doesn't already exist.
        :param str postback_url: An optional parameter that specifies a URL to send a postback to when the course has finished uploading.
        :return: StringResultSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_no_upload_and_import_course_job_with_http_info(course_id, import_request, **kwargs)  # noqa: E501
        else:
            (data) = self.create_no_upload_and_import_course_job_with_http_info(course_id, import_request, **kwargs)  # noqa: E501
            return data

    def create_no_upload_and_import_course_job_with_http_info(self, course_id, import_request, **kwargs):  # noqa: E501
        """Create a Course from a fetched or referenced external media file   # noqa: E501

        Creates a course from one of two methods, fetchRequest or mediaFileReferenceRequest.  In either case, an import job ID will be returned, which can be used with GetImportJobStatus to view the status of the import.  Courses represent the learning material a learner will progress through.  - A fetchRequest performs the same actions as CreateFetchAndImportCourseJob.  A course will be created from a package fetched from the provided url.  The package will be downloaded from the url and stored in SCORM Cloud. - A mediaFileReferenceRequest will not store the file in SCORM Cloud.  Instead it will reference the media file at the time the learner needs to view the file from the provided url.  >**Note:** >The import job ID used for calls to GetImportJobStatus are only valid for one week after the course import finishes.  >**Info:** >Unless working with media files, it is typical to use one of the other two import methods. >- CreateUploadAndImportCourseJob would be used if the course is in your local file system. >- CreateFetchAndImportCourseJob would be better suited for situations where the course is uploaded remotely but is accessible via a public url.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_no_upload_and_import_course_job_with_http_info(course_id, import_request, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: A unique identifier your application will use to identify the course after import. Your application is responsible both for generating this unique ID and for keeping track of the ID for later use. (required)
        :param ImportRequestSchema import_request: (required)
        :param bool may_create_new_version: Is it OK to create a new version of this course? If this is set to false and the course already exists, the upload will fail. If true and the course already exists then a new version will be created. No effect if the course doesn't already exist.
        :param str postback_url: An optional parameter that specifies a URL to send a postback to when the course has finished uploading.
        :return: StringResultSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['course_id', 'import_request', 'may_create_new_version', 'postback_url']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_no_upload_and_import_course_job" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'course_id' is set
        if ('course_id' not in params or
                params['course_id'] is None):
            raise ValueError("Missing the required parameter `course_id` when calling `create_no_upload_and_import_course_job`")  # noqa: E501
        # verify the required parameter 'import_request' is set
        if ('import_request' not in params or
                params['import_request'] is None):
            raise ValueError("Missing the required parameter `import_request` when calling `create_no_upload_and_import_course_job`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'course_id' in params:
            query_params.append(('courseId', params['course_id']))  # noqa: E501
        if 'may_create_new_version' in params:
            query_params.append(('mayCreateNewVersion', params['may_create_new_version']))  # noqa: E501
        if 'postback_url' in params:
            query_params.append(('postbackUrl', params['postback_url']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'import_request' in params:
            body_params = params['import_request']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APP_NORMAL', 'OAUTH']  # noqa: E501

        return self.api_client.call_api(
            '/courses/importJobs/noUpload', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='StringResultSchema',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_upload_and_import_course_job(self, course_id, **kwargs):  # noqa: E501
        """Create a Course from an uploaded package   # noqa: E501

        Creates a course from a package uploaded from your file system.  The package will be sent as part of the request and will be stored in SCORM Cloud.  An import job ID will be returned, which can be used with GetImportJobStatus to view the status of the import.  Courses represent the learning material a learner will progress through.  >**Note:** >The import job ID used for calls to GetImportJobStatus are only valid for one week after the course import finishes.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_upload_and_import_course_job(course_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: A unique identifier your application will use to identify the course after import. Your application is responsible both for generating this unique ID and for keeping track of the ID for later use. (required)
        :param bool may_create_new_version: Is it OK to create a new version of this course? If this is set to false and the course already exists, the upload will fail. If true and the course already exists then a new version will be created. No effect if the course doesn't already exist.
        :param str postback_url: An optional parameter that specifies a URL to send a postback to when the course has finished uploading.
        :param str uploaded_content_type: The MIME type identifier for the content to be uploaded. This is required if uploading a media file (.pdf, .mp3, or .mp4).
        :param str content_metadata: Serialized 'mediaFileMetadata' schema.
        :param file file: The zip file of the course contents to import. 
        :return: StringResultSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_upload_and_import_course_job_with_http_info(course_id, **kwargs)  # noqa: E501
        else:
            (data) = self.create_upload_and_import_course_job_with_http_info(course_id, **kwargs)  # noqa: E501
            return data

    def create_upload_and_import_course_job_with_http_info(self, course_id, **kwargs):  # noqa: E501
        """Create a Course from an uploaded package   # noqa: E501

        Creates a course from a package uploaded from your file system.  The package will be sent as part of the request and will be stored in SCORM Cloud.  An import job ID will be returned, which can be used with GetImportJobStatus to view the status of the import.  Courses represent the learning material a learner will progress through.  >**Note:** >The import job ID used for calls to GetImportJobStatus are only valid for one week after the course import finishes.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_upload_and_import_course_job_with_http_info(course_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: A unique identifier your application will use to identify the course after import. Your application is responsible both for generating this unique ID and for keeping track of the ID for later use. (required)
        :param bool may_create_new_version: Is it OK to create a new version of this course? If this is set to false and the course already exists, the upload will fail. If true and the course already exists then a new version will be created. No effect if the course doesn't already exist.
        :param str postback_url: An optional parameter that specifies a URL to send a postback to when the course has finished uploading.
        :param str uploaded_content_type: The MIME type identifier for the content to be uploaded. This is required if uploading a media file (.pdf, .mp3, or .mp4).
        :param str content_metadata: Serialized 'mediaFileMetadata' schema.
        :param file file: The zip file of the course contents to import. 
        :return: StringResultSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['course_id', 'may_create_new_version', 'postback_url', 'uploaded_content_type', 'content_metadata', 'file']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_upload_and_import_course_job" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'course_id' is set
        if ('course_id' not in params or
                params['course_id'] is None):
            raise ValueError("Missing the required parameter `course_id` when calling `create_upload_and_import_course_job`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'course_id' in params:
            query_params.append(('courseId', params['course_id']))  # noqa: E501
        if 'may_create_new_version' in params:
            query_params.append(('mayCreateNewVersion', params['may_create_new_version']))  # noqa: E501
        if 'postback_url' in params:
            query_params.append(('postbackUrl', params['postback_url']))  # noqa: E501

        header_params = {}
        if 'uploaded_content_type' in params:
            header_params['uploadedContentType'] = params['uploaded_content_type']  # noqa: E501

        form_params = []
        local_var_files = {}
        if 'content_metadata' in params:
            form_params.append(('contentMetadata', params['content_metadata']))  # noqa: E501
        if 'file' in params:
            local_var_files['file'] = params['file']  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APP_NORMAL', 'OAUTH']  # noqa: E501

        return self.api_client.call_api(
            '/courses/importJobs/upload', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='StringResultSchema',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_course(self, course_id, **kwargs):  # noqa: E501
        """Delete a Course   # noqa: E501

        Deletes the specified course.  >**Caution:** >When a course is deleted, so is everything connected to the course.  This includes: >- Registrations >- Invitations >- Dispatches >- Debug Logs   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_course(course_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_course_with_http_info(course_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_course_with_http_info(course_id, **kwargs)  # noqa: E501
            return data

    def delete_course_with_http_info(self, course_id, **kwargs):  # noqa: E501
        """Delete a Course   # noqa: E501

        Deletes the specified course.  >**Caution:** >When a course is deleted, so is everything connected to the course.  This includes: >- Registrations >- Invitations >- Dispatches >- Debug Logs   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_course_with_http_info(course_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['course_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_course" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'course_id' is set
        if ('course_id' not in params or
                params['course_id'] is None):
            raise ValueError("Missing the required parameter `course_id` when calling `delete_course`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'course_id' in params:
            path_params['courseId'] = params['course_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APP_NORMAL', 'OAUTH']  # noqa: E501

        return self.api_client.call_api(
            '/courses/{courseId}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_course_asset(self, course_id, relative_path, **kwargs):  # noqa: E501
        """Delete an asset file from a Course   # noqa: E501

        Deletes the asset file at the specified relative path from the latest version of the course. GetCourseFileList can be used to find the relative path of the file.  >**Caution:** >This may have unintended consequences if the asset is still being linked to in other files in the course.  Make sure that other files relying on this asset are modified or removed as well.  This can be done with the ImportCourseAssetFile or UploadCourseAssetFile endpoints.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_course_asset(course_id, relative_path, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: (required)
        :param str relative_path: Relative path of the asset within the course.  (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_course_asset_with_http_info(course_id, relative_path, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_course_asset_with_http_info(course_id, relative_path, **kwargs)  # noqa: E501
            return data

    def delete_course_asset_with_http_info(self, course_id, relative_path, **kwargs):  # noqa: E501
        """Delete an asset file from a Course   # noqa: E501

        Deletes the asset file at the specified relative path from the latest version of the course. GetCourseFileList can be used to find the relative path of the file.  >**Caution:** >This may have unintended consequences if the asset is still being linked to in other files in the course.  Make sure that other files relying on this asset are modified or removed as well.  This can be done with the ImportCourseAssetFile or UploadCourseAssetFile endpoints.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_course_asset_with_http_info(course_id, relative_path, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: (required)
        :param str relative_path: Relative path of the asset within the course.  (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['course_id', 'relative_path']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_course_asset" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'course_id' is set
        if ('course_id' not in params or
                params['course_id'] is None):
            raise ValueError("Missing the required parameter `course_id` when calling `delete_course_asset`")  # noqa: E501
        # verify the required parameter 'relative_path' is set
        if ('relative_path' not in params or
                params['relative_path'] is None):
            raise ValueError("Missing the required parameter `relative_path` when calling `delete_course_asset`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'course_id' in params:
            path_params['courseId'] = params['course_id']  # noqa: E501

        query_params = []
        if 'relative_path' in params:
            query_params.append(('relativePath', params['relative_path']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APP_NORMAL', 'OAUTH']  # noqa: E501

        return self.api_client.call_api(
            '/courses/{courseId}/asset', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_course_configuration_setting(self, course_id, setting_id, **kwargs):  # noqa: E501
        """Delete a configuration setting explicitly set for a Course   # noqa: E501

        Clears the specified setting from the course.  This causes the setting to inherit a value from a higher level (e.g. application).  If the configuration setting was not set at the course level it will continue to persist and will require deletion from the level it was set.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_course_configuration_setting(course_id, setting_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: (required)
        :param str setting_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_course_configuration_setting_with_http_info(course_id, setting_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_course_configuration_setting_with_http_info(course_id, setting_id, **kwargs)  # noqa: E501
            return data

    def delete_course_configuration_setting_with_http_info(self, course_id, setting_id, **kwargs):  # noqa: E501
        """Delete a configuration setting explicitly set for a Course   # noqa: E501

        Clears the specified setting from the course.  This causes the setting to inherit a value from a higher level (e.g. application).  If the configuration setting was not set at the course level it will continue to persist and will require deletion from the level it was set.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_course_configuration_setting_with_http_info(course_id, setting_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: (required)
        :param str setting_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['course_id', 'setting_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_course_configuration_setting" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'course_id' is set
        if ('course_id' not in params or
                params['course_id'] is None):
            raise ValueError("Missing the required parameter `course_id` when calling `delete_course_configuration_setting`")  # noqa: E501
        # verify the required parameter 'setting_id' is set
        if ('setting_id' not in params or
                params['setting_id'] is None):
            raise ValueError("Missing the required parameter `setting_id` when calling `delete_course_configuration_setting`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'course_id' in params:
            path_params['courseId'] = params['course_id']  # noqa: E501
        if 'setting_id' in params:
            path_params['settingId'] = params['setting_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APP_NORMAL', 'OAUTH']  # noqa: E501

        return self.api_client.call_api(
            '/courses/{courseId}/configuration/{settingId}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_course_tags(self, course_id, tags, **kwargs):  # noqa: E501
        """Delete tags from a Course   # noqa: E501

        Deletes the specified tags from the course.  Deleting tags that do not exist will still result in a success.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_course_tags(course_id, tags, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: (required)
        :param TagListSchema tags: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_course_tags_with_http_info(course_id, tags, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_course_tags_with_http_info(course_id, tags, **kwargs)  # noqa: E501
            return data

    def delete_course_tags_with_http_info(self, course_id, tags, **kwargs):  # noqa: E501
        """Delete tags from a Course   # noqa: E501

        Deletes the specified tags from the course.  Deleting tags that do not exist will still result in a success.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_course_tags_with_http_info(course_id, tags, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: (required)
        :param TagListSchema tags: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['course_id', 'tags']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_course_tags" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'course_id' is set
        if ('course_id' not in params or
                params['course_id'] is None):
            raise ValueError("Missing the required parameter `course_id` when calling `delete_course_tags`")  # noqa: E501
        # verify the required parameter 'tags' is set
        if ('tags' not in params or
                params['tags'] is None):
            raise ValueError("Missing the required parameter `tags` when calling `delete_course_tags`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'course_id' in params:
            path_params['courseId'] = params['course_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'tags' in params:
            body_params = params['tags']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APP_NORMAL', 'OAUTH']  # noqa: E501

        return self.api_client.call_api(
            '/courses/{courseId}/tags', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_course_version(self, course_id, version_id, **kwargs):  # noqa: E501
        """Delete a Course Version   # noqa: E501

        Deletes the specified version of the course.  If deleting the last remaining version of the course, the course itself will be deleted and no longer accessible.  >**Caution:** >When a course is deleted, so is everything connected to this course.  This includes: >- Registrations >- Invitations >- Dispatches >- Debug Logs   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_course_version(course_id, version_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: (required)
        :param int version_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_course_version_with_http_info(course_id, version_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_course_version_with_http_info(course_id, version_id, **kwargs)  # noqa: E501
            return data

    def delete_course_version_with_http_info(self, course_id, version_id, **kwargs):  # noqa: E501
        """Delete a Course Version   # noqa: E501

        Deletes the specified version of the course.  If deleting the last remaining version of the course, the course itself will be deleted and no longer accessible.  >**Caution:** >When a course is deleted, so is everything connected to this course.  This includes: >- Registrations >- Invitations >- Dispatches >- Debug Logs   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_course_version_with_http_info(course_id, version_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: (required)
        :param int version_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['course_id', 'version_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_course_version" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'course_id' is set
        if ('course_id' not in params or
                params['course_id'] is None):
            raise ValueError("Missing the required parameter `course_id` when calling `delete_course_version`")  # noqa: E501
        # verify the required parameter 'version_id' is set
        if ('version_id' not in params or
                params['version_id'] is None):
            raise ValueError("Missing the required parameter `version_id` when calling `delete_course_version`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'course_id' in params:
            path_params['courseId'] = params['course_id']  # noqa: E501
        if 'version_id' in params:
            path_params['versionId'] = params['version_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APP_NORMAL', 'OAUTH']  # noqa: E501

        return self.api_client.call_api(
            '/courses/{courseId}/versions/{versionId}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_course_version_asset(self, course_id, version_id, relative_path, **kwargs):  # noqa: E501
        """Delete an asset file from a Course Version   # noqa: E501

        Deletes the asset file at the specified relative path from the course version.  GetCourseVersionFileList can be used to find the relative path of the file.  >**Caution:** >This may have unintended consequences if the asset is still being linked to in other files in the course.  Make sure that other files relying on this asset are modified or removed as well.  This can be done with the ImportCourseVersionAssetFile or UploadCourseVersionAssetFile endpoints.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_course_version_asset(course_id, version_id, relative_path, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: (required)
        :param int version_id: (required)
        :param str relative_path: Relative path of the asset within the course.  (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_course_version_asset_with_http_info(course_id, version_id, relative_path, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_course_version_asset_with_http_info(course_id, version_id, relative_path, **kwargs)  # noqa: E501
            return data

    def delete_course_version_asset_with_http_info(self, course_id, version_id, relative_path, **kwargs):  # noqa: E501
        """Delete an asset file from a Course Version   # noqa: E501

        Deletes the asset file at the specified relative path from the course version.  GetCourseVersionFileList can be used to find the relative path of the file.  >**Caution:** >This may have unintended consequences if the asset is still being linked to in other files in the course.  Make sure that other files relying on this asset are modified or removed as well.  This can be done with the ImportCourseVersionAssetFile or UploadCourseVersionAssetFile endpoints.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_course_version_asset_with_http_info(course_id, version_id, relative_path, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: (required)
        :param int version_id: (required)
        :param str relative_path: Relative path of the asset within the course.  (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['course_id', 'version_id', 'relative_path']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_course_version_asset" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'course_id' is set
        if ('course_id' not in params or
                params['course_id'] is None):
            raise ValueError("Missing the required parameter `course_id` when calling `delete_course_version_asset`")  # noqa: E501
        # verify the required parameter 'version_id' is set
        if ('version_id' not in params or
                params['version_id'] is None):
            raise ValueError("Missing the required parameter `version_id` when calling `delete_course_version_asset`")  # noqa: E501
        # verify the required parameter 'relative_path' is set
        if ('relative_path' not in params or
                params['relative_path'] is None):
            raise ValueError("Missing the required parameter `relative_path` when calling `delete_course_version_asset`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'course_id' in params:
            path_params['courseId'] = params['course_id']  # noqa: E501
        if 'version_id' in params:
            path_params['versionId'] = params['version_id']  # noqa: E501

        query_params = []
        if 'relative_path' in params:
            query_params.append(('relativePath', params['relative_path']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APP_NORMAL', 'OAUTH']  # noqa: E501

        return self.api_client.call_api(
            '/courses/{courseId}/versions/{versionId}/asset', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_course_version_configuration_setting(self, course_id, version_id, setting_id, **kwargs):  # noqa: E501
        """Delete a configuration setting explicitly set for a Course Version   # noqa: E501

        Clears the specified setting from the course version.  This causes the setting to inherit a value from a higher level (e.g. application).  If the configuration setting was not set at the course level it will continue to persist and will require deletion from the level it was set.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_course_version_configuration_setting(course_id, version_id, setting_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: (required)
        :param int version_id: (required)
        :param str setting_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_course_version_configuration_setting_with_http_info(course_id, version_id, setting_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_course_version_configuration_setting_with_http_info(course_id, version_id, setting_id, **kwargs)  # noqa: E501
            return data

    def delete_course_version_configuration_setting_with_http_info(self, course_id, version_id, setting_id, **kwargs):  # noqa: E501
        """Delete a configuration setting explicitly set for a Course Version   # noqa: E501

        Clears the specified setting from the course version.  This causes the setting to inherit a value from a higher level (e.g. application).  If the configuration setting was not set at the course level it will continue to persist and will require deletion from the level it was set.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_course_version_configuration_setting_with_http_info(course_id, version_id, setting_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: (required)
        :param int version_id: (required)
        :param str setting_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['course_id', 'version_id', 'setting_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_course_version_configuration_setting" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'course_id' is set
        if ('course_id' not in params or
                params['course_id'] is None):
            raise ValueError("Missing the required parameter `course_id` when calling `delete_course_version_configuration_setting`")  # noqa: E501
        # verify the required parameter 'version_id' is set
        if ('version_id' not in params or
                params['version_id'] is None):
            raise ValueError("Missing the required parameter `version_id` when calling `delete_course_version_configuration_setting`")  # noqa: E501
        # verify the required parameter 'setting_id' is set
        if ('setting_id' not in params or
                params['setting_id'] is None):
            raise ValueError("Missing the required parameter `setting_id` when calling `delete_course_version_configuration_setting`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'course_id' in params:
            path_params['courseId'] = params['course_id']  # noqa: E501
        if 'version_id' in params:
            path_params['versionId'] = params['version_id']  # noqa: E501
        if 'setting_id' in params:
            path_params['settingId'] = params['setting_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APP_NORMAL', 'OAUTH']  # noqa: E501

        return self.api_client.call_api(
            '/courses/{courseId}/versions/{versionId}/configuration/{settingId}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_course(self, course_id, **kwargs):  # noqa: E501
        """Get detailed information about a Course   # noqa: E501

        Returns detailed information about the course.  This includes title, update date, learning standard, and version.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_course(course_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: (required)
        :param bool include_registration_count: Include the registration count in the results
        :param bool include_course_metadata: Include course metadata in the results. If the course has no metadata, adding this parameter has no effect.
        :return: CourseSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_course_with_http_info(course_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_course_with_http_info(course_id, **kwargs)  # noqa: E501
            return data

    def get_course_with_http_info(self, course_id, **kwargs):  # noqa: E501
        """Get detailed information about a Course   # noqa: E501

        Returns detailed information about the course.  This includes title, update date, learning standard, and version.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_course_with_http_info(course_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: (required)
        :param bool include_registration_count: Include the registration count in the results
        :param bool include_course_metadata: Include course metadata in the results. If the course has no metadata, adding this parameter has no effect.
        :return: CourseSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['course_id', 'include_registration_count', 'include_course_metadata']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_course" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'course_id' is set
        if ('course_id' not in params or
                params['course_id'] is None):
            raise ValueError("Missing the required parameter `course_id` when calling `get_course`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'course_id' in params:
            path_params['courseId'] = params['course_id']  # noqa: E501

        query_params = []
        if 'include_registration_count' in params:
            query_params.append(('includeRegistrationCount', params['include_registration_count']))  # noqa: E501
        if 'include_course_metadata' in params:
            query_params.append(('includeCourseMetadata', params['include_course_metadata']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APP_NORMAL', 'OAUTH']  # noqa: E501

        return self.api_client.call_api(
            '/courses/{courseId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CourseSchema',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_course_asset(self, course_id, relative_path, **kwargs):  # noqa: E501
        """Download an asset file from a Course   # noqa: E501

        Downloads the asset file at the specified relative path from the latest version of the course. GetCourseFileList can be used to find the relative path of the file.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_course_asset(course_id, relative_path, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: (required)
        :param str relative_path: Relative path of the asset within the course.  (required)
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_course_asset_with_http_info(course_id, relative_path, **kwargs)  # noqa: E501
        else:
            (data) = self.get_course_asset_with_http_info(course_id, relative_path, **kwargs)  # noqa: E501
            return data

    def get_course_asset_with_http_info(self, course_id, relative_path, **kwargs):  # noqa: E501
        """Download an asset file from a Course   # noqa: E501

        Downloads the asset file at the specified relative path from the latest version of the course. GetCourseFileList can be used to find the relative path of the file.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_course_asset_with_http_info(course_id, relative_path, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: (required)
        :param str relative_path: Relative path of the asset within the course.  (required)
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['course_id', 'relative_path']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_course_asset" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'course_id' is set
        if ('course_id' not in params or
                params['course_id'] is None):
            raise ValueError("Missing the required parameter `course_id` when calling `get_course_asset`")  # noqa: E501
        # verify the required parameter 'relative_path' is set
        if ('relative_path' not in params or
                params['relative_path'] is None):
            raise ValueError("Missing the required parameter `relative_path` when calling `get_course_asset`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'course_id' in params:
            path_params['courseId'] = params['course_id']  # noqa: E501

        query_params = []
        if 'relative_path' in params:
            query_params.append(('relativePath', params['relative_path']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/octet-stream'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APP_NORMAL', 'OAUTH']  # noqa: E501

        return self.api_client.call_api(
            '/courses/{courseId}/asset', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='file',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_course_configuration(self, course_id, **kwargs):  # noqa: E501
        """Get effective configuration settings for a Course   # noqa: E501

        Returns the effective configuration settings for the course.  If not set at the course level, the setting will inherit a value from a higher level (e.g. application).  If there is a configuration setting present at a more specific level, that setting will override the one set at the course level.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_course_configuration(course_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: (required)
        :param bool include_metadata:
        :return: SettingListSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_course_configuration_with_http_info(course_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_course_configuration_with_http_info(course_id, **kwargs)  # noqa: E501
            return data

    def get_course_configuration_with_http_info(self, course_id, **kwargs):  # noqa: E501
        """Get effective configuration settings for a Course   # noqa: E501

        Returns the effective configuration settings for the course.  If not set at the course level, the setting will inherit a value from a higher level (e.g. application).  If there is a configuration setting present at a more specific level, that setting will override the one set at the course level.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_course_configuration_with_http_info(course_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: (required)
        :param bool include_metadata:
        :return: SettingListSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['course_id', 'include_metadata']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_course_configuration" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'course_id' is set
        if ('course_id' not in params or
                params['course_id'] is None):
            raise ValueError("Missing the required parameter `course_id` when calling `get_course_configuration`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'course_id' in params:
            path_params['courseId'] = params['course_id']  # noqa: E501

        query_params = []
        if 'include_metadata' in params:
            query_params.append(('includeMetadata', params['include_metadata']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APP_NORMAL', 'OAUTH']  # noqa: E501

        return self.api_client.call_api(
            '/courses/{courseId}/configuration', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SettingListSchema',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_course_file_list(self, course_id, **kwargs):  # noqa: E501
        """Get a list of asset files in a Course   # noqa: E501

        Returns a list of asset files in the course.  Included will be the relative path to use for the other course asset manipulation calls.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_course_file_list(course_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: (required)
        :return: FileListSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_course_file_list_with_http_info(course_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_course_file_list_with_http_info(course_id, **kwargs)  # noqa: E501
            return data

    def get_course_file_list_with_http_info(self, course_id, **kwargs):  # noqa: E501
        """Get a list of asset files in a Course   # noqa: E501

        Returns a list of asset files in the course.  Included will be the relative path to use for the other course asset manipulation calls.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_course_file_list_with_http_info(course_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: (required)
        :return: FileListSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['course_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_course_file_list" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'course_id' is set
        if ('course_id' not in params or
                params['course_id'] is None):
            raise ValueError("Missing the required parameter `course_id` when calling `get_course_file_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'course_id' in params:
            path_params['courseId'] = params['course_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APP_NORMAL', 'OAUTH']  # noqa: E501

        return self.api_client.call_api(
            '/courses/{courseId}/asset/list', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='FileListSchema',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_course_statements(self, course_id, **kwargs):  # noqa: E501
        """Get xAPI statements for a Course   # noqa: E501

        Returns xAPI statements for the course.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_course_statements(course_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: (required)
        :param str learner_id: Only entries for the specified learner id will be included.
        :param datetime since: Filter by ISO 8601 TimeStamp inclusive (defaults to UTC)
        :param datetime until: Filter by ISO 8601 TimeStamp inclusive (defaults to UTC)
        :param str more: Pagination token returned as `more` property of multi page list requests
        :return: XapiStatementResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_course_statements_with_http_info(course_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_course_statements_with_http_info(course_id, **kwargs)  # noqa: E501
            return data

    def get_course_statements_with_http_info(self, course_id, **kwargs):  # noqa: E501
        """Get xAPI statements for a Course   # noqa: E501

        Returns xAPI statements for the course.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_course_statements_with_http_info(course_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: (required)
        :param str learner_id: Only entries for the specified learner id will be included.
        :param datetime since: Filter by ISO 8601 TimeStamp inclusive (defaults to UTC)
        :param datetime until: Filter by ISO 8601 TimeStamp inclusive (defaults to UTC)
        :param str more: Pagination token returned as `more` property of multi page list requests
        :return: XapiStatementResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['course_id', 'learner_id', 'since', 'until', 'more']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_course_statements" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'course_id' is set
        if ('course_id' not in params or
                params['course_id'] is None):
            raise ValueError("Missing the required parameter `course_id` when calling `get_course_statements`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'course_id' in params:
            path_params['courseId'] = params['course_id']  # noqa: E501

        query_params = []
        if 'learner_id' in params:
            query_params.append(('learnerId', params['learner_id']))  # noqa: E501
        if 'since' in params:
            query_params.append(('since', params['since']))  # noqa: E501
        if 'until' in params:
            query_params.append(('until', params['until']))  # noqa: E501
        if 'more' in params:
            query_params.append(('more', params['more']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APP_NORMAL', 'OAUTH']  # noqa: E501

        return self.api_client.call_api(
            '/courses/{courseId}/xAPIStatements', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='XapiStatementResult',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_course_tags(self, course_id, **kwargs):  # noqa: E501
        """Get tags for a Course   # noqa: E501

        Returns the tags for the course.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_course_tags(course_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: (required)
        :return: TagListSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_course_tags_with_http_info(course_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_course_tags_with_http_info(course_id, **kwargs)  # noqa: E501
            return data

    def get_course_tags_with_http_info(self, course_id, **kwargs):  # noqa: E501
        """Get tags for a Course   # noqa: E501

        Returns the tags for the course.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_course_tags_with_http_info(course_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: (required)
        :return: TagListSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['course_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_course_tags" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'course_id' is set
        if ('course_id' not in params or
                params['course_id'] is None):
            raise ValueError("Missing the required parameter `course_id` when calling `get_course_tags`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'course_id' in params:
            path_params['courseId'] = params['course_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APP_NORMAL', 'OAUTH']  # noqa: E501

        return self.api_client.call_api(
            '/courses/{courseId}/tags', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TagListSchema',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_course_version_asset(self, course_id, version_id, relative_path, **kwargs):  # noqa: E501
        """Download an asset file from a specific Course Version   # noqa: E501

        Downloads the asset file at the provided relative path from the course version.  GetCourseVersionFileList can be used to find the relative path of the file.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_course_version_asset(course_id, version_id, relative_path, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: (required)
        :param int version_id: (required)
        :param str relative_path: Relative path of the asset within the course.  (required)
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_course_version_asset_with_http_info(course_id, version_id, relative_path, **kwargs)  # noqa: E501
        else:
            (data) = self.get_course_version_asset_with_http_info(course_id, version_id, relative_path, **kwargs)  # noqa: E501
            return data

    def get_course_version_asset_with_http_info(self, course_id, version_id, relative_path, **kwargs):  # noqa: E501
        """Download an asset file from a specific Course Version   # noqa: E501

        Downloads the asset file at the provided relative path from the course version.  GetCourseVersionFileList can be used to find the relative path of the file.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_course_version_asset_with_http_info(course_id, version_id, relative_path, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: (required)
        :param int version_id: (required)
        :param str relative_path: Relative path of the asset within the course.  (required)
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['course_id', 'version_id', 'relative_path']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_course_version_asset" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'course_id' is set
        if ('course_id' not in params or
                params['course_id'] is None):
            raise ValueError("Missing the required parameter `course_id` when calling `get_course_version_asset`")  # noqa: E501
        # verify the required parameter 'version_id' is set
        if ('version_id' not in params or
                params['version_id'] is None):
            raise ValueError("Missing the required parameter `version_id` when calling `get_course_version_asset`")  # noqa: E501
        # verify the required parameter 'relative_path' is set
        if ('relative_path' not in params or
                params['relative_path'] is None):
            raise ValueError("Missing the required parameter `relative_path` when calling `get_course_version_asset`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'course_id' in params:
            path_params['courseId'] = params['course_id']  # noqa: E501
        if 'version_id' in params:
            path_params['versionId'] = params['version_id']  # noqa: E501

        query_params = []
        if 'relative_path' in params:
            query_params.append(('relativePath', params['relative_path']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/octet-stream'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APP_NORMAL', 'OAUTH']  # noqa: E501

        return self.api_client.call_api(
            '/courses/{courseId}/versions/{versionId}/asset', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='file',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_course_version_configuration(self, course_id, version_id, **kwargs):  # noqa: E501
        """Get effective configuration settings for a Course Version   # noqa: E501

        Returns the effective configuration settings for the course version.  If not set at the course level, the setting will inherit a value from a higher level (e.g. application).  If there is a configuration setting present at a more specific level, that setting will override the one set at the course level.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_course_version_configuration(course_id, version_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: (required)
        :param int version_id: (required)
        :param bool include_metadata:
        :return: SettingListSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_course_version_configuration_with_http_info(course_id, version_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_course_version_configuration_with_http_info(course_id, version_id, **kwargs)  # noqa: E501
            return data

    def get_course_version_configuration_with_http_info(self, course_id, version_id, **kwargs):  # noqa: E501
        """Get effective configuration settings for a Course Version   # noqa: E501

        Returns the effective configuration settings for the course version.  If not set at the course level, the setting will inherit a value from a higher level (e.g. application).  If there is a configuration setting present at a more specific level, that setting will override the one set at the course level.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_course_version_configuration_with_http_info(course_id, version_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: (required)
        :param int version_id: (required)
        :param bool include_metadata:
        :return: SettingListSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['course_id', 'version_id', 'include_metadata']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_course_version_configuration" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'course_id' is set
        if ('course_id' not in params or
                params['course_id'] is None):
            raise ValueError("Missing the required parameter `course_id` when calling `get_course_version_configuration`")  # noqa: E501
        # verify the required parameter 'version_id' is set
        if ('version_id' not in params or
                params['version_id'] is None):
            raise ValueError("Missing the required parameter `version_id` when calling `get_course_version_configuration`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'course_id' in params:
            path_params['courseId'] = params['course_id']  # noqa: E501
        if 'version_id' in params:
            path_params['versionId'] = params['version_id']  # noqa: E501

        query_params = []
        if 'include_metadata' in params:
            query_params.append(('includeMetadata', params['include_metadata']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APP_NORMAL', 'OAUTH']  # noqa: E501

        return self.api_client.call_api(
            '/courses/{courseId}/versions/{versionId}/configuration', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SettingListSchema',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_course_version_file_list(self, course_id, version_id, **kwargs):  # noqa: E501
        """Get a list of asset files in a Course Version   # noqa: E501

        Returns a list of asset files in the course version.  Included will be the relative path to use for the other course asset manipulation calls.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_course_version_file_list(course_id, version_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: (required)
        :param int version_id: (required)
        :return: FileListSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_course_version_file_list_with_http_info(course_id, version_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_course_version_file_list_with_http_info(course_id, version_id, **kwargs)  # noqa: E501
            return data

    def get_course_version_file_list_with_http_info(self, course_id, version_id, **kwargs):  # noqa: E501
        """Get a list of asset files in a Course Version   # noqa: E501

        Returns a list of asset files in the course version.  Included will be the relative path to use for the other course asset manipulation calls.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_course_version_file_list_with_http_info(course_id, version_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: (required)
        :param int version_id: (required)
        :return: FileListSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['course_id', 'version_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_course_version_file_list" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'course_id' is set
        if ('course_id' not in params or
                params['course_id'] is None):
            raise ValueError("Missing the required parameter `course_id` when calling `get_course_version_file_list`")  # noqa: E501
        # verify the required parameter 'version_id' is set
        if ('version_id' not in params or
                params['version_id'] is None):
            raise ValueError("Missing the required parameter `version_id` when calling `get_course_version_file_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'course_id' in params:
            path_params['courseId'] = params['course_id']  # noqa: E501
        if 'version_id' in params:
            path_params['versionId'] = params['version_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APP_NORMAL', 'OAUTH']  # noqa: E501

        return self.api_client.call_api(
            '/courses/{courseId}/versions/{versionId}/asset/list', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='FileListSchema',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_course_version_info(self, course_id, version_id, **kwargs):  # noqa: E501
        """Get detailed information about a Course Version   # noqa: E501

        Returns detailed information about the course version.  This includes update date and registration count (if optional value is passed in).   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_course_version_info(course_id, version_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: (required)
        :param int version_id: (required)
        :param bool include_registration_count: Include the registration count in the results
        :param bool include_course_metadata: Include course metadata in the results. If the course has no metadata, adding this parameter has no effect.
        :return: CourseSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_course_version_info_with_http_info(course_id, version_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_course_version_info_with_http_info(course_id, version_id, **kwargs)  # noqa: E501
            return data

    def get_course_version_info_with_http_info(self, course_id, version_id, **kwargs):  # noqa: E501
        """Get detailed information about a Course Version   # noqa: E501

        Returns detailed information about the course version.  This includes update date and registration count (if optional value is passed in).   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_course_version_info_with_http_info(course_id, version_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: (required)
        :param int version_id: (required)
        :param bool include_registration_count: Include the registration count in the results
        :param bool include_course_metadata: Include course metadata in the results. If the course has no metadata, adding this parameter has no effect.
        :return: CourseSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['course_id', 'version_id', 'include_registration_count', 'include_course_metadata']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_course_version_info" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'course_id' is set
        if ('course_id' not in params or
                params['course_id'] is None):
            raise ValueError("Missing the required parameter `course_id` when calling `get_course_version_info`")  # noqa: E501
        # verify the required parameter 'version_id' is set
        if ('version_id' not in params or
                params['version_id'] is None):
            raise ValueError("Missing the required parameter `version_id` when calling `get_course_version_info`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'course_id' in params:
            path_params['courseId'] = params['course_id']  # noqa: E501
        if 'version_id' in params:
            path_params['versionId'] = params['version_id']  # noqa: E501

        query_params = []
        if 'include_registration_count' in params:
            query_params.append(('includeRegistrationCount', params['include_registration_count']))  # noqa: E501
        if 'include_course_metadata' in params:
            query_params.append(('includeCourseMetadata', params['include_course_metadata']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APP_NORMAL', 'OAUTH']  # noqa: E501

        return self.api_client.call_api(
            '/courses/{courseId}/versions/{versionId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CourseSchema',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_course_version_statements(self, course_id, version_id, **kwargs):  # noqa: E501
        """Get xAPI statements for a Course Version   # noqa: E501

        Returns xAPI statements for the course version.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_course_version_statements(course_id, version_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: (required)
        :param int version_id: (required)
        :param str learner_id: Only entries for the specified learner id will be included.
        :param datetime since: Filter by ISO 8601 TimeStamp inclusive (defaults to UTC)
        :param datetime until: Filter by ISO 8601 TimeStamp inclusive (defaults to UTC)
        :param str more: Pagination token returned as `more` property of multi page list requests
        :return: XapiStatementResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_course_version_statements_with_http_info(course_id, version_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_course_version_statements_with_http_info(course_id, version_id, **kwargs)  # noqa: E501
            return data

    def get_course_version_statements_with_http_info(self, course_id, version_id, **kwargs):  # noqa: E501
        """Get xAPI statements for a Course Version   # noqa: E501

        Returns xAPI statements for the course version.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_course_version_statements_with_http_info(course_id, version_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: (required)
        :param int version_id: (required)
        :param str learner_id: Only entries for the specified learner id will be included.
        :param datetime since: Filter by ISO 8601 TimeStamp inclusive (defaults to UTC)
        :param datetime until: Filter by ISO 8601 TimeStamp inclusive (defaults to UTC)
        :param str more: Pagination token returned as `more` property of multi page list requests
        :return: XapiStatementResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['course_id', 'version_id', 'learner_id', 'since', 'until', 'more']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_course_version_statements" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'course_id' is set
        if ('course_id' not in params or
                params['course_id'] is None):
            raise ValueError("Missing the required parameter `course_id` when calling `get_course_version_statements`")  # noqa: E501
        # verify the required parameter 'version_id' is set
        if ('version_id' not in params or
                params['version_id'] is None):
            raise ValueError("Missing the required parameter `version_id` when calling `get_course_version_statements`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'course_id' in params:
            path_params['courseId'] = params['course_id']  # noqa: E501
        if 'version_id' in params:
            path_params['versionId'] = params['version_id']  # noqa: E501

        query_params = []
        if 'learner_id' in params:
            query_params.append(('learnerId', params['learner_id']))  # noqa: E501
        if 'since' in params:
            query_params.append(('since', params['since']))  # noqa: E501
        if 'until' in params:
            query_params.append(('until', params['until']))  # noqa: E501
        if 'more' in params:
            query_params.append(('more', params['more']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APP_NORMAL', 'OAUTH']  # noqa: E501

        return self.api_client.call_api(
            '/courses/{courseId}/versions/{versionId}/xAPIStatements', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='XapiStatementResult',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_course_versions(self, course_id, **kwargs):  # noqa: E501
        """Get a list of a Course's Versions   # noqa: E501

        Returns information about all versions of the course.  This can be useful to see information such as registration counts and modification times across the versions of a course.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_course_versions(course_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: (required)
        :param datetime since: Filter by ISO 8601 TimeStamp inclusive (defaults to UTC)
        :param datetime until: Filter by ISO 8601 TimeStamp inclusive (defaults to UTC)
        :param bool include_registration_count: Include the registration count in the results
        :param bool include_course_metadata: Include course metadata in the results. If the course has no metadata, adding this parameter has no effect.
        :return: CourseListNonPagedSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_course_versions_with_http_info(course_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_course_versions_with_http_info(course_id, **kwargs)  # noqa: E501
            return data

    def get_course_versions_with_http_info(self, course_id, **kwargs):  # noqa: E501
        """Get a list of a Course's Versions   # noqa: E501

        Returns information about all versions of the course.  This can be useful to see information such as registration counts and modification times across the versions of a course.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_course_versions_with_http_info(course_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: (required)
        :param datetime since: Filter by ISO 8601 TimeStamp inclusive (defaults to UTC)
        :param datetime until: Filter by ISO 8601 TimeStamp inclusive (defaults to UTC)
        :param bool include_registration_count: Include the registration count in the results
        :param bool include_course_metadata: Include course metadata in the results. If the course has no metadata, adding this parameter has no effect.
        :return: CourseListNonPagedSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['course_id', 'since', 'until', 'include_registration_count', 'include_course_metadata']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_course_versions" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'course_id' is set
        if ('course_id' not in params or
                params['course_id'] is None):
            raise ValueError("Missing the required parameter `course_id` when calling `get_course_versions`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'course_id' in params:
            path_params['courseId'] = params['course_id']  # noqa: E501

        query_params = []
        if 'since' in params:
            query_params.append(('since', params['since']))  # noqa: E501
        if 'until' in params:
            query_params.append(('until', params['until']))  # noqa: E501
        if 'include_registration_count' in params:
            query_params.append(('includeRegistrationCount', params['include_registration_count']))  # noqa: E501
        if 'include_course_metadata' in params:
            query_params.append(('includeCourseMetadata', params['include_course_metadata']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APP_NORMAL', 'OAUTH']  # noqa: E501

        return self.api_client.call_api(
            '/courses/{courseId}/versions', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CourseListNonPagedSchema',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_courses(self, **kwargs):  # noqa: E501
        """Get a list of Courses   # noqa: E501

        Returns a list of courses.  Can be filtered using the request parameters to provide a subset of results.  >**Note:** >This request is paginated and will only provide a limited amount of resources at a time.  If there are more results to be collected, a `more` token provided with the response which can be passed to get the next page of results.  When passing this token, no other filter parameters can be sent as part of the request.  The resources will continue to respect the filters passed in by the original request.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_courses(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param datetime since: Filter by ISO 8601 TimeStamp inclusive (defaults to UTC)
        :param datetime until: Filter by ISO 8601 TimeStamp inclusive (defaults to UTC)
        :param str datetime_filter: Specifies field that `since` and `until` parameters are applied against
        :param list[str] tags: Filter items matching any tag provided (not all)
        :param str filter: Optional string which filters results by a specified field (described by filterBy).
        :param str filter_by: Optional enum parameter for specifying the field on which to run the filter. 
        :param str order_by: Optional enum parameter for specifying the field and order by which to sort the results. 
        :param str more: Pagination token returned as `more` property of multi page list requests
        :param bool include_course_metadata: Include course metadata in the results. If the course has no metadata, adding this parameter has no effect.
        :param bool include_registration_count: Include the registration count in the results
        :return: CourseListSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_courses_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_courses_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_courses_with_http_info(self, **kwargs):  # noqa: E501
        """Get a list of Courses   # noqa: E501

        Returns a list of courses.  Can be filtered using the request parameters to provide a subset of results.  >**Note:** >This request is paginated and will only provide a limited amount of resources at a time.  If there are more results to be collected, a `more` token provided with the response which can be passed to get the next page of results.  When passing this token, no other filter parameters can be sent as part of the request.  The resources will continue to respect the filters passed in by the original request.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_courses_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param datetime since: Filter by ISO 8601 TimeStamp inclusive (defaults to UTC)
        :param datetime until: Filter by ISO 8601 TimeStamp inclusive (defaults to UTC)
        :param str datetime_filter: Specifies field that `since` and `until` parameters are applied against
        :param list[str] tags: Filter items matching any tag provided (not all)
        :param str filter: Optional string which filters results by a specified field (described by filterBy).
        :param str filter_by: Optional enum parameter for specifying the field on which to run the filter. 
        :param str order_by: Optional enum parameter for specifying the field and order by which to sort the results. 
        :param str more: Pagination token returned as `more` property of multi page list requests
        :param bool include_course_metadata: Include course metadata in the results. If the course has no metadata, adding this parameter has no effect.
        :param bool include_registration_count: Include the registration count in the results
        :return: CourseListSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['since', 'until', 'datetime_filter', 'tags', 'filter', 'filter_by', 'order_by', 'more', 'include_course_metadata', 'include_registration_count']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_courses" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'since' in params:
            query_params.append(('since', params['since']))  # noqa: E501
        if 'until' in params:
            query_params.append(('until', params['until']))  # noqa: E501
        if 'datetime_filter' in params:
            query_params.append(('datetimeFilter', params['datetime_filter']))  # noqa: E501
        if 'tags' in params:
            query_params.append(('tags', params['tags']))  # noqa: E501
            collection_formats['tags'] = 'csv'  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501
        if 'filter_by' in params:
            query_params.append(('filterBy', params['filter_by']))  # noqa: E501
        if 'order_by' in params:
            query_params.append(('orderBy', params['order_by']))  # noqa: E501
        if 'more' in params:
            query_params.append(('more', params['more']))  # noqa: E501
        if 'include_course_metadata' in params:
            query_params.append(('includeCourseMetadata', params['include_course_metadata']))  # noqa: E501
        if 'include_registration_count' in params:
            query_params.append(('includeRegistrationCount', params['include_registration_count']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APP_NORMAL', 'OAUTH']  # noqa: E501

        return self.api_client.call_api(
            '/courses', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CourseListSchema',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_import_job_status(self, import_job_id, **kwargs):  # noqa: E501
        """Get import job status for a Course   # noqa: E501

        Check the status of a course import.  This can be called incrementally to check the progress of a call to any of the import options.  >**Note:** >The import job ID used for calls to GetImportJobStatus are only valid for one week after the course import finishes.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_import_job_status(import_job_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str import_job_id: Id received when the import job was submitted to the importJobs resource. (required)
        :return: ImportJobResultSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_import_job_status_with_http_info(import_job_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_import_job_status_with_http_info(import_job_id, **kwargs)  # noqa: E501
            return data

    def get_import_job_status_with_http_info(self, import_job_id, **kwargs):  # noqa: E501
        """Get import job status for a Course   # noqa: E501

        Check the status of a course import.  This can be called incrementally to check the progress of a call to any of the import options.  >**Note:** >The import job ID used for calls to GetImportJobStatus are only valid for one week after the course import finishes.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_import_job_status_with_http_info(import_job_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str import_job_id: Id received when the import job was submitted to the importJobs resource. (required)
        :return: ImportJobResultSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['import_job_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_import_job_status" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'import_job_id' is set
        if ('import_job_id' not in params or
                params['import_job_id'] is None):
            raise ValueError("Missing the required parameter `import_job_id` when calling `get_import_job_status`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'import_job_id' in params:
            path_params['importJobId'] = params['import_job_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APP_NORMAL', 'OAUTH']  # noqa: E501

        return self.api_client.call_api(
            '/courses/importJobs/{importJobId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ImportJobResultSchema',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def import_course_asset_file(self, course_id, asset_schema, **kwargs):  # noqa: E501
        """Import an asset file for a Course   # noqa: E501

        Creates or updates an asset file fetched from the provided url into the course.  The file will be downloaded from the url and stored in SCORM Cloud.  This is a useful way to modify the course structure without needing to reimport the whole course after you've made changes.  >**Info:** >If the course structure is being heavily modified, consider creating a new version instead.  This can be done by calling one of the course import jobs while passing true for `mayCreateNewVersion`.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.import_course_asset_file(course_id, asset_schema, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: (required)
        :param ImportAssetRequestSchema asset_schema: (required)
        :param str update_asset_policy: Describes how SCORM Cloud should handle importing asset files with respect to overwriting files. Valid values are 'reject', 'strict', and 'lax'. A 'reject' policy request will fail if the asset file already exists on the system ('overwriting' not allowed). A 'strict' policy request will fail if the asset file does not already exist ('overwriting' is required). A 'lax' policy request will not consider whether the file already exists (i.e., it will attempt to import in all cases). 
        :return: AssetFileSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.import_course_asset_file_with_http_info(course_id, asset_schema, **kwargs)  # noqa: E501
        else:
            (data) = self.import_course_asset_file_with_http_info(course_id, asset_schema, **kwargs)  # noqa: E501
            return data

    def import_course_asset_file_with_http_info(self, course_id, asset_schema, **kwargs):  # noqa: E501
        """Import an asset file for a Course   # noqa: E501

        Creates or updates an asset file fetched from the provided url into the course.  The file will be downloaded from the url and stored in SCORM Cloud.  This is a useful way to modify the course structure without needing to reimport the whole course after you've made changes.  >**Info:** >If the course structure is being heavily modified, consider creating a new version instead.  This can be done by calling one of the course import jobs while passing true for `mayCreateNewVersion`.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.import_course_asset_file_with_http_info(course_id, asset_schema, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: (required)
        :param ImportAssetRequestSchema asset_schema: (required)
        :param str update_asset_policy: Describes how SCORM Cloud should handle importing asset files with respect to overwriting files. Valid values are 'reject', 'strict', and 'lax'. A 'reject' policy request will fail if the asset file already exists on the system ('overwriting' not allowed). A 'strict' policy request will fail if the asset file does not already exist ('overwriting' is required). A 'lax' policy request will not consider whether the file already exists (i.e., it will attempt to import in all cases). 
        :return: AssetFileSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['course_id', 'asset_schema', 'update_asset_policy']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method import_course_asset_file" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'course_id' is set
        if ('course_id' not in params or
                params['course_id'] is None):
            raise ValueError("Missing the required parameter `course_id` when calling `import_course_asset_file`")  # noqa: E501
        # verify the required parameter 'asset_schema' is set
        if ('asset_schema' not in params or
                params['asset_schema'] is None):
            raise ValueError("Missing the required parameter `asset_schema` when calling `import_course_asset_file`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'course_id' in params:
            path_params['courseId'] = params['course_id']  # noqa: E501

        query_params = []
        if 'update_asset_policy' in params:
            query_params.append(('updateAssetPolicy', params['update_asset_policy']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'asset_schema' in params:
            body_params = params['asset_schema']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APP_NORMAL', 'OAUTH']  # noqa: E501

        return self.api_client.call_api(
            '/courses/{courseId}/asset', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AssetFileSchema',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def import_course_version_asset_file(self, course_id, version_id, asset_schema, **kwargs):  # noqa: E501
        """Import an asset file for a Course Version   # noqa: E501

        Creates or updates an asset file fetched from the provided url into the course version.  The file will be downloaded from the url and stored in SCORM Cloud.  This is a useful way to modify the course structure without needing to reimport the whole course after you've made changes.  >**Info:** >If the course structure is being heavily modified, consider creating a new version instead.  This can be done by calling one of the course import jobs while passing true for `mayCreateNewVersion`.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.import_course_version_asset_file(course_id, version_id, asset_schema, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: (required)
        :param int version_id: (required)
        :param ImportAssetRequestSchema asset_schema: (required)
        :param str update_asset_policy: Describes how SCORM Cloud should handle importing asset files with respect to overwriting files. Valid values are 'reject', 'strict', and 'lax'. A 'reject' policy request will fail if the asset file already exists on the system ('overwriting' not allowed). A 'strict' policy request will fail if the asset file does not already exist ('overwriting' is required). A 'lax' policy request will not consider whether the file already exists (i.e., it will attempt to import in all cases). 
        :return: AssetFileSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.import_course_version_asset_file_with_http_info(course_id, version_id, asset_schema, **kwargs)  # noqa: E501
        else:
            (data) = self.import_course_version_asset_file_with_http_info(course_id, version_id, asset_schema, **kwargs)  # noqa: E501
            return data

    def import_course_version_asset_file_with_http_info(self, course_id, version_id, asset_schema, **kwargs):  # noqa: E501
        """Import an asset file for a Course Version   # noqa: E501

        Creates or updates an asset file fetched from the provided url into the course version.  The file will be downloaded from the url and stored in SCORM Cloud.  This is a useful way to modify the course structure without needing to reimport the whole course after you've made changes.  >**Info:** >If the course structure is being heavily modified, consider creating a new version instead.  This can be done by calling one of the course import jobs while passing true for `mayCreateNewVersion`.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.import_course_version_asset_file_with_http_info(course_id, version_id, asset_schema, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: (required)
        :param int version_id: (required)
        :param ImportAssetRequestSchema asset_schema: (required)
        :param str update_asset_policy: Describes how SCORM Cloud should handle importing asset files with respect to overwriting files. Valid values are 'reject', 'strict', and 'lax'. A 'reject' policy request will fail if the asset file already exists on the system ('overwriting' not allowed). A 'strict' policy request will fail if the asset file does not already exist ('overwriting' is required). A 'lax' policy request will not consider whether the file already exists (i.e., it will attempt to import in all cases). 
        :return: AssetFileSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['course_id', 'version_id', 'asset_schema', 'update_asset_policy']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method import_course_version_asset_file" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'course_id' is set
        if ('course_id' not in params or
                params['course_id'] is None):
            raise ValueError("Missing the required parameter `course_id` when calling `import_course_version_asset_file`")  # noqa: E501
        # verify the required parameter 'version_id' is set
        if ('version_id' not in params or
                params['version_id'] is None):
            raise ValueError("Missing the required parameter `version_id` when calling `import_course_version_asset_file`")  # noqa: E501
        # verify the required parameter 'asset_schema' is set
        if ('asset_schema' not in params or
                params['asset_schema'] is None):
            raise ValueError("Missing the required parameter `asset_schema` when calling `import_course_version_asset_file`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'course_id' in params:
            path_params['courseId'] = params['course_id']  # noqa: E501
        if 'version_id' in params:
            path_params['versionId'] = params['version_id']  # noqa: E501

        query_params = []
        if 'update_asset_policy' in params:
            query_params.append(('updateAssetPolicy', params['update_asset_policy']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'asset_schema' in params:
            body_params = params['asset_schema']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APP_NORMAL', 'OAUTH']  # noqa: E501

        return self.api_client.call_api(
            '/courses/{courseId}/versions/{versionId}/asset', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AssetFileSchema',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def put_course_tags(self, course_id, tags, **kwargs):  # noqa: E501
        """Add tags to a Course   # noqa: E501

        Applies the provided tags to the course.  Tags are used to easily identify resources.  Adding tags can enable more refined searches when making calls to certain endpoints (e.g. GetCourses).   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_course_tags(course_id, tags, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: (required)
        :param TagListSchema tags: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.put_course_tags_with_http_info(course_id, tags, **kwargs)  # noqa: E501
        else:
            (data) = self.put_course_tags_with_http_info(course_id, tags, **kwargs)  # noqa: E501
            return data

    def put_course_tags_with_http_info(self, course_id, tags, **kwargs):  # noqa: E501
        """Add tags to a Course   # noqa: E501

        Applies the provided tags to the course.  Tags are used to easily identify resources.  Adding tags can enable more refined searches when making calls to certain endpoints (e.g. GetCourses).   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_course_tags_with_http_info(course_id, tags, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: (required)
        :param TagListSchema tags: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['course_id', 'tags']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_course_tags" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'course_id' is set
        if ('course_id' not in params or
                params['course_id'] is None):
            raise ValueError("Missing the required parameter `course_id` when calling `put_course_tags`")  # noqa: E501
        # verify the required parameter 'tags' is set
        if ('tags' not in params or
                params['tags'] is None):
            raise ValueError("Missing the required parameter `tags` when calling `put_course_tags`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'course_id' in params:
            path_params['courseId'] = params['course_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'tags' in params:
            body_params = params['tags']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APP_NORMAL', 'OAUTH']  # noqa: E501

        return self.api_client.call_api(
            '/courses/{courseId}/tags', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def put_course_tags_batch(self, batch, **kwargs):  # noqa: E501
        """Add a group of tags to a group of Courses   # noqa: E501

        Applies all of the provided tags on all of the provided courses.  Tags are used to easily identify resources. Adding tags can enable more refined searches when making calls to certain endpoints (e.g. GetCourses).   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_course_tags_batch(batch, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param BatchTagsSchema batch: Array of ids, and array of tags for bulk tag operations (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.put_course_tags_batch_with_http_info(batch, **kwargs)  # noqa: E501
        else:
            (data) = self.put_course_tags_batch_with_http_info(batch, **kwargs)  # noqa: E501
            return data

    def put_course_tags_batch_with_http_info(self, batch, **kwargs):  # noqa: E501
        """Add a group of tags to a group of Courses   # noqa: E501

        Applies all of the provided tags on all of the provided courses.  Tags are used to easily identify resources. Adding tags can enable more refined searches when making calls to certain endpoints (e.g. GetCourses).   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_course_tags_batch_with_http_info(batch, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param BatchTagsSchema batch: Array of ids, and array of tags for bulk tag operations (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['batch']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_course_tags_batch" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'batch' is set
        if ('batch' not in params or
                params['batch'] is None):
            raise ValueError("Missing the required parameter `batch` when calling `put_course_tags_batch`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'batch' in params:
            body_params = params['batch']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APP_NORMAL', 'OAUTH']  # noqa: E501

        return self.api_client.call_api(
            '/courses/tags', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def set_course_configuration(self, course_id, configuration_settings, **kwargs):  # noqa: E501
        """Update configuration settings for a Course   # noqa: E501

        Updates configuration settings at the course level.  This will explicitly set a value at the course level and override any settings from a higher level.  These settings will affect all items within the course which do not have their own explicit configuration set.  This can effectively be used to set course level defaults.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_course_configuration(course_id, configuration_settings, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: (required)
        :param SettingsPostSchema configuration_settings: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.set_course_configuration_with_http_info(course_id, configuration_settings, **kwargs)  # noqa: E501
        else:
            (data) = self.set_course_configuration_with_http_info(course_id, configuration_settings, **kwargs)  # noqa: E501
            return data

    def set_course_configuration_with_http_info(self, course_id, configuration_settings, **kwargs):  # noqa: E501
        """Update configuration settings for a Course   # noqa: E501

        Updates configuration settings at the course level.  This will explicitly set a value at the course level and override any settings from a higher level.  These settings will affect all items within the course which do not have their own explicit configuration set.  This can effectively be used to set course level defaults.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_course_configuration_with_http_info(course_id, configuration_settings, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: (required)
        :param SettingsPostSchema configuration_settings: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['course_id', 'configuration_settings']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method set_course_configuration" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'course_id' is set
        if ('course_id' not in params or
                params['course_id'] is None):
            raise ValueError("Missing the required parameter `course_id` when calling `set_course_configuration`")  # noqa: E501
        # verify the required parameter 'configuration_settings' is set
        if ('configuration_settings' not in params or
                params['configuration_settings'] is None):
            raise ValueError("Missing the required parameter `configuration_settings` when calling `set_course_configuration`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'course_id' in params:
            path_params['courseId'] = params['course_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'configuration_settings' in params:
            body_params = params['configuration_settings']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APP_NORMAL', 'OAUTH']  # noqa: E501

        return self.api_client.call_api(
            '/courses/{courseId}/configuration', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def set_course_title(self, course_id, title, **kwargs):  # noqa: E501
        """Update title for a Course   # noqa: E501

        Updates the title of the course.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_course_title(course_id, title, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: (required)
        :param TitleSchema title: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.set_course_title_with_http_info(course_id, title, **kwargs)  # noqa: E501
        else:
            (data) = self.set_course_title_with_http_info(course_id, title, **kwargs)  # noqa: E501
            return data

    def set_course_title_with_http_info(self, course_id, title, **kwargs):  # noqa: E501
        """Update title for a Course   # noqa: E501

        Updates the title of the course.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_course_title_with_http_info(course_id, title, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: (required)
        :param TitleSchema title: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['course_id', 'title']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method set_course_title" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'course_id' is set
        if ('course_id' not in params or
                params['course_id'] is None):
            raise ValueError("Missing the required parameter `course_id` when calling `set_course_title`")  # noqa: E501
        # verify the required parameter 'title' is set
        if ('title' not in params or
                params['title'] is None):
            raise ValueError("Missing the required parameter `title` when calling `set_course_title`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'course_id' in params:
            path_params['courseId'] = params['course_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'title' in params:
            body_params = params['title']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APP_NORMAL', 'OAUTH']  # noqa: E501

        return self.api_client.call_api(
            '/courses/{courseId}/title', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def set_course_version_configuration(self, course_id, version_id, configuration_settings, **kwargs):  # noqa: E501
        """Update configuration settings for a Course Version   # noqa: E501

        Updates configuration settings at the course level.  This will explicitly set a value at the course level and override any settings from a higher level.  These settings will affect all items within the course which do not have their own explicit configuration set.  This can effectively be used to set course level defaults.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_course_version_configuration(course_id, version_id, configuration_settings, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: (required)
        :param int version_id: (required)
        :param SettingsPostSchema configuration_settings: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.set_course_version_configuration_with_http_info(course_id, version_id, configuration_settings, **kwargs)  # noqa: E501
        else:
            (data) = self.set_course_version_configuration_with_http_info(course_id, version_id, configuration_settings, **kwargs)  # noqa: E501
            return data

    def set_course_version_configuration_with_http_info(self, course_id, version_id, configuration_settings, **kwargs):  # noqa: E501
        """Update configuration settings for a Course Version   # noqa: E501

        Updates configuration settings at the course level.  This will explicitly set a value at the course level and override any settings from a higher level.  These settings will affect all items within the course which do not have their own explicit configuration set.  This can effectively be used to set course level defaults.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_course_version_configuration_with_http_info(course_id, version_id, configuration_settings, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: (required)
        :param int version_id: (required)
        :param SettingsPostSchema configuration_settings: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['course_id', 'version_id', 'configuration_settings']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method set_course_version_configuration" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'course_id' is set
        if ('course_id' not in params or
                params['course_id'] is None):
            raise ValueError("Missing the required parameter `course_id` when calling `set_course_version_configuration`")  # noqa: E501
        # verify the required parameter 'version_id' is set
        if ('version_id' not in params or
                params['version_id'] is None):
            raise ValueError("Missing the required parameter `version_id` when calling `set_course_version_configuration`")  # noqa: E501
        # verify the required parameter 'configuration_settings' is set
        if ('configuration_settings' not in params or
                params['configuration_settings'] is None):
            raise ValueError("Missing the required parameter `configuration_settings` when calling `set_course_version_configuration`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'course_id' in params:
            path_params['courseId'] = params['course_id']  # noqa: E501
        if 'version_id' in params:
            path_params['versionId'] = params['version_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'configuration_settings' in params:
            body_params = params['configuration_settings']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APP_NORMAL', 'OAUTH']  # noqa: E501

        return self.api_client.call_api(
            '/courses/{courseId}/versions/{versionId}/configuration', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def upload_course_asset_file(self, course_id, destination, **kwargs):  # noqa: E501
        """Upload an asset file for a Course   # noqa: E501

        Creates or updates an asset file uploaded from your file system into the course.  The file will be sent as part of the request and will be stored in SCORM Cloud alongside the course.  This is a useful way to modify the course structure without needing to reimport the whole course after you've made changes.  >**Info:** >If the course structure is being heavily modified, consider creating a new version instead.  This can be done by calling one of the course import jobs while passing true for `mayCreateNewVersion`.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.upload_course_asset_file(course_id, destination, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: (required)
        :param str destination: Relative path from the course's base directory where the asset file will be uploaded. `/Etiquette/Course.html` will upload the file into the Etiquette folder of the course.  (required)
        :param file file: The asset file to import into the course. 
        :param str update_asset_policy: Describes how SCORM Cloud should handle importing asset files with respect to overwriting files. Valid values are 'reject', 'strict', and 'lax'. A 'reject' policy request will fail if the asset file already exists on the system ('overwriting' not allowed). A 'strict' policy request will fail if the asset file does not already exist ('overwriting' is required). A 'lax' policy request will not consider whether the file already exists (i.e., it will attempt to import in all cases). 
        :return: AssetFileSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.upload_course_asset_file_with_http_info(course_id, destination, **kwargs)  # noqa: E501
        else:
            (data) = self.upload_course_asset_file_with_http_info(course_id, destination, **kwargs)  # noqa: E501
            return data

    def upload_course_asset_file_with_http_info(self, course_id, destination, **kwargs):  # noqa: E501
        """Upload an asset file for a Course   # noqa: E501

        Creates or updates an asset file uploaded from your file system into the course.  The file will be sent as part of the request and will be stored in SCORM Cloud alongside the course.  This is a useful way to modify the course structure without needing to reimport the whole course after you've made changes.  >**Info:** >If the course structure is being heavily modified, consider creating a new version instead.  This can be done by calling one of the course import jobs while passing true for `mayCreateNewVersion`.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.upload_course_asset_file_with_http_info(course_id, destination, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: (required)
        :param str destination: Relative path from the course's base directory where the asset file will be uploaded. `/Etiquette/Course.html` will upload the file into the Etiquette folder of the course.  (required)
        :param file file: The asset file to import into the course. 
        :param str update_asset_policy: Describes how SCORM Cloud should handle importing asset files with respect to overwriting files. Valid values are 'reject', 'strict', and 'lax'. A 'reject' policy request will fail if the asset file already exists on the system ('overwriting' not allowed). A 'strict' policy request will fail if the asset file does not already exist ('overwriting' is required). A 'lax' policy request will not consider whether the file already exists (i.e., it will attempt to import in all cases). 
        :return: AssetFileSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['course_id', 'destination', 'file', 'update_asset_policy']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method upload_course_asset_file" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'course_id' is set
        if ('course_id' not in params or
                params['course_id'] is None):
            raise ValueError("Missing the required parameter `course_id` when calling `upload_course_asset_file`")  # noqa: E501
        # verify the required parameter 'destination' is set
        if ('destination' not in params or
                params['destination'] is None):
            raise ValueError("Missing the required parameter `destination` when calling `upload_course_asset_file`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'course_id' in params:
            path_params['courseId'] = params['course_id']  # noqa: E501

        query_params = []
        if 'update_asset_policy' in params:
            query_params.append(('updateAssetPolicy', params['update_asset_policy']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'file' in params:
            local_var_files['file'] = params['file']  # noqa: E501
        if 'destination' in params:
            form_params.append(('destination', params['destination']))  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APP_NORMAL', 'OAUTH']  # noqa: E501

        return self.api_client.call_api(
            '/courses/{courseId}/asset/upload', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AssetFileSchema',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def upload_course_version_asset_file(self, course_id, version_id, destination, **kwargs):  # noqa: E501
        """Upload an asset file for Course Version   # noqa: E501

        Creates or updates an asset file uploaded from your file system into the course version.  The file will be sent as part of the request and will be stored in SCORM Cloud alongside the course.  This is a useful way to modify the course structure without needing to reimport the whole course after you've made changes.  >**Info:** >If the course structure is being heavily modified, consider creating a new version instead.  This can be done by calling one of the course import jobs while passing true for `mayCreateNewVersion`.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.upload_course_version_asset_file(course_id, version_id, destination, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: (required)
        :param int version_id: (required)
        :param str destination: Relative path from the course's base directory where the asset file will be uploaded. `/Etiquette/Course.html` will upload the file into the Etiquette folder of the course.  (required)
        :param file file: The asset file to import into the course. 
        :param str update_asset_policy: Describes how SCORM Cloud should handle importing asset files with respect to overwriting files. Valid values are 'reject', 'strict', and 'lax'. A 'reject' policy request will fail if the asset file already exists on the system ('overwriting' not allowed). A 'strict' policy request will fail if the asset file does not already exist ('overwriting' is required). A 'lax' policy request will not consider whether the file already exists (i.e., it will attempt to import in all cases). 
        :return: AssetFileSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.upload_course_version_asset_file_with_http_info(course_id, version_id, destination, **kwargs)  # noqa: E501
        else:
            (data) = self.upload_course_version_asset_file_with_http_info(course_id, version_id, destination, **kwargs)  # noqa: E501
            return data

    def upload_course_version_asset_file_with_http_info(self, course_id, version_id, destination, **kwargs):  # noqa: E501
        """Upload an asset file for Course Version   # noqa: E501

        Creates or updates an asset file uploaded from your file system into the course version.  The file will be sent as part of the request and will be stored in SCORM Cloud alongside the course.  This is a useful way to modify the course structure without needing to reimport the whole course after you've made changes.  >**Info:** >If the course structure is being heavily modified, consider creating a new version instead.  This can be done by calling one of the course import jobs while passing true for `mayCreateNewVersion`.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.upload_course_version_asset_file_with_http_info(course_id, version_id, destination, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: (required)
        :param int version_id: (required)
        :param str destination: Relative path from the course's base directory where the asset file will be uploaded. `/Etiquette/Course.html` will upload the file into the Etiquette folder of the course.  (required)
        :param file file: The asset file to import into the course. 
        :param str update_asset_policy: Describes how SCORM Cloud should handle importing asset files with respect to overwriting files. Valid values are 'reject', 'strict', and 'lax'. A 'reject' policy request will fail if the asset file already exists on the system ('overwriting' not allowed). A 'strict' policy request will fail if the asset file does not already exist ('overwriting' is required). A 'lax' policy request will not consider whether the file already exists (i.e., it will attempt to import in all cases). 
        :return: AssetFileSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['course_id', 'version_id', 'destination', 'file', 'update_asset_policy']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method upload_course_version_asset_file" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'course_id' is set
        if ('course_id' not in params or
                params['course_id'] is None):
            raise ValueError("Missing the required parameter `course_id` when calling `upload_course_version_asset_file`")  # noqa: E501
        # verify the required parameter 'version_id' is set
        if ('version_id' not in params or
                params['version_id'] is None):
            raise ValueError("Missing the required parameter `version_id` when calling `upload_course_version_asset_file`")  # noqa: E501
        # verify the required parameter 'destination' is set
        if ('destination' not in params or
                params['destination'] is None):
            raise ValueError("Missing the required parameter `destination` when calling `upload_course_version_asset_file`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'course_id' in params:
            path_params['courseId'] = params['course_id']  # noqa: E501
        if 'version_id' in params:
            path_params['versionId'] = params['version_id']  # noqa: E501

        query_params = []
        if 'update_asset_policy' in params:
            query_params.append(('updateAssetPolicy', params['update_asset_policy']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'file' in params:
            local_var_files['file'] = params['file']  # noqa: E501
        if 'destination' in params:
            form_params.append(('destination', params['destination']))  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APP_NORMAL', 'OAUTH']  # noqa: E501

        return self.api_client.call_api(
            '/courses/{courseId}/versions/{versionId}/asset/upload', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AssetFileSchema',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
