# coding: utf-8

"""
    SCORM Cloud Rest API

    REST API used for SCORM Cloud integrations.  # noqa: E501

    OpenAPI spec version: 2.0
    Contact: systems@rusticisoftware.com
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from rustici_software_cloud_v2.api_client import ApiClient


class DispatchApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def create_destinations(self, destinations_list, **kwargs):  # noqa: E501
        """DestinationsByTenant  # noqa: E501

        Create multiple destinations.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_destinations(destinations_list, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param DestinationListSchema destinations_list:  (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_destinations_with_http_info(destinations_list, **kwargs)  # noqa: E501
        else:
            (data) = self.create_destinations_with_http_info(destinations_list, **kwargs)  # noqa: E501
            return data

    def create_destinations_with_http_info(self, destinations_list, **kwargs):  # noqa: E501
        """DestinationsByTenant  # noqa: E501

        Create multiple destinations.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_destinations_with_http_info(destinations_list, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param DestinationListSchema destinations_list:  (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['destinations_list']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_destinations" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'destinations_list' is set
        if ('destinations_list' not in params or
                params['destinations_list'] is None):
            raise ValueError("Missing the required parameter `destinations_list` when calling `create_destinations`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'destinations_list' in params:
            body_params = params['destinations_list']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APP_NORMAL', 'OAUTH']  # noqa: E501

        return self.api_client.call_api(
            '/dispatch/destinations', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_dispatches(self, dispatch_list, **kwargs):  # noqa: E501
        """Create dispatches.  # noqa: E501

        Create multiple dispatches at once.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_dispatches(dispatch_list, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param CreateDispatchListSchema dispatch_list: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_dispatches_with_http_info(dispatch_list, **kwargs)  # noqa: E501
        else:
            (data) = self.create_dispatches_with_http_info(dispatch_list, **kwargs)  # noqa: E501
            return data

    def create_dispatches_with_http_info(self, dispatch_list, **kwargs):  # noqa: E501
        """Create dispatches.  # noqa: E501

        Create multiple dispatches at once.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_dispatches_with_http_info(dispatch_list, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param CreateDispatchListSchema dispatch_list: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['dispatch_list']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_dispatches" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'dispatch_list' is set
        if ('dispatch_list' not in params or
                params['dispatch_list'] is None):
            raise ValueError("Missing the required parameter `dispatch_list` when calling `create_dispatches`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'dispatch_list' in params:
            body_params = params['dispatch_list']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APP_NORMAL', 'OAUTH']  # noqa: E501

        return self.api_client.call_api(
            '/dispatch/dispatches', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_destination(self, destination_id, **kwargs):  # noqa: E501
        """Delete destination   # noqa: E501

        Delete the destination with `destinationId`   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_destination(destination_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str destination_id: Identifier for the destination (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_destination_with_http_info(destination_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_destination_with_http_info(destination_id, **kwargs)  # noqa: E501
            return data

    def delete_destination_with_http_info(self, destination_id, **kwargs):  # noqa: E501
        """Delete destination   # noqa: E501

        Delete the destination with `destinationId`   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_destination_with_http_info(destination_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str destination_id: Identifier for the destination (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['destination_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_destination" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'destination_id' is set
        if ('destination_id' not in params or
                params['destination_id'] is None):
            raise ValueError("Missing the required parameter `destination_id` when calling `delete_destination`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'destination_id' in params:
            path_params['destinationId'] = params['destination_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APP_NORMAL', 'OAUTH']  # noqa: E501

        return self.api_client.call_api(
            '/dispatch/destinations/{destinationId}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_destination_dispatches(self, destination_id, **kwargs):  # noqa: E501
        """Delete dispatches in destination   # noqa: E501

        Delete the dispatches in a destination   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_destination_dispatches(destination_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str destination_id: Identifier for the destination (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_destination_dispatches_with_http_info(destination_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_destination_dispatches_with_http_info(destination_id, **kwargs)  # noqa: E501
            return data

    def delete_destination_dispatches_with_http_info(self, destination_id, **kwargs):  # noqa: E501
        """Delete dispatches in destination   # noqa: E501

        Delete the dispatches in a destination   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_destination_dispatches_with_http_info(destination_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str destination_id: Identifier for the destination (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['destination_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_destination_dispatches" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'destination_id' is set
        if ('destination_id' not in params or
                params['destination_id'] is None):
            raise ValueError("Missing the required parameter `destination_id` when calling `delete_destination_dispatches`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'destination_id' in params:
            path_params['destinationId'] = params['destination_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APP_NORMAL', 'OAUTH']  # noqa: E501

        return self.api_client.call_api(
            '/dispatch/destinations/{destinationId}/dispatches', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_destination_tags(self, destination_id, tags, **kwargs):  # noqa: E501
        """Delete the tags for this destination   # noqa: E501

        Delete the tags for this destination   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_destination_tags(destination_id, tags, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str destination_id: Identifier for the destination (required)
        :param TagListSchema tags: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_destination_tags_with_http_info(destination_id, tags, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_destination_tags_with_http_info(destination_id, tags, **kwargs)  # noqa: E501
            return data

    def delete_destination_tags_with_http_info(self, destination_id, tags, **kwargs):  # noqa: E501
        """Delete the tags for this destination   # noqa: E501

        Delete the tags for this destination   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_destination_tags_with_http_info(destination_id, tags, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str destination_id: Identifier for the destination (required)
        :param TagListSchema tags: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['destination_id', 'tags']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_destination_tags" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'destination_id' is set
        if ('destination_id' not in params or
                params['destination_id'] is None):
            raise ValueError("Missing the required parameter `destination_id` when calling `delete_destination_tags`")  # noqa: E501
        # verify the required parameter 'tags' is set
        if ('tags' not in params or
                params['tags'] is None):
            raise ValueError("Missing the required parameter `tags` when calling `delete_destination_tags`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'destination_id' in params:
            path_params['destinationId'] = params['destination_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'tags' in params:
            body_params = params['tags']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APP_NORMAL', 'OAUTH']  # noqa: E501

        return self.api_client.call_api(
            '/dispatch/destinations/{destinationId}/tags', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_dispatch(self, dispatch_id, **kwargs):  # noqa: E501
        """Delete the dispatch with `dispatchId`.   # noqa: E501

        Delete the dispatch with `dispatchId`.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_dispatch(dispatch_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str dispatch_id: Identifier for the dispatch (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_dispatch_with_http_info(dispatch_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_dispatch_with_http_info(dispatch_id, **kwargs)  # noqa: E501
            return data

    def delete_dispatch_with_http_info(self, dispatch_id, **kwargs):  # noqa: E501
        """Delete the dispatch with `dispatchId`.   # noqa: E501

        Delete the dispatch with `dispatchId`.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_dispatch_with_http_info(dispatch_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str dispatch_id: Identifier for the dispatch (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['dispatch_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_dispatch" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'dispatch_id' is set
        if ('dispatch_id' not in params or
                params['dispatch_id'] is None):
            raise ValueError("Missing the required parameter `dispatch_id` when calling `delete_dispatch`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'dispatch_id' in params:
            path_params['dispatchId'] = params['dispatch_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APP_NORMAL', 'OAUTH']  # noqa: E501

        return self.api_client.call_api(
            '/dispatch/dispatches/{dispatchId}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_dispatch_postback_info(self, dispatch_id, **kwargs):  # noqa: E501
        """DispatchesByTenantAndDispatchId  # noqa: E501

        Delete the postback info dispatch with 'dispatchId'.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_dispatch_postback_info(dispatch_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str dispatch_id: Identifier for the dispatch (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_dispatch_postback_info_with_http_info(dispatch_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_dispatch_postback_info_with_http_info(dispatch_id, **kwargs)  # noqa: E501
            return data

    def delete_dispatch_postback_info_with_http_info(self, dispatch_id, **kwargs):  # noqa: E501
        """DispatchesByTenantAndDispatchId  # noqa: E501

        Delete the postback info dispatch with 'dispatchId'.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_dispatch_postback_info_with_http_info(dispatch_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str dispatch_id: Identifier for the dispatch (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['dispatch_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_dispatch_postback_info" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'dispatch_id' is set
        if ('dispatch_id' not in params or
                params['dispatch_id'] is None):
            raise ValueError("Missing the required parameter `dispatch_id` when calling `delete_dispatch_postback_info`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'dispatch_id' in params:
            path_params['dispatchId'] = params['dispatch_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APP_NORMAL', 'OAUTH']  # noqa: E501

        return self.api_client.call_api(
            '/dispatch/dispatches/{dispatchId}/postback', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_dispatch_tags(self, dispatch_id, tags, **kwargs):  # noqa: E501
        """Delete the tags for this dispatch.   # noqa: E501

        Delete the tags for this dispatch.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_dispatch_tags(dispatch_id, tags, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str dispatch_id: Identifier for the dispatch (required)
        :param TagListSchema tags: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_dispatch_tags_with_http_info(dispatch_id, tags, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_dispatch_tags_with_http_info(dispatch_id, tags, **kwargs)  # noqa: E501
            return data

    def delete_dispatch_tags_with_http_info(self, dispatch_id, tags, **kwargs):  # noqa: E501
        """Delete the tags for this dispatch.   # noqa: E501

        Delete the tags for this dispatch.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_dispatch_tags_with_http_info(dispatch_id, tags, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str dispatch_id: Identifier for the dispatch (required)
        :param TagListSchema tags: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['dispatch_id', 'tags']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_dispatch_tags" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'dispatch_id' is set
        if ('dispatch_id' not in params or
                params['dispatch_id'] is None):
            raise ValueError("Missing the required parameter `dispatch_id` when calling `delete_dispatch_tags`")  # noqa: E501
        # verify the required parameter 'tags' is set
        if ('tags' not in params or
                params['tags'] is None):
            raise ValueError("Missing the required parameter `tags` when calling `delete_dispatch_tags`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'dispatch_id' in params:
            path_params['dispatchId'] = params['dispatch_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'tags' in params:
            body_params = params['tags']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APP_NORMAL', 'OAUTH']  # noqa: E501

        return self.api_client.call_api(
            '/dispatch/dispatches/{dispatchId}/tags', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def enable_registration_instancing(self, destination_id, enabled, **kwargs):  # noqa: E501
        """DestinationsDispatchesRegistrationInstancing  # noqa: E501

        Enable or disable registration instancing.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.enable_registration_instancing(destination_id, enabled, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str destination_id: Identifier for the destination (required)
        :param EnabledSchema enabled:  (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.enable_registration_instancing_with_http_info(destination_id, enabled, **kwargs)  # noqa: E501
        else:
            (data) = self.enable_registration_instancing_with_http_info(destination_id, enabled, **kwargs)  # noqa: E501
            return data

    def enable_registration_instancing_with_http_info(self, destination_id, enabled, **kwargs):  # noqa: E501
        """DestinationsDispatchesRegistrationInstancing  # noqa: E501

        Enable or disable registration instancing.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.enable_registration_instancing_with_http_info(destination_id, enabled, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str destination_id: Identifier for the destination (required)
        :param EnabledSchema enabled:  (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['destination_id', 'enabled']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method enable_registration_instancing" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'destination_id' is set
        if ('destination_id' not in params or
                params['destination_id'] is None):
            raise ValueError("Missing the required parameter `destination_id` when calling `enable_registration_instancing`")  # noqa: E501
        # verify the required parameter 'enabled' is set
        if ('enabled' not in params or
                params['enabled'] is None):
            raise ValueError("Missing the required parameter `enabled` when calling `enable_registration_instancing`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'destination_id' in params:
            path_params['destinationId'] = params['destination_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'enabled' in params:
            body_params = params['enabled']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APP_NORMAL', 'OAUTH']  # noqa: E501

        return self.api_client.call_api(
            '/dispatch/destinations/{destinationId}/dispatches/registrationInstancing', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_destination(self, destination_id, **kwargs):  # noqa: E501
        """Get destination information by destinationId.  # noqa: E501

        Gets detailed information about a destination belonging to a destinationId.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_destination(destination_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str destination_id: Identifier for the destination (required)
        :return: DestinationSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_destination_with_http_info(destination_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_destination_with_http_info(destination_id, **kwargs)  # noqa: E501
            return data

    def get_destination_with_http_info(self, destination_id, **kwargs):  # noqa: E501
        """Get destination information by destinationId.  # noqa: E501

        Gets detailed information about a destination belonging to a destinationId.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_destination_with_http_info(destination_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str destination_id: Identifier for the destination (required)
        :return: DestinationSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['destination_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_destination" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'destination_id' is set
        if ('destination_id' not in params or
                params['destination_id'] is None):
            raise ValueError("Missing the required parameter `destination_id` when calling `get_destination`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'destination_id' in params:
            path_params['destinationId'] = params['destination_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APP_NORMAL', 'OAUTH']  # noqa: E501

        return self.api_client.call_api(
            '/dispatch/destinations/{destinationId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DestinationSchema',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_destination_dispatch_registration_count(self, destination_id, **kwargs):  # noqa: E501
        """DestinationsDispatchesRegistrationCount  # noqa: E501

        Get an aggregate count of all related dispatch registrations.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_destination_dispatch_registration_count(destination_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str destination_id: Identifier for the destination (required)
        :return: IntegerResultSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_destination_dispatch_registration_count_with_http_info(destination_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_destination_dispatch_registration_count_with_http_info(destination_id, **kwargs)  # noqa: E501
            return data

    def get_destination_dispatch_registration_count_with_http_info(self, destination_id, **kwargs):  # noqa: E501
        """DestinationsDispatchesRegistrationCount  # noqa: E501

        Get an aggregate count of all related dispatch registrations.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_destination_dispatch_registration_count_with_http_info(destination_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str destination_id: Identifier for the destination (required)
        :return: IntegerResultSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['destination_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_destination_dispatch_registration_count" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'destination_id' is set
        if ('destination_id' not in params or
                params['destination_id'] is None):
            raise ValueError("Missing the required parameter `destination_id` when calling `get_destination_dispatch_registration_count`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'destination_id' in params:
            path_params['destinationId'] = params['destination_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APP_NORMAL', 'OAUTH']  # noqa: E501

        return self.api_client.call_api(
            '/dispatch/destinations/{destinationId}/dispatches/registrationCount', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='IntegerResultSchema',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_destination_dispatch_zip(self, destination_id, **kwargs):  # noqa: E501
        """Get a ZIP of related dispatches.  # noqa: E501

        Returns a zip file containing all of the dispatch packages for a destination.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_destination_dispatch_zip(destination_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str destination_id: Identifier for the destination (required)
        :param str type: The type of dispatch package to export (SCORM12 only supported in cloud today)
        :param str css_url:
        :param list[str] tags:
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_destination_dispatch_zip_with_http_info(destination_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_destination_dispatch_zip_with_http_info(destination_id, **kwargs)  # noqa: E501
            return data

    def get_destination_dispatch_zip_with_http_info(self, destination_id, **kwargs):  # noqa: E501
        """Get a ZIP of related dispatches.  # noqa: E501

        Returns a zip file containing all of the dispatch packages for a destination.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_destination_dispatch_zip_with_http_info(destination_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str destination_id: Identifier for the destination (required)
        :param str type: The type of dispatch package to export (SCORM12 only supported in cloud today)
        :param str css_url:
        :param list[str] tags:
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['destination_id', 'type', 'css_url', 'tags']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_destination_dispatch_zip" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'destination_id' is set
        if ('destination_id' not in params or
                params['destination_id'] is None):
            raise ValueError("Missing the required parameter `destination_id` when calling `get_destination_dispatch_zip`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'destination_id' in params:
            path_params['destinationId'] = params['destination_id']  # noqa: E501

        query_params = []
        if 'type' in params:
            query_params.append(('type', params['type']))  # noqa: E501
        if 'css_url' in params:
            query_params.append(('cssUrl', params['css_url']))  # noqa: E501
        if 'tags' in params:
            query_params.append(('tags', params['tags']))  # noqa: E501
            collection_formats['tags'] = 'csv'  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/zip'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APP_NORMAL', 'OAUTH']  # noqa: E501

        return self.api_client.call_api(
            '/dispatch/destinations/{destinationId}/dispatches/zip', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='file',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_destination_dispatches(self, destination_id, **kwargs):  # noqa: E501
        """Get a list of dispatches in this destination  # noqa: E501

        Get a list of related dispatches.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_destination_dispatches(destination_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str destination_id: Identifier for the destination (required)
        :param str course_id: Only retreive resources having `courseId` 
        :param str more: Value for this parameter will be provided in the 'more' property of registration lists, where needed. An opaque value, construction and parsing may change without notice.
        :param datetime since: Only items updated since the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used.
        :param datetime until: Only items updated before the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used.
        :param list[str] tags:
        :param str datetime_filter: A string describing what the since/until parameters will be applied to. Options are: 'created' or 'updated'.  If not provided, it will default to `updated`.
        :param str order_by:
        :return: DispatchListSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_destination_dispatches_with_http_info(destination_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_destination_dispatches_with_http_info(destination_id, **kwargs)  # noqa: E501
            return data

    def get_destination_dispatches_with_http_info(self, destination_id, **kwargs):  # noqa: E501
        """Get a list of dispatches in this destination  # noqa: E501

        Get a list of related dispatches.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_destination_dispatches_with_http_info(destination_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str destination_id: Identifier for the destination (required)
        :param str course_id: Only retreive resources having `courseId` 
        :param str more: Value for this parameter will be provided in the 'more' property of registration lists, where needed. An opaque value, construction and parsing may change without notice.
        :param datetime since: Only items updated since the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used.
        :param datetime until: Only items updated before the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used.
        :param list[str] tags:
        :param str datetime_filter: A string describing what the since/until parameters will be applied to. Options are: 'created' or 'updated'.  If not provided, it will default to `updated`.
        :param str order_by:
        :return: DispatchListSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['destination_id', 'course_id', 'more', 'since', 'until', 'tags', 'datetime_filter', 'order_by']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_destination_dispatches" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'destination_id' is set
        if ('destination_id' not in params or
                params['destination_id'] is None):
            raise ValueError("Missing the required parameter `destination_id` when calling `get_destination_dispatches`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'destination_id' in params:
            path_params['destinationId'] = params['destination_id']  # noqa: E501

        query_params = []
        if 'course_id' in params:
            query_params.append(('courseId', params['course_id']))  # noqa: E501
        if 'more' in params:
            query_params.append(('more', params['more']))  # noqa: E501
        if 'since' in params:
            query_params.append(('since', params['since']))  # noqa: E501
        if 'until' in params:
            query_params.append(('until', params['until']))  # noqa: E501
        if 'tags' in params:
            query_params.append(('tags', params['tags']))  # noqa: E501
            collection_formats['tags'] = 'csv'  # noqa: E501
        if 'datetime_filter' in params:
            query_params.append(('datetimeFilter', params['datetime_filter']))  # noqa: E501
        if 'order_by' in params:
            query_params.append(('orderBy', params['order_by']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APP_NORMAL', 'OAUTH']  # noqa: E501

        return self.api_client.call_api(
            '/dispatch/destinations/{destinationId}/dispatches', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DispatchListSchema',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_destination_hash_user_info(self, destination_id, **kwargs):  # noqa: E501
        """True if the destination is set to hash user info, or false if it is disabled.  # noqa: E501

        True if the destination is set to hash user info, or false if it is disabled.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_destination_hash_user_info(destination_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str destination_id: Identifier for the destination (required)
        :return: EnabledSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_destination_hash_user_info_with_http_info(destination_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_destination_hash_user_info_with_http_info(destination_id, **kwargs)  # noqa: E501
            return data

    def get_destination_hash_user_info_with_http_info(self, destination_id, **kwargs):  # noqa: E501
        """True if the destination is set to hash user info, or false if it is disabled.  # noqa: E501

        True if the destination is set to hash user info, or false if it is disabled.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_destination_hash_user_info_with_http_info(destination_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str destination_id: Identifier for the destination (required)
        :return: EnabledSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['destination_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_destination_hash_user_info" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'destination_id' is set
        if ('destination_id' not in params or
                params['destination_id'] is None):
            raise ValueError("Missing the required parameter `destination_id` when calling `get_destination_hash_user_info`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'destination_id' in params:
            path_params['destinationId'] = params['destination_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APP_NORMAL', 'OAUTH']  # noqa: E501

        return self.api_client.call_api(
            '/dispatch/destinations/{destinationId}/dispatches/hashUserInfo', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='EnabledSchema',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_destination_tags(self, destination_id, **kwargs):  # noqa: E501
        """Get the tags for this destination   # noqa: E501

        Get the tags for this destination   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_destination_tags(destination_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str destination_id: Identifier for the destination (required)
        :return: TagListSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_destination_tags_with_http_info(destination_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_destination_tags_with_http_info(destination_id, **kwargs)  # noqa: E501
            return data

    def get_destination_tags_with_http_info(self, destination_id, **kwargs):  # noqa: E501
        """Get the tags for this destination   # noqa: E501

        Get the tags for this destination   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_destination_tags_with_http_info(destination_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str destination_id: Identifier for the destination (required)
        :return: TagListSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['destination_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_destination_tags" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'destination_id' is set
        if ('destination_id' not in params or
                params['destination_id'] is None):
            raise ValueError("Missing the required parameter `destination_id` when calling `get_destination_tags`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'destination_id' in params:
            path_params['destinationId'] = params['destination_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APP_NORMAL', 'OAUTH']  # noqa: E501

        return self.api_client.call_api(
            '/dispatch/destinations/{destinationId}/tags', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TagListSchema',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_destinations(self, **kwargs):  # noqa: E501
        """getAllDestinations  # noqa: E501

        Get a list of destinations.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_destinations(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: Only retreive resources having `courseId` 
        :param str more: Value for this parameter will be provided in the 'more' property of registration lists, where needed. An opaque value, construction and parsing may change without notice.
        :param datetime since: Only items updated since the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used.
        :param datetime until: Only items updated before the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used.
        :param list[str] tags:
        :param str datetime_filter: A string describing what the since/until parameters will be applied to. Options are: 'created' or 'updated'.  If not provided, it will default to `updated`.
        :param str order_by: Optional enum parameter for specifying the field and order by which to sort the results.  Defaults to updated_asc
        :return: DestinationListSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_destinations_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_destinations_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_destinations_with_http_info(self, **kwargs):  # noqa: E501
        """getAllDestinations  # noqa: E501

        Get a list of destinations.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_destinations_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: Only retreive resources having `courseId` 
        :param str more: Value for this parameter will be provided in the 'more' property of registration lists, where needed. An opaque value, construction and parsing may change without notice.
        :param datetime since: Only items updated since the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used.
        :param datetime until: Only items updated before the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used.
        :param list[str] tags:
        :param str datetime_filter: A string describing what the since/until parameters will be applied to. Options are: 'created' or 'updated'.  If not provided, it will default to `updated`.
        :param str order_by: Optional enum parameter for specifying the field and order by which to sort the results.  Defaults to updated_asc
        :return: DestinationListSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['course_id', 'more', 'since', 'until', 'tags', 'datetime_filter', 'order_by']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_destinations" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'course_id' in params:
            query_params.append(('courseId', params['course_id']))  # noqa: E501
        if 'more' in params:
            query_params.append(('more', params['more']))  # noqa: E501
        if 'since' in params:
            query_params.append(('since', params['since']))  # noqa: E501
        if 'until' in params:
            query_params.append(('until', params['until']))  # noqa: E501
        if 'tags' in params:
            query_params.append(('tags', params['tags']))  # noqa: E501
            collection_formats['tags'] = 'csv'  # noqa: E501
        if 'datetime_filter' in params:
            query_params.append(('datetimeFilter', params['datetime_filter']))  # noqa: E501
        if 'order_by' in params:
            query_params.append(('orderBy', params['order_by']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APP_NORMAL', 'OAUTH']  # noqa: E501

        return self.api_client.call_api(
            '/dispatch/destinations', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DestinationListSchema',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_dispatch(self, dispatch_id, **kwargs):  # noqa: E501
        """Get dispatch by id.  # noqa: E501

        Get the dispatch with `dispatchId`.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_dispatch(dispatch_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str dispatch_id: Identifier for the dispatch (required)
        :return: DispatchSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_dispatch_with_http_info(dispatch_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_dispatch_with_http_info(dispatch_id, **kwargs)  # noqa: E501
            return data

    def get_dispatch_with_http_info(self, dispatch_id, **kwargs):  # noqa: E501
        """Get dispatch by id.  # noqa: E501

        Get the dispatch with `dispatchId`.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_dispatch_with_http_info(dispatch_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str dispatch_id: Identifier for the dispatch (required)
        :return: DispatchSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['dispatch_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_dispatch" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'dispatch_id' is set
        if ('dispatch_id' not in params or
                params['dispatch_id'] is None):
            raise ValueError("Missing the required parameter `dispatch_id` when calling `get_dispatch`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'dispatch_id' in params:
            path_params['dispatchId'] = params['dispatch_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APP_NORMAL', 'OAUTH']  # noqa: E501

        return self.api_client.call_api(
            '/dispatch/dispatches/{dispatchId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DispatchSchema',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_dispatch_enabled(self, dispatch_id, **kwargs):  # noqa: E501
        """Get the `enabled` status for `dispatchId`.   # noqa: E501

        Get the `enabled` status for `dispatchId`.  True if the dispatch is enabled, or false if it is disabled.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_dispatch_enabled(dispatch_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str dispatch_id: Identifier for the dispatch (required)
        :return: EnabledSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_dispatch_enabled_with_http_info(dispatch_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_dispatch_enabled_with_http_info(dispatch_id, **kwargs)  # noqa: E501
            return data

    def get_dispatch_enabled_with_http_info(self, dispatch_id, **kwargs):  # noqa: E501
        """Get the `enabled` status for `dispatchId`.   # noqa: E501

        Get the `enabled` status for `dispatchId`.  True if the dispatch is enabled, or false if it is disabled.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_dispatch_enabled_with_http_info(dispatch_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str dispatch_id: Identifier for the dispatch (required)
        :return: EnabledSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['dispatch_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_dispatch_enabled" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'dispatch_id' is set
        if ('dispatch_id' not in params or
                params['dispatch_id'] is None):
            raise ValueError("Missing the required parameter `dispatch_id` when calling `get_dispatch_enabled`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'dispatch_id' in params:
            path_params['dispatchId'] = params['dispatch_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APP_NORMAL', 'OAUTH']  # noqa: E501

        return self.api_client.call_api(
            '/dispatch/dispatches/{dispatchId}/enabled', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='EnabledSchema',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_dispatch_hash_user_info(self, dispatch_id, **kwargs):  # noqa: E501
        """Get if this dispatch has PII hashing enabled.  # noqa: E501

        Get if this dispatch has PII hashing enabled. True if the dispatch is set to hash user info, or false if it is disabled.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_dispatch_hash_user_info(dispatch_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str dispatch_id: Identifier for the dispatch (required)
        :return: EnabledSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_dispatch_hash_user_info_with_http_info(dispatch_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_dispatch_hash_user_info_with_http_info(dispatch_id, **kwargs)  # noqa: E501
            return data

    def get_dispatch_hash_user_info_with_http_info(self, dispatch_id, **kwargs):  # noqa: E501
        """Get if this dispatch has PII hashing enabled.  # noqa: E501

        Get if this dispatch has PII hashing enabled. True if the dispatch is set to hash user info, or false if it is disabled.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_dispatch_hash_user_info_with_http_info(dispatch_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str dispatch_id: Identifier for the dispatch (required)
        :return: EnabledSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['dispatch_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_dispatch_hash_user_info" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'dispatch_id' is set
        if ('dispatch_id' not in params or
                params['dispatch_id'] is None):
            raise ValueError("Missing the required parameter `dispatch_id` when calling `get_dispatch_hash_user_info`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'dispatch_id' in params:
            path_params['dispatchId'] = params['dispatch_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APP_NORMAL', 'OAUTH']  # noqa: E501

        return self.api_client.call_api(
            '/dispatch/dispatches/{dispatchId}/hashUserInfo', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='EnabledSchema',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_dispatch_registration_count(self, dispatch_id, **kwargs):  # noqa: E501
        """Get the registration count for `dispatchId`.   # noqa: E501

        Get the registration count for this dispatch, and the date and time of the last count reset, if any.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_dispatch_registration_count(dispatch_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str dispatch_id: Identifier for the dispatch (required)
        :return: DispatchRegistrationCountSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_dispatch_registration_count_with_http_info(dispatch_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_dispatch_registration_count_with_http_info(dispatch_id, **kwargs)  # noqa: E501
            return data

    def get_dispatch_registration_count_with_http_info(self, dispatch_id, **kwargs):  # noqa: E501
        """Get the registration count for `dispatchId`.   # noqa: E501

        Get the registration count for this dispatch, and the date and time of the last count reset, if any.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_dispatch_registration_count_with_http_info(dispatch_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str dispatch_id: Identifier for the dispatch (required)
        :return: DispatchRegistrationCountSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['dispatch_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_dispatch_registration_count" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'dispatch_id' is set
        if ('dispatch_id' not in params or
                params['dispatch_id'] is None):
            raise ValueError("Missing the required parameter `dispatch_id` when calling `get_dispatch_registration_count`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'dispatch_id' in params:
            path_params['dispatchId'] = params['dispatch_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APP_NORMAL', 'OAUTH']  # noqa: E501

        return self.api_client.call_api(
            '/dispatch/dispatches/{dispatchId}/registrationCount', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DispatchRegistrationCountSchema',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_dispatch_tags(self, dispatch_id, **kwargs):  # noqa: E501
        """Get the tags for this dispatch.   # noqa: E501

        Get the tags for this dispatch.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_dispatch_tags(dispatch_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str dispatch_id: Identifier for the dispatch (required)
        :return: TagListSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_dispatch_tags_with_http_info(dispatch_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_dispatch_tags_with_http_info(dispatch_id, **kwargs)  # noqa: E501
            return data

    def get_dispatch_tags_with_http_info(self, dispatch_id, **kwargs):  # noqa: E501
        """Get the tags for this dispatch.   # noqa: E501

        Get the tags for this dispatch.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_dispatch_tags_with_http_info(dispatch_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str dispatch_id: Identifier for the dispatch (required)
        :return: TagListSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['dispatch_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_dispatch_tags" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'dispatch_id' is set
        if ('dispatch_id' not in params or
                params['dispatch_id'] is None):
            raise ValueError("Missing the required parameter `dispatch_id` when calling `get_dispatch_tags`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'dispatch_id' in params:
            path_params['dispatchId'] = params['dispatch_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APP_NORMAL', 'OAUTH']  # noqa: E501

        return self.api_client.call_api(
            '/dispatch/dispatches/{dispatchId}/tags', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TagListSchema',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_dispatch_zip(self, dispatch_id, **kwargs):  # noqa: E501
        """Get the ZIP for the dispatchId.  # noqa: E501

        Get the ZIP for the dispatch with `dispatchId`   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_dispatch_zip(dispatch_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str dispatch_id: Identifier for the dispatch (required)
        :param str type: The type of dispatch package to export (SCORM12 only supported in cloud today)
        :param str css_url:
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_dispatch_zip_with_http_info(dispatch_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_dispatch_zip_with_http_info(dispatch_id, **kwargs)  # noqa: E501
            return data

    def get_dispatch_zip_with_http_info(self, dispatch_id, **kwargs):  # noqa: E501
        """Get the ZIP for the dispatchId.  # noqa: E501

        Get the ZIP for the dispatch with `dispatchId`   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_dispatch_zip_with_http_info(dispatch_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str dispatch_id: Identifier for the dispatch (required)
        :param str type: The type of dispatch package to export (SCORM12 only supported in cloud today)
        :param str css_url:
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['dispatch_id', 'type', 'css_url']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_dispatch_zip" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'dispatch_id' is set
        if ('dispatch_id' not in params or
                params['dispatch_id'] is None):
            raise ValueError("Missing the required parameter `dispatch_id` when calling `get_dispatch_zip`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'dispatch_id' in params:
            path_params['dispatchId'] = params['dispatch_id']  # noqa: E501

        query_params = []
        if 'type' in params:
            query_params.append(('type', params['type']))  # noqa: E501
        if 'css_url' in params:
            query_params.append(('cssUrl', params['css_url']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/zip'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APP_NORMAL', 'OAUTH']  # noqa: E501

        return self.api_client.call_api(
            '/dispatch/dispatches/{dispatchId}/zip', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='file',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_dispatches(self, **kwargs):  # noqa: E501
        """All Dispatches in the system for an AppId  # noqa: E501

        Get a list of dispatches.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_dispatches(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: Only retreive resources having `courseId` 
        :param str more: Value for this parameter will be provided in the 'more' property of registration lists, where needed. An opaque value, construction and parsing may change without notice.
        :param datetime since: Only items updated since the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used.
        :param datetime until: Only items updated before the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used.
        :param list[str] tags:
        :param str datetime_filter: A string describing what the since/until parameters will be applied to. Options are: 'created' or 'updated'.  If not provided, it will default to `updated`.
        :param str order_by: Optional enum parameter for specifying the field and order by which to sort the results.  Defaults to updated_asc
        :return: DispatchListSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_dispatches_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_dispatches_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_dispatches_with_http_info(self, **kwargs):  # noqa: E501
        """All Dispatches in the system for an AppId  # noqa: E501

        Get a list of dispatches.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_dispatches_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: Only retreive resources having `courseId` 
        :param str more: Value for this parameter will be provided in the 'more' property of registration lists, where needed. An opaque value, construction and parsing may change without notice.
        :param datetime since: Only items updated since the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used.
        :param datetime until: Only items updated before the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used.
        :param list[str] tags:
        :param str datetime_filter: A string describing what the since/until parameters will be applied to. Options are: 'created' or 'updated'.  If not provided, it will default to `updated`.
        :param str order_by: Optional enum parameter for specifying the field and order by which to sort the results.  Defaults to updated_asc
        :return: DispatchListSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['course_id', 'more', 'since', 'until', 'tags', 'datetime_filter', 'order_by']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_dispatches" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'course_id' in params:
            query_params.append(('courseId', params['course_id']))  # noqa: E501
        if 'more' in params:
            query_params.append(('more', params['more']))  # noqa: E501
        if 'since' in params:
            query_params.append(('since', params['since']))  # noqa: E501
        if 'until' in params:
            query_params.append(('until', params['until']))  # noqa: E501
        if 'tags' in params:
            query_params.append(('tags', params['tags']))  # noqa: E501
            collection_formats['tags'] = 'csv'  # noqa: E501
        if 'datetime_filter' in params:
            query_params.append(('datetimeFilter', params['datetime_filter']))  # noqa: E501
        if 'order_by' in params:
            query_params.append(('orderBy', params['order_by']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APP_NORMAL', 'OAUTH']  # noqa: E501

        return self.api_client.call_api(
            '/dispatch/dispatches', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DispatchListSchema',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def put_destination_tags(self, destination_id, tags, **kwargs):  # noqa: E501
        """Set the tags for this destination   # noqa: E501

        Set the tags for this destination   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_destination_tags(destination_id, tags, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str destination_id: Identifier for the destination (required)
        :param TagListSchema tags: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.put_destination_tags_with_http_info(destination_id, tags, **kwargs)  # noqa: E501
        else:
            (data) = self.put_destination_tags_with_http_info(destination_id, tags, **kwargs)  # noqa: E501
            return data

    def put_destination_tags_with_http_info(self, destination_id, tags, **kwargs):  # noqa: E501
        """Set the tags for this destination   # noqa: E501

        Set the tags for this destination   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_destination_tags_with_http_info(destination_id, tags, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str destination_id: Identifier for the destination (required)
        :param TagListSchema tags: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['destination_id', 'tags']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_destination_tags" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'destination_id' is set
        if ('destination_id' not in params or
                params['destination_id'] is None):
            raise ValueError("Missing the required parameter `destination_id` when calling `put_destination_tags`")  # noqa: E501
        # verify the required parameter 'tags' is set
        if ('tags' not in params or
                params['tags'] is None):
            raise ValueError("Missing the required parameter `tags` when calling `put_destination_tags`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'destination_id' in params:
            path_params['destinationId'] = params['destination_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'tags' in params:
            body_params = params['tags']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APP_NORMAL', 'OAUTH']  # noqa: E501

        return self.api_client.call_api(
            '/dispatch/destinations/{destinationId}/tags', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def put_destination_tags_batch(self, batch, **kwargs):  # noqa: E501
        """Sets all of the provided tags on all of the provided destinations  # noqa: E501

        Sets all of the provided tags on all of the provided destinations  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_destination_tags_batch(batch, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param BatchTagsSchema batch: Object representing an array of ids to apply an array of tags to. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.put_destination_tags_batch_with_http_info(batch, **kwargs)  # noqa: E501
        else:
            (data) = self.put_destination_tags_batch_with_http_info(batch, **kwargs)  # noqa: E501
            return data

    def put_destination_tags_batch_with_http_info(self, batch, **kwargs):  # noqa: E501
        """Sets all of the provided tags on all of the provided destinations  # noqa: E501

        Sets all of the provided tags on all of the provided destinations  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_destination_tags_batch_with_http_info(batch, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param BatchTagsSchema batch: Object representing an array of ids to apply an array of tags to. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['batch']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_destination_tags_batch" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'batch' is set
        if ('batch' not in params or
                params['batch'] is None):
            raise ValueError("Missing the required parameter `batch` when calling `put_destination_tags_batch`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'batch' in params:
            body_params = params['batch']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APP_NORMAL', 'OAUTH']  # noqa: E501

        return self.api_client.call_api(
            '/dispatch/destinations/tags', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def put_dispatch_tags(self, dispatch_id, tags, **kwargs):  # noqa: E501
        """Set the tags for this dispatch.   # noqa: E501

        Set the tags for this dispatch.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_dispatch_tags(dispatch_id, tags, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str dispatch_id: Identifier for the dispatch (required)
        :param TagListSchema tags: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.put_dispatch_tags_with_http_info(dispatch_id, tags, **kwargs)  # noqa: E501
        else:
            (data) = self.put_dispatch_tags_with_http_info(dispatch_id, tags, **kwargs)  # noqa: E501
            return data

    def put_dispatch_tags_with_http_info(self, dispatch_id, tags, **kwargs):  # noqa: E501
        """Set the tags for this dispatch.   # noqa: E501

        Set the tags for this dispatch.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_dispatch_tags_with_http_info(dispatch_id, tags, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str dispatch_id: Identifier for the dispatch (required)
        :param TagListSchema tags: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['dispatch_id', 'tags']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_dispatch_tags" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'dispatch_id' is set
        if ('dispatch_id' not in params or
                params['dispatch_id'] is None):
            raise ValueError("Missing the required parameter `dispatch_id` when calling `put_dispatch_tags`")  # noqa: E501
        # verify the required parameter 'tags' is set
        if ('tags' not in params or
                params['tags'] is None):
            raise ValueError("Missing the required parameter `tags` when calling `put_dispatch_tags`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'dispatch_id' in params:
            path_params['dispatchId'] = params['dispatch_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'tags' in params:
            body_params = params['tags']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APP_NORMAL', 'OAUTH']  # noqa: E501

        return self.api_client.call_api(
            '/dispatch/dispatches/{dispatchId}/tags', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def put_dispatch_tags_batch(self, batch, **kwargs):  # noqa: E501
        """Sets all of the provided tags on all of the provided dispatches   # noqa: E501

        Sets all of the provided tags on all of the provided dispatches   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_dispatch_tags_batch(batch, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param BatchTagsSchema batch: Object representing an array of ids to apply an array of tags to. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.put_dispatch_tags_batch_with_http_info(batch, **kwargs)  # noqa: E501
        else:
            (data) = self.put_dispatch_tags_batch_with_http_info(batch, **kwargs)  # noqa: E501
            return data

    def put_dispatch_tags_batch_with_http_info(self, batch, **kwargs):  # noqa: E501
        """Sets all of the provided tags on all of the provided dispatches   # noqa: E501

        Sets all of the provided tags on all of the provided dispatches   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_dispatch_tags_batch_with_http_info(batch, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param BatchTagsSchema batch: Object representing an array of ids to apply an array of tags to. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['batch']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_dispatch_tags_batch" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'batch' is set
        if ('batch' not in params or
                params['batch'] is None):
            raise ValueError("Missing the required parameter `batch` when calling `put_dispatch_tags_batch`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'batch' in params:
            body_params = params['batch']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APP_NORMAL', 'OAUTH']  # noqa: E501

        return self.api_client.call_api(
            '/dispatch/dispatches/tags', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def reset_destination_dispatch_registration_count(self, destination_id, **kwargs):  # noqa: E501
        """DestinationsDispatchesRegistrationCount  # noqa: E501

        Reset registration counts for all related dispatches.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.reset_destination_dispatch_registration_count(destination_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str destination_id: Identifier for the destination (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.reset_destination_dispatch_registration_count_with_http_info(destination_id, **kwargs)  # noqa: E501
        else:
            (data) = self.reset_destination_dispatch_registration_count_with_http_info(destination_id, **kwargs)  # noqa: E501
            return data

    def reset_destination_dispatch_registration_count_with_http_info(self, destination_id, **kwargs):  # noqa: E501
        """DestinationsDispatchesRegistrationCount  # noqa: E501

        Reset registration counts for all related dispatches.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.reset_destination_dispatch_registration_count_with_http_info(destination_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str destination_id: Identifier for the destination (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['destination_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method reset_destination_dispatch_registration_count" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'destination_id' is set
        if ('destination_id' not in params or
                params['destination_id'] is None):
            raise ValueError("Missing the required parameter `destination_id` when calling `reset_destination_dispatch_registration_count`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'destination_id' in params:
            path_params['destinationId'] = params['destination_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APP_NORMAL', 'OAUTH']  # noqa: E501

        return self.api_client.call_api(
            '/dispatch/destinations/{destinationId}/dispatches/registrationCount', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def reset_dispatch_registration_count(self, dispatch_id, **kwargs):  # noqa: E501
        """Reset registration count.   # noqa: E501

        Reset the registration count for this dispatch.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.reset_dispatch_registration_count(dispatch_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str dispatch_id: Identifier for the dispatch (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.reset_dispatch_registration_count_with_http_info(dispatch_id, **kwargs)  # noqa: E501
        else:
            (data) = self.reset_dispatch_registration_count_with_http_info(dispatch_id, **kwargs)  # noqa: E501
            return data

    def reset_dispatch_registration_count_with_http_info(self, dispatch_id, **kwargs):  # noqa: E501
        """Reset registration count.   # noqa: E501

        Reset the registration count for this dispatch.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.reset_dispatch_registration_count_with_http_info(dispatch_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str dispatch_id: Identifier for the dispatch (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['dispatch_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method reset_dispatch_registration_count" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'dispatch_id' is set
        if ('dispatch_id' not in params or
                params['dispatch_id'] is None):
            raise ValueError("Missing the required parameter `dispatch_id` when calling `reset_dispatch_registration_count`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'dispatch_id' in params:
            path_params['dispatchId'] = params['dispatch_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APP_NORMAL', 'OAUTH']  # noqa: E501

        return self.api_client.call_api(
            '/dispatch/dispatches/{dispatchId}/registrationCount', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def set_destination(self, destination_id, destination, **kwargs):  # noqa: E501
        """set_destination  # noqa: E501

        Creates or updates the destination identified by the `destinationId` provided in the path. If the destination is being created, a name should be provided in the DestinationSchema, else an error will be thrown.  You may also optionally supply the e-mail address of the user to be associated with this destination.  This e-mail address should correspond to a SCORM Cloud user account. If you do not supply an e-mail address upon the creation of a destination, the owner of the Realm will be used.  This can, of course, also be changed via calling this method to update an existing destination.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_destination(destination_id, destination, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str destination_id: Identifier for the destination (required)
        :param DestinationSchema destination: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.set_destination_with_http_info(destination_id, destination, **kwargs)  # noqa: E501
        else:
            (data) = self.set_destination_with_http_info(destination_id, destination, **kwargs)  # noqa: E501
            return data

    def set_destination_with_http_info(self, destination_id, destination, **kwargs):  # noqa: E501
        """set_destination  # noqa: E501

        Creates or updates the destination identified by the `destinationId` provided in the path. If the destination is being created, a name should be provided in the DestinationSchema, else an error will be thrown.  You may also optionally supply the e-mail address of the user to be associated with this destination.  This e-mail address should correspond to a SCORM Cloud user account. If you do not supply an e-mail address upon the creation of a destination, the owner of the Realm will be used.  This can, of course, also be changed via calling this method to update an existing destination.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_destination_with_http_info(destination_id, destination, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str destination_id: Identifier for the destination (required)
        :param DestinationSchema destination: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['destination_id', 'destination']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method set_destination" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'destination_id' is set
        if ('destination_id' not in params or
                params['destination_id'] is None):
            raise ValueError("Missing the required parameter `destination_id` when calling `set_destination`")  # noqa: E501
        # verify the required parameter 'destination' is set
        if ('destination' not in params or
                params['destination'] is None):
            raise ValueError("Missing the required parameter `destination` when calling `set_destination`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'destination_id' in params:
            path_params['destinationId'] = params['destination_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'destination' in params:
            body_params = params['destination']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APP_NORMAL', 'OAUTH']  # noqa: E501

        return self.api_client.call_api(
            '/dispatch/destinations/{destinationId}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def set_destination_dispatch_enabled(self, destination_id, enabled, **kwargs):  # noqa: E501
        """DestinationsDispatchesEnabledByTenant  # noqa: E501

        Enable or disable all related dispatches.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_destination_dispatch_enabled(destination_id, enabled, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str destination_id: Identifier for the destination (required)
        :param EnabledSchema enabled:  (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.set_destination_dispatch_enabled_with_http_info(destination_id, enabled, **kwargs)  # noqa: E501
        else:
            (data) = self.set_destination_dispatch_enabled_with_http_info(destination_id, enabled, **kwargs)  # noqa: E501
            return data

    def set_destination_dispatch_enabled_with_http_info(self, destination_id, enabled, **kwargs):  # noqa: E501
        """DestinationsDispatchesEnabledByTenant  # noqa: E501

        Enable or disable all related dispatches.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_destination_dispatch_enabled_with_http_info(destination_id, enabled, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str destination_id: Identifier for the destination (required)
        :param EnabledSchema enabled:  (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['destination_id', 'enabled']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method set_destination_dispatch_enabled" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'destination_id' is set
        if ('destination_id' not in params or
                params['destination_id'] is None):
            raise ValueError("Missing the required parameter `destination_id` when calling `set_destination_dispatch_enabled`")  # noqa: E501
        # verify the required parameter 'enabled' is set
        if ('enabled' not in params or
                params['enabled'] is None):
            raise ValueError("Missing the required parameter `enabled` when calling `set_destination_dispatch_enabled`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'destination_id' in params:
            path_params['destinationId'] = params['destination_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'enabled' in params:
            body_params = params['enabled']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APP_NORMAL', 'OAUTH']  # noqa: E501

        return self.api_client.call_api(
            '/dispatch/destinations/{destinationId}/dispatches/enabled', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def set_dispatch_enabled(self, dispatch_id, enabled, **kwargs):  # noqa: E501
        """Set the `enabled` status for `dispatchId`.   # noqa: E501

        Set the `enabled` status for `dispatchId`.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_dispatch_enabled(dispatch_id, enabled, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str dispatch_id: Identifier for the dispatch (required)
        :param EnabledSchema enabled:  (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.set_dispatch_enabled_with_http_info(dispatch_id, enabled, **kwargs)  # noqa: E501
        else:
            (data) = self.set_dispatch_enabled_with_http_info(dispatch_id, enabled, **kwargs)  # noqa: E501
            return data

    def set_dispatch_enabled_with_http_info(self, dispatch_id, enabled, **kwargs):  # noqa: E501
        """Set the `enabled` status for `dispatchId`.   # noqa: E501

        Set the `enabled` status for `dispatchId`.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_dispatch_enabled_with_http_info(dispatch_id, enabled, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str dispatch_id: Identifier for the dispatch (required)
        :param EnabledSchema enabled:  (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['dispatch_id', 'enabled']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method set_dispatch_enabled" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'dispatch_id' is set
        if ('dispatch_id' not in params or
                params['dispatch_id'] is None):
            raise ValueError("Missing the required parameter `dispatch_id` when calling `set_dispatch_enabled`")  # noqa: E501
        # verify the required parameter 'enabled' is set
        if ('enabled' not in params or
                params['enabled'] is None):
            raise ValueError("Missing the required parameter `enabled` when calling `set_dispatch_enabled`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'dispatch_id' in params:
            path_params['dispatchId'] = params['dispatch_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'enabled' in params:
            body_params = params['enabled']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APP_NORMAL', 'OAUTH']  # noqa: E501

        return self.api_client.call_api(
            '/dispatch/dispatches/{dispatchId}/enabled', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_destination_hash_user_info(self, destination_id, enabled, **kwargs):  # noqa: E501
        """Enable or disable hashing of the user info for the destination.  # noqa: E501

        Enable or disable hashing of the user info for the destination.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_destination_hash_user_info(destination_id, enabled, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str destination_id: Identifier for the destination (required)
        :param EnabledSchema enabled: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_destination_hash_user_info_with_http_info(destination_id, enabled, **kwargs)  # noqa: E501
        else:
            (data) = self.update_destination_hash_user_info_with_http_info(destination_id, enabled, **kwargs)  # noqa: E501
            return data

    def update_destination_hash_user_info_with_http_info(self, destination_id, enabled, **kwargs):  # noqa: E501
        """Enable or disable hashing of the user info for the destination.  # noqa: E501

        Enable or disable hashing of the user info for the destination.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_destination_hash_user_info_with_http_info(destination_id, enabled, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str destination_id: Identifier for the destination (required)
        :param EnabledSchema enabled: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['destination_id', 'enabled']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_destination_hash_user_info" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'destination_id' is set
        if ('destination_id' not in params or
                params['destination_id'] is None):
            raise ValueError("Missing the required parameter `destination_id` when calling `update_destination_hash_user_info`")  # noqa: E501
        # verify the required parameter 'enabled' is set
        if ('enabled' not in params or
                params['enabled'] is None):
            raise ValueError("Missing the required parameter `enabled` when calling `update_destination_hash_user_info`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'destination_id' in params:
            path_params['destinationId'] = params['destination_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'enabled' in params:
            body_params = params['enabled']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APP_NORMAL', 'OAUTH']  # noqa: E501

        return self.api_client.call_api(
            '/dispatch/destinations/{destinationId}/dispatches/hashUserInfo', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_dispatch(self, dispatch_id, dispatch_properties, **kwargs):  # noqa: E501
        """Update the dispatch with `dispatchId`.   # noqa: E501

        Update the dispatch with `dispatchId`.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_dispatch(dispatch_id, dispatch_properties, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str dispatch_id: Identifier for the dispatch (required)
        :param UpdateDispatchSchema dispatch_properties: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_dispatch_with_http_info(dispatch_id, dispatch_properties, **kwargs)  # noqa: E501
        else:
            (data) = self.update_dispatch_with_http_info(dispatch_id, dispatch_properties, **kwargs)  # noqa: E501
            return data

    def update_dispatch_with_http_info(self, dispatch_id, dispatch_properties, **kwargs):  # noqa: E501
        """Update the dispatch with `dispatchId`.   # noqa: E501

        Update the dispatch with `dispatchId`.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_dispatch_with_http_info(dispatch_id, dispatch_properties, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str dispatch_id: Identifier for the dispatch (required)
        :param UpdateDispatchSchema dispatch_properties: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['dispatch_id', 'dispatch_properties']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_dispatch" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'dispatch_id' is set
        if ('dispatch_id' not in params or
                params['dispatch_id'] is None):
            raise ValueError("Missing the required parameter `dispatch_id` when calling `update_dispatch`")  # noqa: E501
        # verify the required parameter 'dispatch_properties' is set
        if ('dispatch_properties' not in params or
                params['dispatch_properties'] is None):
            raise ValueError("Missing the required parameter `dispatch_properties` when calling `update_dispatch`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'dispatch_id' in params:
            path_params['dispatchId'] = params['dispatch_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'dispatch_properties' in params:
            body_params = params['dispatch_properties']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APP_NORMAL', 'OAUTH']  # noqa: E501

        return self.api_client.call_api(
            '/dispatch/dispatches/{dispatchId}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_dispatch_hash_user_info(self, dispatch_id, enabled, **kwargs):  # noqa: E501
        """Enable or disable hashing of the user info for the dispatch.  # noqa: E501

        Enable or disable hashing of the user info for the dispatch.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_dispatch_hash_user_info(dispatch_id, enabled, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str dispatch_id: Identifier for the dispatch (required)
        :param EnabledSchema enabled: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_dispatch_hash_user_info_with_http_info(dispatch_id, enabled, **kwargs)  # noqa: E501
        else:
            (data) = self.update_dispatch_hash_user_info_with_http_info(dispatch_id, enabled, **kwargs)  # noqa: E501
            return data

    def update_dispatch_hash_user_info_with_http_info(self, dispatch_id, enabled, **kwargs):  # noqa: E501
        """Enable or disable hashing of the user info for the dispatch.  # noqa: E501

        Enable or disable hashing of the user info for the dispatch.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_dispatch_hash_user_info_with_http_info(dispatch_id, enabled, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str dispatch_id: Identifier for the dispatch (required)
        :param EnabledSchema enabled: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['dispatch_id', 'enabled']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_dispatch_hash_user_info" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'dispatch_id' is set
        if ('dispatch_id' not in params or
                params['dispatch_id'] is None):
            raise ValueError("Missing the required parameter `dispatch_id` when calling `update_dispatch_hash_user_info`")  # noqa: E501
        # verify the required parameter 'enabled' is set
        if ('enabled' not in params or
                params['enabled'] is None):
            raise ValueError("Missing the required parameter `enabled` when calling `update_dispatch_hash_user_info`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'dispatch_id' in params:
            path_params['dispatchId'] = params['dispatch_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'enabled' in params:
            body_params = params['enabled']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APP_NORMAL', 'OAUTH']  # noqa: E501

        return self.api_client.call_api(
            '/dispatch/dispatches/{dispatchId}/hashUserInfo', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
