# coding: utf-8

"""
    SCORM Cloud Rest API

    REST API used for SCORM Cloud integrations.  # noqa: E501

    OpenAPI spec version: 2.0
    Contact: systems@rusticisoftware.com
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


from __future__ import absolute_import
from deprecated import deprecated

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from rustici_software_cloud_v2.api_client import ApiClient


class DispatchApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def create_destinations(self, destinations_list, **kwargs):  # noqa: E501
        """Create a group of Destinations   # noqa: E501

        Creates a group of destinations.  A destination is a label used to identify an entity outside of SCORM Cloud, such as an LMS.  Used in conjunction with dispatches to provide access control mechanisms for the courses distributed to the destination.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_destinations(destinations_list, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param DestinationListSchema destinations_list:  (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_destinations_with_http_info(destinations_list, **kwargs)  # noqa: E501
        else:
            (data) = self.create_destinations_with_http_info(destinations_list, **kwargs)  # noqa: E501
            return data

    def create_destinations_with_http_info(self, destinations_list, **kwargs):  # noqa: E501
        """Create a group of Destinations   # noqa: E501

        Creates a group of destinations.  A destination is a label used to identify an entity outside of SCORM Cloud, such as an LMS.  Used in conjunction with dispatches to provide access control mechanisms for the courses distributed to the destination.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_destinations_with_http_info(destinations_list, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param DestinationListSchema destinations_list:  (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['destinations_list']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_destinations" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'destinations_list' is set
        if ('destinations_list' not in params or
                params['destinations_list'] is None):
            raise ValueError("Missing the required parameter `destinations_list` when calling `create_destinations`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'destinations_list' in params:
            body_params = params['destinations_list']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APP_NORMAL', 'OAUTH']  # noqa: E501

        return self.api_client.call_api(
            '/dispatch/destinations', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_dispatches(self, dispatch_list, **kwargs):  # noqa: E501
        """Create a group of Dispatches   # noqa: E501

        Creates a group of dispatches.  Dispatches are the connection between a course and a destination.  A dispatch zip package is a distributable course stub which, upon launch in a third-party LMS, will reference and launch the underlying course in SCORM Cloud.  As an extension, dispatches allow for limiting access control even after the zip file has been given to the destination.  >**Caution:** >Only one dispatch can exist for a given course-destination combination.  If calling this method with the same course and destination supplied, the old one will be loaded for modification.  An exception to this is if a dispatchId is passed in the body, the request will fail with a 400 response warning that the dispatch already exists.  This is to prevent confusion over which dispatchId is to be used in future requests.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_dispatches(dispatch_list, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param CreateDispatchListSchema dispatch_list: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_dispatches_with_http_info(dispatch_list, **kwargs)  # noqa: E501
        else:
            (data) = self.create_dispatches_with_http_info(dispatch_list, **kwargs)  # noqa: E501
            return data

    def create_dispatches_with_http_info(self, dispatch_list, **kwargs):  # noqa: E501
        """Create a group of Dispatches   # noqa: E501

        Creates a group of dispatches.  Dispatches are the connection between a course and a destination.  A dispatch zip package is a distributable course stub which, upon launch in a third-party LMS, will reference and launch the underlying course in SCORM Cloud.  As an extension, dispatches allow for limiting access control even after the zip file has been given to the destination.  >**Caution:** >Only one dispatch can exist for a given course-destination combination.  If calling this method with the same course and destination supplied, the old one will be loaded for modification.  An exception to this is if a dispatchId is passed in the body, the request will fail with a 400 response warning that the dispatch already exists.  This is to prevent confusion over which dispatchId is to be used in future requests.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_dispatches_with_http_info(dispatch_list, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param CreateDispatchListSchema dispatch_list: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['dispatch_list']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_dispatches" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'dispatch_list' is set
        if ('dispatch_list' not in params or
                params['dispatch_list'] is None):
            raise ValueError("Missing the required parameter `dispatch_list` when calling `create_dispatches`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'dispatch_list' in params:
            body_params = params['dispatch_list']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APP_NORMAL', 'OAUTH']  # noqa: E501

        return self.api_client.call_api(
            '/dispatch/dispatches', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_destination(self, destination_id, **kwargs):  # noqa: E501
        """Delete a Destination   # noqa: E501

        Deletes the specified destination.  >**Caution:** >This will also delete all dispatches belonging to the destination.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_destination(destination_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str destination_id: Identifier for the destination (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_destination_with_http_info(destination_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_destination_with_http_info(destination_id, **kwargs)  # noqa: E501
            return data

    def delete_destination_with_http_info(self, destination_id, **kwargs):  # noqa: E501
        """Delete a Destination   # noqa: E501

        Deletes the specified destination.  >**Caution:** >This will also delete all dispatches belonging to the destination.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_destination_with_http_info(destination_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str destination_id: Identifier for the destination (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['destination_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_destination" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'destination_id' is set
        if ('destination_id' not in params or
                params['destination_id'] is None):
            raise ValueError("Missing the required parameter `destination_id` when calling `delete_destination`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'destination_id' in params:
            path_params['destinationId'] = params['destination_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APP_NORMAL', 'OAUTH']  # noqa: E501

        return self.api_client.call_api(
            '/dispatch/destinations/{destinationId}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_destination_dispatches(self, destination_id, **kwargs):  # noqa: E501
        """Delete a Destination's Dispatches   # noqa: E501

        Deletes all the dispatches from the destination.  >**Caution:** >This will invalidate any existing dispatch packages, rendering them unlaunchable.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_destination_dispatches(destination_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str destination_id: Identifier for the destination (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_destination_dispatches_with_http_info(destination_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_destination_dispatches_with_http_info(destination_id, **kwargs)  # noqa: E501
            return data

    def delete_destination_dispatches_with_http_info(self, destination_id, **kwargs):  # noqa: E501
        """Delete a Destination's Dispatches   # noqa: E501

        Deletes all the dispatches from the destination.  >**Caution:** >This will invalidate any existing dispatch packages, rendering them unlaunchable.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_destination_dispatches_with_http_info(destination_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str destination_id: Identifier for the destination (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['destination_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_destination_dispatches" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'destination_id' is set
        if ('destination_id' not in params or
                params['destination_id'] is None):
            raise ValueError("Missing the required parameter `destination_id` when calling `delete_destination_dispatches`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'destination_id' in params:
            path_params['destinationId'] = params['destination_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APP_NORMAL', 'OAUTH']  # noqa: E501

        return self.api_client.call_api(
            '/dispatch/destinations/{destinationId}/dispatches', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_destination_tags(self, destination_id, tags, **kwargs):  # noqa: E501
        """Delete tags from a Destination   # noqa: E501

        Deletes the specified tags from the destination.  Deleting tags that do not exist will still result in a success.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_destination_tags(destination_id, tags, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str destination_id: Identifier for the destination (required)
        :param TagListSchema tags: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_destination_tags_with_http_info(destination_id, tags, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_destination_tags_with_http_info(destination_id, tags, **kwargs)  # noqa: E501
            return data

    def delete_destination_tags_with_http_info(self, destination_id, tags, **kwargs):  # noqa: E501
        """Delete tags from a Destination   # noqa: E501

        Deletes the specified tags from the destination.  Deleting tags that do not exist will still result in a success.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_destination_tags_with_http_info(destination_id, tags, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str destination_id: Identifier for the destination (required)
        :param TagListSchema tags: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['destination_id', 'tags']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_destination_tags" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'destination_id' is set
        if ('destination_id' not in params or
                params['destination_id'] is None):
            raise ValueError("Missing the required parameter `destination_id` when calling `delete_destination_tags`")  # noqa: E501
        # verify the required parameter 'tags' is set
        if ('tags' not in params or
                params['tags'] is None):
            raise ValueError("Missing the required parameter `tags` when calling `delete_destination_tags`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'destination_id' in params:
            path_params['destinationId'] = params['destination_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'tags' in params:
            body_params = params['tags']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APP_NORMAL', 'OAUTH']  # noqa: E501

        return self.api_client.call_api(
            '/dispatch/destinations/{destinationId}/tags', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_dispatch(self, dispatch_id, **kwargs):  # noqa: E501
        """Delete a Dispatch   # noqa: E501

        Deletes the specified dispatch.  >**Caution:** >This will invalidate any existing dispatch packages, rendering them unlaunchable.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_dispatch(dispatch_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str dispatch_id: Identifier for the dispatch (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_dispatch_with_http_info(dispatch_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_dispatch_with_http_info(dispatch_id, **kwargs)  # noqa: E501
            return data

    def delete_dispatch_with_http_info(self, dispatch_id, **kwargs):  # noqa: E501
        """Delete a Dispatch   # noqa: E501

        Deletes the specified dispatch.  >**Caution:** >This will invalidate any existing dispatch packages, rendering them unlaunchable.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_dispatch_with_http_info(dispatch_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str dispatch_id: Identifier for the dispatch (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['dispatch_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_dispatch" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'dispatch_id' is set
        if ('dispatch_id' not in params or
                params['dispatch_id'] is None):
            raise ValueError("Missing the required parameter `dispatch_id` when calling `delete_dispatch`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'dispatch_id' in params:
            path_params['dispatchId'] = params['dispatch_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APP_NORMAL', 'OAUTH']  # noqa: E501

        return self.api_client.call_api(
            '/dispatch/dispatches/{dispatchId}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_dispatch_postback_info(self, dispatch_id, **kwargs):  # noqa: E501
        """Delete postback information from a Dispatch   # noqa: E501

        Clears the postback settings from the dispatch.  This causes the postback settings to inherit a value from a higher level (e.g. application).  If there is no setting at the application level, this will disable postbacks for the dispatch.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_dispatch_postback_info(dispatch_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str dispatch_id: Identifier for the dispatch (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_dispatch_postback_info_with_http_info(dispatch_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_dispatch_postback_info_with_http_info(dispatch_id, **kwargs)  # noqa: E501
            return data

    def delete_dispatch_postback_info_with_http_info(self, dispatch_id, **kwargs):  # noqa: E501
        """Delete postback information from a Dispatch   # noqa: E501

        Clears the postback settings from the dispatch.  This causes the postback settings to inherit a value from a higher level (e.g. application).  If there is no setting at the application level, this will disable postbacks for the dispatch.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_dispatch_postback_info_with_http_info(dispatch_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str dispatch_id: Identifier for the dispatch (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['dispatch_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_dispatch_postback_info" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'dispatch_id' is set
        if ('dispatch_id' not in params or
                params['dispatch_id'] is None):
            raise ValueError("Missing the required parameter `dispatch_id` when calling `delete_dispatch_postback_info`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'dispatch_id' in params:
            path_params['dispatchId'] = params['dispatch_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APP_NORMAL', 'OAUTH']  # noqa: E501

        return self.api_client.call_api(
            '/dispatch/dispatches/{dispatchId}/postback', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_dispatch_tags(self, dispatch_id, tags, **kwargs):  # noqa: E501
        """Delete tags from a Dispatch   # noqa: E501

        Deletes the specified tags from the dispatch.  Deleting tags that do not exist will still result in a success.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_dispatch_tags(dispatch_id, tags, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str dispatch_id: Identifier for the dispatch (required)
        :param TagListSchema tags: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_dispatch_tags_with_http_info(dispatch_id, tags, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_dispatch_tags_with_http_info(dispatch_id, tags, **kwargs)  # noqa: E501
            return data

    def delete_dispatch_tags_with_http_info(self, dispatch_id, tags, **kwargs):  # noqa: E501
        """Delete tags from a Dispatch   # noqa: E501

        Deletes the specified tags from the dispatch.  Deleting tags that do not exist will still result in a success.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_dispatch_tags_with_http_info(dispatch_id, tags, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str dispatch_id: Identifier for the dispatch (required)
        :param TagListSchema tags: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['dispatch_id', 'tags']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_dispatch_tags" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'dispatch_id' is set
        if ('dispatch_id' not in params or
                params['dispatch_id'] is None):
            raise ValueError("Missing the required parameter `dispatch_id` when calling `delete_dispatch_tags`")  # noqa: E501
        # verify the required parameter 'tags' is set
        if ('tags' not in params or
                params['tags'] is None):
            raise ValueError("Missing the required parameter `tags` when calling `delete_dispatch_tags`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'dispatch_id' in params:
            path_params['dispatchId'] = params['dispatch_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'tags' in params:
            body_params = params['tags']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APP_NORMAL', 'OAUTH']  # noqa: E501

        return self.api_client.call_api(
            '/dispatch/dispatches/{dispatchId}/tags', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_dispatches(self, **kwargs):  # noqa: E501
        """Delete a group of Dispatches   # noqa: E501

        Deletes the specified group of dispatches.  Can be filtered using the request parameters to provide a subset of results.  >**Caution:** >This will invalidate any existing dispatch packages, rendering them unlaunchable.  >**Note:** >One of the filter parameters (i.e. `courseId`, `since`/`until`, `tags`, or `filter`) needs to be provided.  This is to prevent accidental deletion of all dispatches.  If you do wish to update all dispatches, try setting the since parameter to a value prior to the creation of any dispatches.  >**Info:** >If using one of our client libraries, refer to its README for additional information on how to work with the `X-Total-Count` header.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_dispatches(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: Only retrieve resources having `courseId`
        :param datetime since: Filter by ISO 8601 TimeStamp inclusive (defaults to UTC)
        :param datetime until: Filter by ISO 8601 TimeStamp inclusive (defaults to UTC)
        :param str datetime_filter: Specifies field that `since` and `until` parameters are applied against
        :param list[str] tags: Filter items matching any tag provided (not all)
        :param str filter: Optional string which filters results by a specified field (described by filterBy).
        :param str filter_by: Optional enum parameter for specifying the field on which to run the filter. 
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_dispatches_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.delete_dispatches_with_http_info(**kwargs)  # noqa: E501
            return data

    def delete_dispatches_with_http_info(self, **kwargs):  # noqa: E501
        """Delete a group of Dispatches   # noqa: E501

        Deletes the specified group of dispatches.  Can be filtered using the request parameters to provide a subset of results.  >**Caution:** >This will invalidate any existing dispatch packages, rendering them unlaunchable.  >**Note:** >One of the filter parameters (i.e. `courseId`, `since`/`until`, `tags`, or `filter`) needs to be provided.  This is to prevent accidental deletion of all dispatches.  If you do wish to update all dispatches, try setting the since parameter to a value prior to the creation of any dispatches.  >**Info:** >If using one of our client libraries, refer to its README for additional information on how to work with the `X-Total-Count` header.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_dispatches_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: Only retrieve resources having `courseId`
        :param datetime since: Filter by ISO 8601 TimeStamp inclusive (defaults to UTC)
        :param datetime until: Filter by ISO 8601 TimeStamp inclusive (defaults to UTC)
        :param str datetime_filter: Specifies field that `since` and `until` parameters are applied against
        :param list[str] tags: Filter items matching any tag provided (not all)
        :param str filter: Optional string which filters results by a specified field (described by filterBy).
        :param str filter_by: Optional enum parameter for specifying the field on which to run the filter. 
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['course_id', 'since', 'until', 'datetime_filter', 'tags', 'filter', 'filter_by']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_dispatches" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'course_id' in params:
            query_params.append(('courseId', params['course_id']))  # noqa: E501
        if 'since' in params:
            query_params.append(('since', params['since']))  # noqa: E501
        if 'until' in params:
            query_params.append(('until', params['until']))  # noqa: E501
        if 'datetime_filter' in params:
            query_params.append(('datetimeFilter', params['datetime_filter']))  # noqa: E501
        if 'tags' in params:
            query_params.append(('tags', params['tags']))  # noqa: E501
            collection_formats['tags'] = 'csv'  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501
        if 'filter_by' in params:
            query_params.append(('filterBy', params['filter_by']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APP_NORMAL', 'OAUTH']  # noqa: E501

        return self.api_client.call_api(
            '/dispatch/dispatches', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def enable_registration_instancing(self, destination_id, enabled, **kwargs):  # noqa: E501
        """Update registration instancing status for a Destination's Dispatches   # noqa: E501

        Updates the restration instancing status for all dispatches distributed to the destination.  Registration instancing is the default for dispatches, in order to support versioning of dispatches.  A small portion of users may experience duplicate registrations with content dispatched to some LMS platforms.  If you happen to be dispatching content to an LMS with this issue, disabling registration instancing here will resolve the problems. However, dispatch versioning will also be disabled.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.enable_registration_instancing(destination_id, enabled, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str destination_id: Identifier for the destination (required)
        :param EnabledSchema enabled:  (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.enable_registration_instancing_with_http_info(destination_id, enabled, **kwargs)  # noqa: E501
        else:
            (data) = self.enable_registration_instancing_with_http_info(destination_id, enabled, **kwargs)  # noqa: E501
            return data

    def enable_registration_instancing_with_http_info(self, destination_id, enabled, **kwargs):  # noqa: E501
        """Update registration instancing status for a Destination's Dispatches   # noqa: E501

        Updates the restration instancing status for all dispatches distributed to the destination.  Registration instancing is the default for dispatches, in order to support versioning of dispatches.  A small portion of users may experience duplicate registrations with content dispatched to some LMS platforms.  If you happen to be dispatching content to an LMS with this issue, disabling registration instancing here will resolve the problems. However, dispatch versioning will also be disabled.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.enable_registration_instancing_with_http_info(destination_id, enabled, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str destination_id: Identifier for the destination (required)
        :param EnabledSchema enabled:  (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['destination_id', 'enabled']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method enable_registration_instancing" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'destination_id' is set
        if ('destination_id' not in params or
                params['destination_id'] is None):
            raise ValueError("Missing the required parameter `destination_id` when calling `enable_registration_instancing`")  # noqa: E501
        # verify the required parameter 'enabled' is set
        if ('enabled' not in params or
                params['enabled'] is None):
            raise ValueError("Missing the required parameter `enabled` when calling `enable_registration_instancing`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'destination_id' in params:
            path_params['destinationId'] = params['destination_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'enabled' in params:
            body_params = params['enabled']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APP_NORMAL', 'OAUTH']  # noqa: E501

        return self.api_client.call_api(
            '/dispatch/destinations/{destinationId}/dispatches/registrationInstancing', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_destination(self, destination_id, **kwargs):  # noqa: E501
        """Get detailed information about a Destination   # noqa: E501

        Returns detailed information about the destination.  This includes name, tags, and launchAuth information.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_destination(destination_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str destination_id: Identifier for the destination (required)
        :return: DestinationSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_destination_with_http_info(destination_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_destination_with_http_info(destination_id, **kwargs)  # noqa: E501
            return data

    def get_destination_with_http_info(self, destination_id, **kwargs):  # noqa: E501
        """Get detailed information about a Destination   # noqa: E501

        Returns detailed information about the destination.  This includes name, tags, and launchAuth information.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_destination_with_http_info(destination_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str destination_id: Identifier for the destination (required)
        :return: DestinationSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['destination_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_destination" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'destination_id' is set
        if ('destination_id' not in params or
                params['destination_id'] is None):
            raise ValueError("Missing the required parameter `destination_id` when calling `get_destination`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'destination_id' in params:
            path_params['destinationId'] = params['destination_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APP_NORMAL', 'OAUTH']  # noqa: E501

        return self.api_client.call_api(
            '/dispatch/destinations/{destinationId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DestinationSchema',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_destination_dispatch_registration_count(self, destination_id, **kwargs):  # noqa: E501
        """Get registration count for a Destination's Dispatches   # noqa: E501

        Returns the registration count for all dispatches distributed to the destination.  >**Note:** >The count here is a convenience counter.  Since it has the capability of being reset, it may not match the actual billed registration count for a dispatch.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_destination_dispatch_registration_count(destination_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str destination_id: Identifier for the destination (required)
        :return: IntegerResultSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_destination_dispatch_registration_count_with_http_info(destination_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_destination_dispatch_registration_count_with_http_info(destination_id, **kwargs)  # noqa: E501
            return data

    def get_destination_dispatch_registration_count_with_http_info(self, destination_id, **kwargs):  # noqa: E501
        """Get registration count for a Destination's Dispatches   # noqa: E501

        Returns the registration count for all dispatches distributed to the destination.  >**Note:** >The count here is a convenience counter.  Since it has the capability of being reset, it may not match the actual billed registration count for a dispatch.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_destination_dispatch_registration_count_with_http_info(destination_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str destination_id: Identifier for the destination (required)
        :return: IntegerResultSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['destination_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_destination_dispatch_registration_count" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'destination_id' is set
        if ('destination_id' not in params or
                params['destination_id'] is None):
            raise ValueError("Missing the required parameter `destination_id` when calling `get_destination_dispatch_registration_count`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'destination_id' in params:
            path_params['destinationId'] = params['destination_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APP_NORMAL', 'OAUTH']  # noqa: E501

        return self.api_client.call_api(
            '/dispatch/destinations/{destinationId}/dispatches/registrationCount', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='IntegerResultSchema',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_destination_dispatch_zip(self, destination_id, **kwargs):  # noqa: E501
        """Download a zip file for a Destination's Dispatches   # noqa: E501

        Downloads a zip file containing all of the dispatch packages for the destination.  A dispatch zip package is a distributable course stub which, upon launch in a third-party LMS, will reference and launch the underlying course in SCORM Cloud.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_destination_dispatch_zip(destination_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str destination_id: Identifier for the destination (required)
        :param str type: The type of dispatch package to export (SCORM_12 only supported in SCORM Cloud today)
        :param str css_url:
        :param list[str] tags: Filter items matching any tag provided (not all)
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_destination_dispatch_zip_with_http_info(destination_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_destination_dispatch_zip_with_http_info(destination_id, **kwargs)  # noqa: E501
            return data

    def get_destination_dispatch_zip_with_http_info(self, destination_id, **kwargs):  # noqa: E501
        """Download a zip file for a Destination's Dispatches   # noqa: E501

        Downloads a zip file containing all of the dispatch packages for the destination.  A dispatch zip package is a distributable course stub which, upon launch in a third-party LMS, will reference and launch the underlying course in SCORM Cloud.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_destination_dispatch_zip_with_http_info(destination_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str destination_id: Identifier for the destination (required)
        :param str type: The type of dispatch package to export (SCORM_12 only supported in SCORM Cloud today)
        :param str css_url:
        :param list[str] tags: Filter items matching any tag provided (not all)
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['destination_id', 'type', 'css_url', 'tags']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_destination_dispatch_zip" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'destination_id' is set
        if ('destination_id' not in params or
                params['destination_id'] is None):
            raise ValueError("Missing the required parameter `destination_id` when calling `get_destination_dispatch_zip`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'destination_id' in params:
            path_params['destinationId'] = params['destination_id']  # noqa: E501

        query_params = []
        if 'type' in params:
            query_params.append(('type', params['type']))  # noqa: E501
        if 'css_url' in params:
            query_params.append(('cssUrl', params['css_url']))  # noqa: E501
        if 'tags' in params:
            query_params.append(('tags', params['tags']))  # noqa: E501
            collection_formats['tags'] = 'csv'  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/zip'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APP_NORMAL', 'OAUTH']  # noqa: E501

        return self.api_client.call_api(
            '/dispatch/destinations/{destinationId}/dispatches/zip', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='file',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_destination_dispatches(self, destination_id, **kwargs):  # noqa: E501
        """Get a list of a Destination's Dispatches   # noqa: E501

        Returns a list of dispatches belonging to the destination.  Can be filtered using the request parameters to provide a subset of results.  Using the `courseId` filter should only ever yield 0 or 1 results, as a dispatch is the intersection of a course and a destination.  This can be useful for identifying if a certain course is dispatched to the destination.  >**Note:** >This request is paginated and will only provide a limited amount of resources at a time.  If there are more results to be collected, a `more` token provided with the response which can be passed to get the next page of results.  When passing this token, no other filter parameters can be sent as part of the request.  The resources will continue to respect the filters passed in by the original request.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_destination_dispatches(destination_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str destination_id: Identifier for the destination (required)
        :param str course_id: Only retrieve resources having `courseId`
        :param datetime since: Filter by ISO 8601 TimeStamp inclusive (defaults to UTC)
        :param datetime until: Filter by ISO 8601 TimeStamp inclusive (defaults to UTC)
        :param str datetime_filter: Specifies field that `since` and `until` parameters are applied against
        :param list[str] tags: Filter items matching any tag provided (not all)
        :param str filter: Optional string which filters results by a specified field (described by filterBy).
        :param str filter_by: Optional enum parameter for specifying the field on which to run the filter. 
        :param str order_by: Optional enum parameter for specifying the field and order by which to sort the results. 
        :param str more: Pagination token returned as `more` property of multi page list requests
        :param bool include_total_count: Include the total count of results matching the provided filters as a header on the initial request.  The header will not be present on subsequent requests resulting from passing the `more` token. 
        :return: DispatchListSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_destination_dispatches_with_http_info(destination_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_destination_dispatches_with_http_info(destination_id, **kwargs)  # noqa: E501
            return data

    def get_destination_dispatches_with_http_info(self, destination_id, **kwargs):  # noqa: E501
        """Get a list of a Destination's Dispatches   # noqa: E501

        Returns a list of dispatches belonging to the destination.  Can be filtered using the request parameters to provide a subset of results.  Using the `courseId` filter should only ever yield 0 or 1 results, as a dispatch is the intersection of a course and a destination.  This can be useful for identifying if a certain course is dispatched to the destination.  >**Note:** >This request is paginated and will only provide a limited amount of resources at a time.  If there are more results to be collected, a `more` token provided with the response which can be passed to get the next page of results.  When passing this token, no other filter parameters can be sent as part of the request.  The resources will continue to respect the filters passed in by the original request.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_destination_dispatches_with_http_info(destination_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str destination_id: Identifier for the destination (required)
        :param str course_id: Only retrieve resources having `courseId`
        :param datetime since: Filter by ISO 8601 TimeStamp inclusive (defaults to UTC)
        :param datetime until: Filter by ISO 8601 TimeStamp inclusive (defaults to UTC)
        :param str datetime_filter: Specifies field that `since` and `until` parameters are applied against
        :param list[str] tags: Filter items matching any tag provided (not all)
        :param str filter: Optional string which filters results by a specified field (described by filterBy).
        :param str filter_by: Optional enum parameter for specifying the field on which to run the filter. 
        :param str order_by: Optional enum parameter for specifying the field and order by which to sort the results. 
        :param str more: Pagination token returned as `more` property of multi page list requests
        :param bool include_total_count: Include the total count of results matching the provided filters as a header on the initial request.  The header will not be present on subsequent requests resulting from passing the `more` token. 
        :return: DispatchListSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['destination_id', 'course_id', 'since', 'until', 'datetime_filter', 'tags', 'filter', 'filter_by', 'order_by', 'more', 'include_total_count']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_destination_dispatches" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'destination_id' is set
        if ('destination_id' not in params or
                params['destination_id'] is None):
            raise ValueError("Missing the required parameter `destination_id` when calling `get_destination_dispatches`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'destination_id' in params:
            path_params['destinationId'] = params['destination_id']  # noqa: E501

        query_params = []
        if 'course_id' in params:
            query_params.append(('courseId', params['course_id']))  # noqa: E501
        if 'since' in params:
            query_params.append(('since', params['since']))  # noqa: E501
        if 'until' in params:
            query_params.append(('until', params['until']))  # noqa: E501
        if 'datetime_filter' in params:
            query_params.append(('datetimeFilter', params['datetime_filter']))  # noqa: E501
        if 'tags' in params:
            query_params.append(('tags', params['tags']))  # noqa: E501
            collection_formats['tags'] = 'csv'  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501
        if 'filter_by' in params:
            query_params.append(('filterBy', params['filter_by']))  # noqa: E501
        if 'order_by' in params:
            query_params.append(('orderBy', params['order_by']))  # noqa: E501
        if 'more' in params:
            query_params.append(('more', params['more']))  # noqa: E501
        if 'include_total_count' in params:
            query_params.append(('includeTotalCount', params['include_total_count']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APP_NORMAL', 'OAUTH']  # noqa: E501

        return self.api_client.call_api(
            '/dispatch/destinations/{destinationId}/dispatches', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DispatchListSchema',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_destination_hash_user_info(self, destination_id, **kwargs):  # noqa: E501
        """Get user PII hashing status for a Destination   # noqa: E501

        Returns whether or not user PII hashing is enabled for the destination.  Enabling it will cause all user PII to be hashed.  Hashing PII will anonymize the learner data from the dispatched course.  This will make looking up specific details about a learner difficult.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_destination_hash_user_info(destination_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str destination_id: Identifier for the destination (required)
        :return: EnabledSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_destination_hash_user_info_with_http_info(destination_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_destination_hash_user_info_with_http_info(destination_id, **kwargs)  # noqa: E501
            return data

    def get_destination_hash_user_info_with_http_info(self, destination_id, **kwargs):  # noqa: E501
        """Get user PII hashing status for a Destination   # noqa: E501

        Returns whether or not user PII hashing is enabled for the destination.  Enabling it will cause all user PII to be hashed.  Hashing PII will anonymize the learner data from the dispatched course.  This will make looking up specific details about a learner difficult.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_destination_hash_user_info_with_http_info(destination_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str destination_id: Identifier for the destination (required)
        :return: EnabledSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['destination_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_destination_hash_user_info" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'destination_id' is set
        if ('destination_id' not in params or
                params['destination_id'] is None):
            raise ValueError("Missing the required parameter `destination_id` when calling `get_destination_hash_user_info`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'destination_id' in params:
            path_params['destinationId'] = params['destination_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APP_NORMAL', 'OAUTH']  # noqa: E501

        return self.api_client.call_api(
            '/dispatch/destinations/{destinationId}/dispatches/hashUserInfo', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='EnabledSchema',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_destination_tags(self, destination_id, **kwargs):  # noqa: E501
        """Get tags for a Destination   # noqa: E501

        Returns the tags for the destination.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_destination_tags(destination_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str destination_id: Identifier for the destination (required)
        :return: TagListSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_destination_tags_with_http_info(destination_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_destination_tags_with_http_info(destination_id, **kwargs)  # noqa: E501
            return data

    def get_destination_tags_with_http_info(self, destination_id, **kwargs):  # noqa: E501
        """Get tags for a Destination   # noqa: E501

        Returns the tags for the destination.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_destination_tags_with_http_info(destination_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str destination_id: Identifier for the destination (required)
        :return: TagListSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['destination_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_destination_tags" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'destination_id' is set
        if ('destination_id' not in params or
                params['destination_id'] is None):
            raise ValueError("Missing the required parameter `destination_id` when calling `get_destination_tags`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'destination_id' in params:
            path_params['destinationId'] = params['destination_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APP_NORMAL', 'OAUTH']  # noqa: E501

        return self.api_client.call_api(
            '/dispatch/destinations/{destinationId}/tags', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TagListSchema',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_destinations(self, **kwargs):  # noqa: E501
        """Get a list of Destinations   # noqa: E501

        Returns a list of destinations.  Can be filtered using the request parameters to provide a subset of results.  >**Note:** >This request is paginated and will only provide a limited amount of resources at a time.  If there are more results to be collected, a `more` token provided with the response which can be passed to get the next page of results.  When passing this token, no other filter parameters can be sent as part of the request.  The resources will continue to respect the filters passed in by the original request.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_destinations(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: Only retrieve resources having `courseId`
        :param datetime since: Filter by ISO 8601 TimeStamp inclusive (defaults to UTC)
        :param datetime until: Filter by ISO 8601 TimeStamp inclusive (defaults to UTC)
        :param str datetime_filter: Specifies field that `since` and `until` parameters are applied against
        :param list[str] tags: Filter items matching any tag provided (not all)
        :param str filter: Optional string which filters results by a specified field (described by filterBy).
        :param str filter_by: Optional enum parameter for specifying the field on which to run the filter. 
        :param str order_by: Optional enum parameter for specifying the field and order by which to sort the results. 
        :param str more: Pagination token returned as `more` property of multi page list requests
        :param bool include_total_count: Include the total count of results matching the provided filters as a header on the initial request.  The header will not be present on subsequent requests resulting from passing the `more` token. 
        :return: DestinationListSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_destinations_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_destinations_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_destinations_with_http_info(self, **kwargs):  # noqa: E501
        """Get a list of Destinations   # noqa: E501

        Returns a list of destinations.  Can be filtered using the request parameters to provide a subset of results.  >**Note:** >This request is paginated and will only provide a limited amount of resources at a time.  If there are more results to be collected, a `more` token provided with the response which can be passed to get the next page of results.  When passing this token, no other filter parameters can be sent as part of the request.  The resources will continue to respect the filters passed in by the original request.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_destinations_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: Only retrieve resources having `courseId`
        :param datetime since: Filter by ISO 8601 TimeStamp inclusive (defaults to UTC)
        :param datetime until: Filter by ISO 8601 TimeStamp inclusive (defaults to UTC)
        :param str datetime_filter: Specifies field that `since` and `until` parameters are applied against
        :param list[str] tags: Filter items matching any tag provided (not all)
        :param str filter: Optional string which filters results by a specified field (described by filterBy).
        :param str filter_by: Optional enum parameter for specifying the field on which to run the filter. 
        :param str order_by: Optional enum parameter for specifying the field and order by which to sort the results. 
        :param str more: Pagination token returned as `more` property of multi page list requests
        :param bool include_total_count: Include the total count of results matching the provided filters as a header on the initial request.  The header will not be present on subsequent requests resulting from passing the `more` token. 
        :return: DestinationListSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['course_id', 'since', 'until', 'datetime_filter', 'tags', 'filter', 'filter_by', 'order_by', 'more', 'include_total_count']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_destinations" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'course_id' in params:
            query_params.append(('courseId', params['course_id']))  # noqa: E501
        if 'since' in params:
            query_params.append(('since', params['since']))  # noqa: E501
        if 'until' in params:
            query_params.append(('until', params['until']))  # noqa: E501
        if 'datetime_filter' in params:
            query_params.append(('datetimeFilter', params['datetime_filter']))  # noqa: E501
        if 'tags' in params:
            query_params.append(('tags', params['tags']))  # noqa: E501
            collection_formats['tags'] = 'csv'  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501
        if 'filter_by' in params:
            query_params.append(('filterBy', params['filter_by']))  # noqa: E501
        if 'order_by' in params:
            query_params.append(('orderBy', params['order_by']))  # noqa: E501
        if 'more' in params:
            query_params.append(('more', params['more']))  # noqa: E501
        if 'include_total_count' in params:
            query_params.append(('includeTotalCount', params['include_total_count']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APP_NORMAL', 'OAUTH']  # noqa: E501

        return self.api_client.call_api(
            '/dispatch/destinations', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DestinationListSchema',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_dispatch(self, dispatch_id, **kwargs):  # noqa: E501
        """Get detailed information about a Dispatch   # noqa: E501

        Returns detailed information about the dispatch.  This includes destination and course IDs, as well as registration count.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_dispatch(dispatch_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str dispatch_id: Identifier for the dispatch (required)
        :return: DispatchSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_dispatch_with_http_info(dispatch_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_dispatch_with_http_info(dispatch_id, **kwargs)  # noqa: E501
            return data

    def get_dispatch_with_http_info(self, dispatch_id, **kwargs):  # noqa: E501
        """Get detailed information about a Dispatch   # noqa: E501

        Returns detailed information about the dispatch.  This includes destination and course IDs, as well as registration count.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_dispatch_with_http_info(dispatch_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str dispatch_id: Identifier for the dispatch (required)
        :return: DispatchSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['dispatch_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_dispatch" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'dispatch_id' is set
        if ('dispatch_id' not in params or
                params['dispatch_id'] is None):
            raise ValueError("Missing the required parameter `dispatch_id` when calling `get_dispatch`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'dispatch_id' in params:
            path_params['dispatchId'] = params['dispatch_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APP_NORMAL', 'OAUTH']  # noqa: E501

        return self.api_client.call_api(
            '/dispatch/dispatches/{dispatchId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DispatchSchema',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_dispatch_enabled(self, dispatch_id, **kwargs):  # noqa: E501
        """Get enabled status of a Dispatch   # noqa: E501

        Returns the enabled status for the dispatch.  This is an access control measure allowing you to turn access to a previously distributed dispatch packages on or off.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_dispatch_enabled(dispatch_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str dispatch_id: Identifier for the dispatch (required)
        :return: EnabledSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_dispatch_enabled_with_http_info(dispatch_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_dispatch_enabled_with_http_info(dispatch_id, **kwargs)  # noqa: E501
            return data

    def get_dispatch_enabled_with_http_info(self, dispatch_id, **kwargs):  # noqa: E501
        """Get enabled status of a Dispatch   # noqa: E501

        Returns the enabled status for the dispatch.  This is an access control measure allowing you to turn access to a previously distributed dispatch packages on or off.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_dispatch_enabled_with_http_info(dispatch_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str dispatch_id: Identifier for the dispatch (required)
        :return: EnabledSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['dispatch_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_dispatch_enabled" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'dispatch_id' is set
        if ('dispatch_id' not in params or
                params['dispatch_id'] is None):
            raise ValueError("Missing the required parameter `dispatch_id` when calling `get_dispatch_enabled`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'dispatch_id' in params:
            path_params['dispatchId'] = params['dispatch_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APP_NORMAL', 'OAUTH']  # noqa: E501

        return self.api_client.call_api(
            '/dispatch/dispatches/{dispatchId}/enabled', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='EnabledSchema',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_dispatch_hash_user_info(self, dispatch_id, **kwargs):  # noqa: E501
        """Get user PII hashing status for a Dispatch   # noqa: E501

        Returns whether or not user PII hashing is enabled for the dispatch.  Enabling it will cause all user PII to be hashed.  Hashing PII will anonymize the learner data from the dispatched course.  This will make looking up specific details about a learner difficult.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_dispatch_hash_user_info(dispatch_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str dispatch_id: Identifier for the dispatch (required)
        :return: EnabledSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_dispatch_hash_user_info_with_http_info(dispatch_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_dispatch_hash_user_info_with_http_info(dispatch_id, **kwargs)  # noqa: E501
            return data

    def get_dispatch_hash_user_info_with_http_info(self, dispatch_id, **kwargs):  # noqa: E501
        """Get user PII hashing status for a Dispatch   # noqa: E501

        Returns whether or not user PII hashing is enabled for the dispatch.  Enabling it will cause all user PII to be hashed.  Hashing PII will anonymize the learner data from the dispatched course.  This will make looking up specific details about a learner difficult.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_dispatch_hash_user_info_with_http_info(dispatch_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str dispatch_id: Identifier for the dispatch (required)
        :return: EnabledSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['dispatch_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_dispatch_hash_user_info" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'dispatch_id' is set
        if ('dispatch_id' not in params or
                params['dispatch_id'] is None):
            raise ValueError("Missing the required parameter `dispatch_id` when calling `get_dispatch_hash_user_info`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'dispatch_id' in params:
            path_params['dispatchId'] = params['dispatch_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APP_NORMAL', 'OAUTH']  # noqa: E501

        return self.api_client.call_api(
            '/dispatch/dispatches/{dispatchId}/hashUserInfo', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='EnabledSchema',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_dispatch_registration_count(self, dispatch_id, **kwargs):  # noqa: E501
        """Get registration count for a Dispatch   # noqa: E501

        Returns the registration count for the dispatch, as well as the date and time of the last count reset, if any.  >**Note:** >The count here is a convenience counter.  Since it has the capability of being reset, it may not match the actual billed registration count for a dispatch.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_dispatch_registration_count(dispatch_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str dispatch_id: Identifier for the dispatch (required)
        :return: DispatchRegistrationCountSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_dispatch_registration_count_with_http_info(dispatch_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_dispatch_registration_count_with_http_info(dispatch_id, **kwargs)  # noqa: E501
            return data

    def get_dispatch_registration_count_with_http_info(self, dispatch_id, **kwargs):  # noqa: E501
        """Get registration count for a Dispatch   # noqa: E501

        Returns the registration count for the dispatch, as well as the date and time of the last count reset, if any.  >**Note:** >The count here is a convenience counter.  Since it has the capability of being reset, it may not match the actual billed registration count for a dispatch.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_dispatch_registration_count_with_http_info(dispatch_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str dispatch_id: Identifier for the dispatch (required)
        :return: DispatchRegistrationCountSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['dispatch_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_dispatch_registration_count" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'dispatch_id' is set
        if ('dispatch_id' not in params or
                params['dispatch_id'] is None):
            raise ValueError("Missing the required parameter `dispatch_id` when calling `get_dispatch_registration_count`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'dispatch_id' in params:
            path_params['dispatchId'] = params['dispatch_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APP_NORMAL', 'OAUTH']  # noqa: E501

        return self.api_client.call_api(
            '/dispatch/dispatches/{dispatchId}/registrationCount', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DispatchRegistrationCountSchema',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_dispatch_tags(self, dispatch_id, **kwargs):  # noqa: E501
        """Get tags for a Dispatch   # noqa: E501

        Returns the tags for the dispatch.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_dispatch_tags(dispatch_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str dispatch_id: Identifier for the dispatch (required)
        :return: TagListSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_dispatch_tags_with_http_info(dispatch_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_dispatch_tags_with_http_info(dispatch_id, **kwargs)  # noqa: E501
            return data

    def get_dispatch_tags_with_http_info(self, dispatch_id, **kwargs):  # noqa: E501
        """Get tags for a Dispatch   # noqa: E501

        Returns the tags for the dispatch.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_dispatch_tags_with_http_info(dispatch_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str dispatch_id: Identifier for the dispatch (required)
        :return: TagListSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['dispatch_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_dispatch_tags" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'dispatch_id' is set
        if ('dispatch_id' not in params or
                params['dispatch_id'] is None):
            raise ValueError("Missing the required parameter `dispatch_id` when calling `get_dispatch_tags`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'dispatch_id' in params:
            path_params['dispatchId'] = params['dispatch_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APP_NORMAL', 'OAUTH']  # noqa: E501

        return self.api_client.call_api(
            '/dispatch/dispatches/{dispatchId}/tags', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TagListSchema',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_dispatch_zip(self, dispatch_id, **kwargs):  # noqa: E501
        """Download a zip package for a Dispatch   # noqa: E501

        Downloads a zip package for the dispatch.  A dispatch zip package is a distributable course stub which, upon launch in a third-party LMS, will reference and launch the underlying course in SCORM Cloud. As an extension, dispatches allow for limiting access control even after the zip file has been given to the destination.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_dispatch_zip(dispatch_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str dispatch_id: Identifier for the dispatch (required)
        :param str type: The type of dispatch package to export (currently only SCORM_12 available)
        :param str css_url: Custom CSS to apply to the dispatch package
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_dispatch_zip_with_http_info(dispatch_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_dispatch_zip_with_http_info(dispatch_id, **kwargs)  # noqa: E501
            return data

    def get_dispatch_zip_with_http_info(self, dispatch_id, **kwargs):  # noqa: E501
        """Download a zip package for a Dispatch   # noqa: E501

        Downloads a zip package for the dispatch.  A dispatch zip package is a distributable course stub which, upon launch in a third-party LMS, will reference and launch the underlying course in SCORM Cloud. As an extension, dispatches allow for limiting access control even after the zip file has been given to the destination.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_dispatch_zip_with_http_info(dispatch_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str dispatch_id: Identifier for the dispatch (required)
        :param str type: The type of dispatch package to export (currently only SCORM_12 available)
        :param str css_url: Custom CSS to apply to the dispatch package
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['dispatch_id', 'type', 'css_url']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_dispatch_zip" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'dispatch_id' is set
        if ('dispatch_id' not in params or
                params['dispatch_id'] is None):
            raise ValueError("Missing the required parameter `dispatch_id` when calling `get_dispatch_zip`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'dispatch_id' in params:
            path_params['dispatchId'] = params['dispatch_id']  # noqa: E501

        query_params = []
        if 'type' in params:
            query_params.append(('type', params['type']))  # noqa: E501
        if 'css_url' in params:
            query_params.append(('cssUrl', params['css_url']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/zip'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APP_NORMAL', 'OAUTH']  # noqa: E501

        return self.api_client.call_api(
            '/dispatch/dispatches/{dispatchId}/zip', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='file',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_dispatches(self, **kwargs):  # noqa: E501
        """Get a list of Dispatches   # noqa: E501

        Returns a list of dispatches.  Can be filtered using the request parameters to provide a subset of results.  Using the `courseId` filter will allow for viewing which destinations the course has been dispatched to.  >**Note:** >This request is paginated and will only provide a limited amount of resources at a time.  If there are more results to be collected, a `more` token provided with the response which can be passed to get the next page of results.  When passing this token, no other filter parameters can be sent as part of the request.  The resources will continue to respect the filters passed in by the original request.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_dispatches(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: Only retrieve resources having `courseId`
        :param datetime since: Filter by ISO 8601 TimeStamp inclusive (defaults to UTC)
        :param datetime until: Filter by ISO 8601 TimeStamp inclusive (defaults to UTC)
        :param str datetime_filter: Specifies field that `since` and `until` parameters are applied against
        :param list[str] tags: Filter items matching any tag provided (not all)
        :param str filter: Optional string which filters results by a specified field (described by filterBy).
        :param str filter_by: Optional enum parameter for specifying the field on which to run the filter. 
        :param str order_by: Optional enum parameter for specifying the field and order by which to sort the results. 
        :param str more: Pagination token returned as `more` property of multi page list requests
        :param bool include_total_count: Include the total count of results matching the provided filters as a header on the initial request.  The header will not be present on subsequent requests resulting from passing the `more` token. 
        :return: DispatchListSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_dispatches_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_dispatches_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_dispatches_with_http_info(self, **kwargs):  # noqa: E501
        """Get a list of Dispatches   # noqa: E501

        Returns a list of dispatches.  Can be filtered using the request parameters to provide a subset of results.  Using the `courseId` filter will allow for viewing which destinations the course has been dispatched to.  >**Note:** >This request is paginated and will only provide a limited amount of resources at a time.  If there are more results to be collected, a `more` token provided with the response which can be passed to get the next page of results.  When passing this token, no other filter parameters can be sent as part of the request.  The resources will continue to respect the filters passed in by the original request.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_dispatches_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str course_id: Only retrieve resources having `courseId`
        :param datetime since: Filter by ISO 8601 TimeStamp inclusive (defaults to UTC)
        :param datetime until: Filter by ISO 8601 TimeStamp inclusive (defaults to UTC)
        :param str datetime_filter: Specifies field that `since` and `until` parameters are applied against
        :param list[str] tags: Filter items matching any tag provided (not all)
        :param str filter: Optional string which filters results by a specified field (described by filterBy).
        :param str filter_by: Optional enum parameter for specifying the field on which to run the filter. 
        :param str order_by: Optional enum parameter for specifying the field and order by which to sort the results. 
        :param str more: Pagination token returned as `more` property of multi page list requests
        :param bool include_total_count: Include the total count of results matching the provided filters as a header on the initial request.  The header will not be present on subsequent requests resulting from passing the `more` token. 
        :return: DispatchListSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['course_id', 'since', 'until', 'datetime_filter', 'tags', 'filter', 'filter_by', 'order_by', 'more', 'include_total_count']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_dispatches" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'course_id' in params:
            query_params.append(('courseId', params['course_id']))  # noqa: E501
        if 'since' in params:
            query_params.append(('since', params['since']))  # noqa: E501
        if 'until' in params:
            query_params.append(('until', params['until']))  # noqa: E501
        if 'datetime_filter' in params:
            query_params.append(('datetimeFilter', params['datetime_filter']))  # noqa: E501
        if 'tags' in params:
            query_params.append(('tags', params['tags']))  # noqa: E501
            collection_formats['tags'] = 'csv'  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501
        if 'filter_by' in params:
            query_params.append(('filterBy', params['filter_by']))  # noqa: E501
        if 'order_by' in params:
            query_params.append(('orderBy', params['order_by']))  # noqa: E501
        if 'more' in params:
            query_params.append(('more', params['more']))  # noqa: E501
        if 'include_total_count' in params:
            query_params.append(('includeTotalCount', params['include_total_count']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APP_NORMAL', 'OAUTH']  # noqa: E501

        return self.api_client.call_api(
            '/dispatch/dispatches', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DispatchListSchema',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_lti13_dispatch(self, dispatch_id, **kwargs):  # noqa: E501
        """Get the information necessary to import this dispatch as a resource link according to the IMS LTI 1.3 specification.   # noqa: E501

        Get the information necessary to import this dispatch as a resource link according to the IMS LTI 1.3 specification. The information from this call will be provided to the platform during the configuration step.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_lti13_dispatch(dispatch_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str dispatch_id: Identifier for the dispatch (required)
        :return: DispatchLti13InfoSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_lti13_dispatch_with_http_info(dispatch_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_lti13_dispatch_with_http_info(dispatch_id, **kwargs)  # noqa: E501
            return data

    def get_lti13_dispatch_with_http_info(self, dispatch_id, **kwargs):  # noqa: E501
        """Get the information necessary to import this dispatch as a resource link according to the IMS LTI 1.3 specification.   # noqa: E501

        Get the information necessary to import this dispatch as a resource link according to the IMS LTI 1.3 specification. The information from this call will be provided to the platform during the configuration step.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_lti13_dispatch_with_http_info(dispatch_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str dispatch_id: Identifier for the dispatch (required)
        :return: DispatchLti13InfoSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['dispatch_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_lti13_dispatch" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'dispatch_id' is set
        if ('dispatch_id' not in params or
                params['dispatch_id'] is None):
            raise ValueError("Missing the required parameter `dispatch_id` when calling `get_lti13_dispatch`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'dispatch_id' in params:
            path_params['dispatchId'] = params['dispatch_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APP_NORMAL', 'OAUTH']  # noqa: E501

        return self.api_client.call_api(
            '/dispatch/dispatches/{dispatchId}/lti13', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DispatchLti13InfoSchema',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_lti13_dispatch_launch(self, dispatch_id, external_config, jwt, **kwargs):  # noqa: E501
        """Launch this dispatch using the IMS LTI 1.3 specification.   # noqa: E501

        Launch this dispatch using the IMS LTI 1.3 specification. This is the final step in the LTI 1.3 launch process, and is the request that redirects to the resource link (i.e. course).   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_lti13_dispatch_launch(dispatch_id, external_config, jwt, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str dispatch_id: Identifier for the dispatch (required)
        :param str external_config: External configuration object (required)
        :param str jwt: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_lti13_dispatch_launch_with_http_info(dispatch_id, external_config, jwt, **kwargs)  # noqa: E501
        else:
            (data) = self.get_lti13_dispatch_launch_with_http_info(dispatch_id, external_config, jwt, **kwargs)  # noqa: E501
            return data

    def get_lti13_dispatch_launch_with_http_info(self, dispatch_id, external_config, jwt, **kwargs):  # noqa: E501
        """Launch this dispatch using the IMS LTI 1.3 specification.   # noqa: E501

        Launch this dispatch using the IMS LTI 1.3 specification. This is the final step in the LTI 1.3 launch process, and is the request that redirects to the resource link (i.e. course).   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_lti13_dispatch_launch_with_http_info(dispatch_id, external_config, jwt, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str dispatch_id: Identifier for the dispatch (required)
        :param str external_config: External configuration object (required)
        :param str jwt: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['dispatch_id', 'external_config', 'jwt']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_lti13_dispatch_launch" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'dispatch_id' is set
        if ('dispatch_id' not in params or
                params['dispatch_id'] is None):
            raise ValueError("Missing the required parameter `dispatch_id` when calling `get_lti13_dispatch_launch`")  # noqa: E501
        # verify the required parameter 'external_config' is set
        if ('external_config' not in params or
                params['external_config'] is None):
            raise ValueError("Missing the required parameter `external_config` when calling `get_lti13_dispatch_launch`")  # noqa: E501
        # verify the required parameter 'jwt' is set
        if ('jwt' not in params or
                params['jwt'] is None):
            raise ValueError("Missing the required parameter `jwt` when calling `get_lti13_dispatch_launch`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'dispatch_id' in params:
            path_params['dispatchId'] = params['dispatch_id']  # noqa: E501

        query_params = []
        if 'external_config' in params:
            query_params.append(('externalConfig', params['external_config']))  # noqa: E501
        if 'jwt' in params:
            query_params.append(('jwt', params['jwt']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/dispatch/dispatches/{dispatchId}/launches', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_lti13_tool_configuration_schema(self, destination_id, **kwargs):  # noqa: E501
        """Get the information needed to configure a LTI 1.3 platform with the destination id `destinationId`   # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_lti13_tool_configuration_schema(destination_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str destination_id: Identifier for the destination (required)
        :return: Lti13ToolConfigurationSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_lti13_tool_configuration_schema_with_http_info(destination_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_lti13_tool_configuration_schema_with_http_info(destination_id, **kwargs)  # noqa: E501
            return data

    def get_lti13_tool_configuration_schema_with_http_info(self, destination_id, **kwargs):  # noqa: E501
        """Get the information needed to configure a LTI 1.3 platform with the destination id `destinationId`   # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_lti13_tool_configuration_schema_with_http_info(destination_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str destination_id: Identifier for the destination (required)
        :return: Lti13ToolConfigurationSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['destination_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_lti13_tool_configuration_schema" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'destination_id' is set
        if ('destination_id' not in params or
                params['destination_id'] is None):
            raise ValueError("Missing the required parameter `destination_id` when calling `get_lti13_tool_configuration_schema`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'destination_id' in params:
            path_params['destinationId'] = params['destination_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APP_NORMAL', 'OAUTH']  # noqa: E501

        return self.api_client.call_api(
            '/dispatch/destinations/{destinationId}/lti13', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Lti13ToolConfigurationSchema',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_lti_dispatch(self, dispatch_id, **kwargs):  # noqa: E501
        """Get the information necessary to launch this dispatch using the IMS LTI 1.1 specification.   # noqa: E501

        Retrieve the information needed to launch this dispatch using the IMS LTI 1.1 specification. This information is then provided to the platform so it can launch this dispatch.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_lti_dispatch(dispatch_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str dispatch_id: Identifier for the dispatch (required)
        :return: DispatchLtiInfoSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_lti_dispatch_with_http_info(dispatch_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_lti_dispatch_with_http_info(dispatch_id, **kwargs)  # noqa: E501
            return data

    def get_lti_dispatch_with_http_info(self, dispatch_id, **kwargs):  # noqa: E501
        """Get the information necessary to launch this dispatch using the IMS LTI 1.1 specification.   # noqa: E501

        Retrieve the information needed to launch this dispatch using the IMS LTI 1.1 specification. This information is then provided to the platform so it can launch this dispatch.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_lti_dispatch_with_http_info(dispatch_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str dispatch_id: Identifier for the dispatch (required)
        :return: DispatchLtiInfoSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['dispatch_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_lti_dispatch" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'dispatch_id' is set
        if ('dispatch_id' not in params or
                params['dispatch_id'] is None):
            raise ValueError("Missing the required parameter `dispatch_id` when calling `get_lti_dispatch`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'dispatch_id' in params:
            path_params['dispatchId'] = params['dispatch_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APP_NORMAL', 'OAUTH']  # noqa: E501

        return self.api_client.call_api(
            '/dispatch/dispatches/{dispatchId}/lti', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DispatchLtiInfoSchema',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def put_destination_tags(self, destination_id, tags, **kwargs):  # noqa: E501
        """Add tags to a Destination   # noqa: E501

        Applies the provided tags to the destination.  Tags are used to easily identify resources.  Adding tags can enable more refined searches when making calls to certain endpoints (e.g. GetDestinations).   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_destination_tags(destination_id, tags, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str destination_id: Identifier for the destination (required)
        :param TagListSchema tags: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.put_destination_tags_with_http_info(destination_id, tags, **kwargs)  # noqa: E501
        else:
            (data) = self.put_destination_tags_with_http_info(destination_id, tags, **kwargs)  # noqa: E501
            return data

    def put_destination_tags_with_http_info(self, destination_id, tags, **kwargs):  # noqa: E501
        """Add tags to a Destination   # noqa: E501

        Applies the provided tags to the destination.  Tags are used to easily identify resources.  Adding tags can enable more refined searches when making calls to certain endpoints (e.g. GetDestinations).   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_destination_tags_with_http_info(destination_id, tags, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str destination_id: Identifier for the destination (required)
        :param TagListSchema tags: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['destination_id', 'tags']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_destination_tags" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'destination_id' is set
        if ('destination_id' not in params or
                params['destination_id'] is None):
            raise ValueError("Missing the required parameter `destination_id` when calling `put_destination_tags`")  # noqa: E501
        # verify the required parameter 'tags' is set
        if ('tags' not in params or
                params['tags'] is None):
            raise ValueError("Missing the required parameter `tags` when calling `put_destination_tags`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'destination_id' in params:
            path_params['destinationId'] = params['destination_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'tags' in params:
            body_params = params['tags']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APP_NORMAL', 'OAUTH']  # noqa: E501

        return self.api_client.call_api(
            '/dispatch/destinations/{destinationId}/tags', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def put_destination_tags_batch(self, batch, **kwargs):  # noqa: E501
        """Add a group of tags to a group of Destinations   # noqa: E501

        Applies all of the provided tags on all of the provided destinations.  Tags are used to easily identify resources. Adding tags can enable more refined searches when making calls to certain endpoints (e.g. GetDestinations).   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_destination_tags_batch(batch, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param BatchTagsSchema batch: Array of ids, and array of tags for bulk tag operations (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.put_destination_tags_batch_with_http_info(batch, **kwargs)  # noqa: E501
        else:
            (data) = self.put_destination_tags_batch_with_http_info(batch, **kwargs)  # noqa: E501
            return data

    def put_destination_tags_batch_with_http_info(self, batch, **kwargs):  # noqa: E501
        """Add a group of tags to a group of Destinations   # noqa: E501

        Applies all of the provided tags on all of the provided destinations.  Tags are used to easily identify resources. Adding tags can enable more refined searches when making calls to certain endpoints (e.g. GetDestinations).   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_destination_tags_batch_with_http_info(batch, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param BatchTagsSchema batch: Array of ids, and array of tags for bulk tag operations (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['batch']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_destination_tags_batch" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'batch' is set
        if ('batch' not in params or
                params['batch'] is None):
            raise ValueError("Missing the required parameter `batch` when calling `put_destination_tags_batch`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'batch' in params:
            body_params = params['batch']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APP_NORMAL', 'OAUTH']  # noqa: E501

        return self.api_client.call_api(
            '/dispatch/destinations/tags', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def put_dispatch_tags(self, dispatch_id, tags, **kwargs):  # noqa: E501
        """Add tags to a Dispatch   # noqa: E501

        Applies the provided tags to the dispatch.  Tags are used to easily identify resources.  Adding tags can enable more refined searches when making calls to certain endpoints (e.g. GetDispatches).   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_dispatch_tags(dispatch_id, tags, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str dispatch_id: Identifier for the dispatch (required)
        :param TagListSchema tags: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.put_dispatch_tags_with_http_info(dispatch_id, tags, **kwargs)  # noqa: E501
        else:
            (data) = self.put_dispatch_tags_with_http_info(dispatch_id, tags, **kwargs)  # noqa: E501
            return data

    def put_dispatch_tags_with_http_info(self, dispatch_id, tags, **kwargs):  # noqa: E501
        """Add tags to a Dispatch   # noqa: E501

        Applies the provided tags to the dispatch.  Tags are used to easily identify resources.  Adding tags can enable more refined searches when making calls to certain endpoints (e.g. GetDispatches).   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_dispatch_tags_with_http_info(dispatch_id, tags, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str dispatch_id: Identifier for the dispatch (required)
        :param TagListSchema tags: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['dispatch_id', 'tags']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_dispatch_tags" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'dispatch_id' is set
        if ('dispatch_id' not in params or
                params['dispatch_id'] is None):
            raise ValueError("Missing the required parameter `dispatch_id` when calling `put_dispatch_tags`")  # noqa: E501
        # verify the required parameter 'tags' is set
        if ('tags' not in params or
                params['tags'] is None):
            raise ValueError("Missing the required parameter `tags` when calling `put_dispatch_tags`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'dispatch_id' in params:
            path_params['dispatchId'] = params['dispatch_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'tags' in params:
            body_params = params['tags']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APP_NORMAL', 'OAUTH']  # noqa: E501

        return self.api_client.call_api(
            '/dispatch/dispatches/{dispatchId}/tags', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def put_dispatch_tags_batch(self, batch, **kwargs):  # noqa: E501
        """Add a group of tags to a group of Dispatches   # noqa: E501

        Applies all of the provided tags on all of the provided dispatches.  Tags are used to easily identify resources. Adding tags can enable more refined searches when making calls to certain endpoints (e.g. GetDispatches).   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_dispatch_tags_batch(batch, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param BatchTagsSchema batch: Array of ids, and array of tags for bulk tag operations (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.put_dispatch_tags_batch_with_http_info(batch, **kwargs)  # noqa: E501
        else:
            (data) = self.put_dispatch_tags_batch_with_http_info(batch, **kwargs)  # noqa: E501
            return data

    def put_dispatch_tags_batch_with_http_info(self, batch, **kwargs):  # noqa: E501
        """Add a group of tags to a group of Dispatches   # noqa: E501

        Applies all of the provided tags on all of the provided dispatches.  Tags are used to easily identify resources. Adding tags can enable more refined searches when making calls to certain endpoints (e.g. GetDispatches).   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_dispatch_tags_batch_with_http_info(batch, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param BatchTagsSchema batch: Array of ids, and array of tags for bulk tag operations (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['batch']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_dispatch_tags_batch" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'batch' is set
        if ('batch' not in params or
                params['batch'] is None):
            raise ValueError("Missing the required parameter `batch` when calling `put_dispatch_tags_batch`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'batch' in params:
            body_params = params['batch']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APP_NORMAL', 'OAUTH']  # noqa: E501

        return self.api_client.call_api(
            '/dispatch/dispatches/tags', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def reset_destination_dispatch_registration_count(self, destination_id, **kwargs):  # noqa: E501
        """Reset registration counts for a Destination's Dispatches   # noqa: E501

        Clears the registration count for all dispatches distributed to the destination.  This resets the registration counter on the dispatch itself, but has no effect on the existing registrations.  Can be used in situations where the license for the course material has been renewed.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.reset_destination_dispatch_registration_count(destination_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str destination_id: Identifier for the destination (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.reset_destination_dispatch_registration_count_with_http_info(destination_id, **kwargs)  # noqa: E501
        else:
            (data) = self.reset_destination_dispatch_registration_count_with_http_info(destination_id, **kwargs)  # noqa: E501
            return data

    def reset_destination_dispatch_registration_count_with_http_info(self, destination_id, **kwargs):  # noqa: E501
        """Reset registration counts for a Destination's Dispatches   # noqa: E501

        Clears the registration count for all dispatches distributed to the destination.  This resets the registration counter on the dispatch itself, but has no effect on the existing registrations.  Can be used in situations where the license for the course material has been renewed.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.reset_destination_dispatch_registration_count_with_http_info(destination_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str destination_id: Identifier for the destination (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['destination_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method reset_destination_dispatch_registration_count" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'destination_id' is set
        if ('destination_id' not in params or
                params['destination_id'] is None):
            raise ValueError("Missing the required parameter `destination_id` when calling `reset_destination_dispatch_registration_count`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'destination_id' in params:
            path_params['destinationId'] = params['destination_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APP_NORMAL', 'OAUTH']  # noqa: E501

        return self.api_client.call_api(
            '/dispatch/destinations/{destinationId}/dispatches/registrationCount', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def reset_dispatch_registration_count(self, dispatch_id, **kwargs):  # noqa: E501
        """Reset registration count for a Dispatch   # noqa: E501

        Clears the registration count for the dispatch.  This resets the registration counter on the dispatch itself, but has no effect on the existing registrations.  Can be used in situations where the license for the course material has been renewed.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.reset_dispatch_registration_count(dispatch_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str dispatch_id: Identifier for the dispatch (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.reset_dispatch_registration_count_with_http_info(dispatch_id, **kwargs)  # noqa: E501
        else:
            (data) = self.reset_dispatch_registration_count_with_http_info(dispatch_id, **kwargs)  # noqa: E501
            return data

    def reset_dispatch_registration_count_with_http_info(self, dispatch_id, **kwargs):  # noqa: E501
        """Reset registration count for a Dispatch   # noqa: E501

        Clears the registration count for the dispatch.  This resets the registration counter on the dispatch itself, but has no effect on the existing registrations.  Can be used in situations where the license for the course material has been renewed.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.reset_dispatch_registration_count_with_http_info(dispatch_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str dispatch_id: Identifier for the dispatch (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['dispatch_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method reset_dispatch_registration_count" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'dispatch_id' is set
        if ('dispatch_id' not in params or
                params['dispatch_id'] is None):
            raise ValueError("Missing the required parameter `dispatch_id` when calling `reset_dispatch_registration_count`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'dispatch_id' in params:
            path_params['dispatchId'] = params['dispatch_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APP_NORMAL', 'OAUTH']  # noqa: E501

        return self.api_client.call_api(
            '/dispatch/dispatches/{dispatchId}/registrationCount', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def set_destination(self, destination_id, destination, **kwargs):  # noqa: E501
        """Create or update a Destination   # noqa: E501

        Creates or updates information about the destination.  -If the destination is being created, a name should be provided in the DestinationSchema.  If one is not present in the request an error will be thrown. -If the destination is instead being updated, only non-null values that are provided will be updated.  You may also optionally supply the e-mail address of the user to be associated with this destination.  This e-mail address should correspond to a SCORM Cloud user account.  >**Note:** >While the \"updated\" and \"created\" values are present in the destination schema, any attempts to manually change those values with SetDestination will be ignored.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_destination(destination_id, destination, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str destination_id: Identifier for the destination (required)
        :param DestinationSchema destination: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.set_destination_with_http_info(destination_id, destination, **kwargs)  # noqa: E501
        else:
            (data) = self.set_destination_with_http_info(destination_id, destination, **kwargs)  # noqa: E501
            return data

    def set_destination_with_http_info(self, destination_id, destination, **kwargs):  # noqa: E501
        """Create or update a Destination   # noqa: E501

        Creates or updates information about the destination.  -If the destination is being created, a name should be provided in the DestinationSchema.  If one is not present in the request an error will be thrown. -If the destination is instead being updated, only non-null values that are provided will be updated.  You may also optionally supply the e-mail address of the user to be associated with this destination.  This e-mail address should correspond to a SCORM Cloud user account.  >**Note:** >While the \"updated\" and \"created\" values are present in the destination schema, any attempts to manually change those values with SetDestination will be ignored.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_destination_with_http_info(destination_id, destination, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str destination_id: Identifier for the destination (required)
        :param DestinationSchema destination: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['destination_id', 'destination']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method set_destination" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'destination_id' is set
        if ('destination_id' not in params or
                params['destination_id'] is None):
            raise ValueError("Missing the required parameter `destination_id` when calling `set_destination`")  # noqa: E501
        # verify the required parameter 'destination' is set
        if ('destination' not in params or
                params['destination'] is None):
            raise ValueError("Missing the required parameter `destination` when calling `set_destination`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'destination_id' in params:
            path_params['destinationId'] = params['destination_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'destination' in params:
            body_params = params['destination']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APP_NORMAL', 'OAUTH']  # noqa: E501

        return self.api_client.call_api(
            '/dispatch/destinations/{destinationId}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def set_destination_dispatch_enabled(self, destination_id, enabled, **kwargs):  # noqa: E501
        """Update enabled status for a Destination's Dispatches   # noqa: E501

        Updates the enabled status for all dispatches distributed to the destination.  This is an access control measure allowing you to turn access to a previously distributed dispatch packages on or off.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_destination_dispatch_enabled(destination_id, enabled, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str destination_id: Identifier for the destination (required)
        :param EnabledSchema enabled:  (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.set_destination_dispatch_enabled_with_http_info(destination_id, enabled, **kwargs)  # noqa: E501
        else:
            (data) = self.set_destination_dispatch_enabled_with_http_info(destination_id, enabled, **kwargs)  # noqa: E501
            return data

    def set_destination_dispatch_enabled_with_http_info(self, destination_id, enabled, **kwargs):  # noqa: E501
        """Update enabled status for a Destination's Dispatches   # noqa: E501

        Updates the enabled status for all dispatches distributed to the destination.  This is an access control measure allowing you to turn access to a previously distributed dispatch packages on or off.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_destination_dispatch_enabled_with_http_info(destination_id, enabled, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str destination_id: Identifier for the destination (required)
        :param EnabledSchema enabled:  (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['destination_id', 'enabled']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method set_destination_dispatch_enabled" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'destination_id' is set
        if ('destination_id' not in params or
                params['destination_id'] is None):
            raise ValueError("Missing the required parameter `destination_id` when calling `set_destination_dispatch_enabled`")  # noqa: E501
        # verify the required parameter 'enabled' is set
        if ('enabled' not in params or
                params['enabled'] is None):
            raise ValueError("Missing the required parameter `enabled` when calling `set_destination_dispatch_enabled`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'destination_id' in params:
            path_params['destinationId'] = params['destination_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'enabled' in params:
            body_params = params['enabled']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APP_NORMAL', 'OAUTH']  # noqa: E501

        return self.api_client.call_api(
            '/dispatch/destinations/{destinationId}/dispatches/enabled', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def set_dispatch_enabled(self, dispatch_id, enabled, **kwargs):  # noqa: E501
        """Update enabled status for a Dispatch   # noqa: E501

        Updates the enabled status for the dispatch.  This is an access control measure allowing you to turn access to a previously distributed dispatch packages on or off.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_dispatch_enabled(dispatch_id, enabled, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str dispatch_id: Identifier for the dispatch (required)
        :param EnabledSchema enabled:  (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.set_dispatch_enabled_with_http_info(dispatch_id, enabled, **kwargs)  # noqa: E501
        else:
            (data) = self.set_dispatch_enabled_with_http_info(dispatch_id, enabled, **kwargs)  # noqa: E501
            return data

    def set_dispatch_enabled_with_http_info(self, dispatch_id, enabled, **kwargs):  # noqa: E501
        """Update enabled status for a Dispatch   # noqa: E501

        Updates the enabled status for the dispatch.  This is an access control measure allowing you to turn access to a previously distributed dispatch packages on or off.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_dispatch_enabled_with_http_info(dispatch_id, enabled, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str dispatch_id: Identifier for the dispatch (required)
        :param EnabledSchema enabled:  (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['dispatch_id', 'enabled']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method set_dispatch_enabled" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'dispatch_id' is set
        if ('dispatch_id' not in params or
                params['dispatch_id'] is None):
            raise ValueError("Missing the required parameter `dispatch_id` when calling `set_dispatch_enabled`")  # noqa: E501
        # verify the required parameter 'enabled' is set
        if ('enabled' not in params or
                params['enabled'] is None):
            raise ValueError("Missing the required parameter `enabled` when calling `set_dispatch_enabled`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'dispatch_id' in params:
            path_params['dispatchId'] = params['dispatch_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'enabled' in params:
            body_params = params['enabled']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APP_NORMAL', 'OAUTH']  # noqa: E501

        return self.api_client.call_api(
            '/dispatch/dispatches/{dispatchId}/enabled', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_destination_hash_user_info(self, destination_id, enabled, **kwargs):  # noqa: E501
        """Update user PII hashing status for a Destination  # noqa: E501

        Updates user PII hashing status for the destination.  Enabling it will cause all user PII to be hashed. Hashing PII will anonymize the learner data from the dispatched course.  This will make looking up specific details about a learner difficult.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_destination_hash_user_info(destination_id, enabled, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str destination_id: Identifier for the destination (required)
        :param EnabledSchema enabled: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_destination_hash_user_info_with_http_info(destination_id, enabled, **kwargs)  # noqa: E501
        else:
            (data) = self.update_destination_hash_user_info_with_http_info(destination_id, enabled, **kwargs)  # noqa: E501
            return data

    def update_destination_hash_user_info_with_http_info(self, destination_id, enabled, **kwargs):  # noqa: E501
        """Update user PII hashing status for a Destination  # noqa: E501

        Updates user PII hashing status for the destination.  Enabling it will cause all user PII to be hashed. Hashing PII will anonymize the learner data from the dispatched course.  This will make looking up specific details about a learner difficult.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_destination_hash_user_info_with_http_info(destination_id, enabled, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str destination_id: Identifier for the destination (required)
        :param EnabledSchema enabled: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['destination_id', 'enabled']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_destination_hash_user_info" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'destination_id' is set
        if ('destination_id' not in params or
                params['destination_id'] is None):
            raise ValueError("Missing the required parameter `destination_id` when calling `update_destination_hash_user_info`")  # noqa: E501
        # verify the required parameter 'enabled' is set
        if ('enabled' not in params or
                params['enabled'] is None):
            raise ValueError("Missing the required parameter `enabled` when calling `update_destination_hash_user_info`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'destination_id' in params:
            path_params['destinationId'] = params['destination_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'enabled' in params:
            body_params = params['enabled']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APP_NORMAL', 'OAUTH']  # noqa: E501

        return self.api_client.call_api(
            '/dispatch/destinations/{destinationId}/dispatches/hashUserInfo', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_dispatch(self, dispatch_id, dispatch_properties, **kwargs):  # noqa: E501
        """Update information about a Dispatch   # noqa: E501

        Updates information about the dispatch, such as the expiration date and registration cap.  Only non-null values that are provided will be updated.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_dispatch(dispatch_id, dispatch_properties, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str dispatch_id: Identifier for the dispatch (required)
        :param UpdateDispatchSchema dispatch_properties: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_dispatch_with_http_info(dispatch_id, dispatch_properties, **kwargs)  # noqa: E501
        else:
            (data) = self.update_dispatch_with_http_info(dispatch_id, dispatch_properties, **kwargs)  # noqa: E501
            return data

    def update_dispatch_with_http_info(self, dispatch_id, dispatch_properties, **kwargs):  # noqa: E501
        """Update information about a Dispatch   # noqa: E501

        Updates information about the dispatch, such as the expiration date and registration cap.  Only non-null values that are provided will be updated.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_dispatch_with_http_info(dispatch_id, dispatch_properties, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str dispatch_id: Identifier for the dispatch (required)
        :param UpdateDispatchSchema dispatch_properties: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['dispatch_id', 'dispatch_properties']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_dispatch" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'dispatch_id' is set
        if ('dispatch_id' not in params or
                params['dispatch_id'] is None):
            raise ValueError("Missing the required parameter `dispatch_id` when calling `update_dispatch`")  # noqa: E501
        # verify the required parameter 'dispatch_properties' is set
        if ('dispatch_properties' not in params or
                params['dispatch_properties'] is None):
            raise ValueError("Missing the required parameter `dispatch_properties` when calling `update_dispatch`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'dispatch_id' in params:
            path_params['dispatchId'] = params['dispatch_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'dispatch_properties' in params:
            body_params = params['dispatch_properties']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APP_NORMAL', 'OAUTH']  # noqa: E501

        return self.api_client.call_api(
            '/dispatch/dispatches/{dispatchId}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_dispatch_hash_user_info(self, dispatch_id, enabled, **kwargs):  # noqa: E501
        """Update user PII hashing status for a Dispatch  # noqa: E501

        Updates user PII hashing status for the dispatch.  Enabling it will cause all user PII to be hashed. Hashing PII will anonymize the learner data from the dispatched course.  This will make looking up specific details about a learner difficult.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_dispatch_hash_user_info(dispatch_id, enabled, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str dispatch_id: Identifier for the dispatch (required)
        :param EnabledSchema enabled: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_dispatch_hash_user_info_with_http_info(dispatch_id, enabled, **kwargs)  # noqa: E501
        else:
            (data) = self.update_dispatch_hash_user_info_with_http_info(dispatch_id, enabled, **kwargs)  # noqa: E501
            return data

    def update_dispatch_hash_user_info_with_http_info(self, dispatch_id, enabled, **kwargs):  # noqa: E501
        """Update user PII hashing status for a Dispatch  # noqa: E501

        Updates user PII hashing status for the dispatch.  Enabling it will cause all user PII to be hashed. Hashing PII will anonymize the learner data from the dispatched course.  This will make looking up specific details about a learner difficult.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_dispatch_hash_user_info_with_http_info(dispatch_id, enabled, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str dispatch_id: Identifier for the dispatch (required)
        :param EnabledSchema enabled: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['dispatch_id', 'enabled']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_dispatch_hash_user_info" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'dispatch_id' is set
        if ('dispatch_id' not in params or
                params['dispatch_id'] is None):
            raise ValueError("Missing the required parameter `dispatch_id` when calling `update_dispatch_hash_user_info`")  # noqa: E501
        # verify the required parameter 'enabled' is set
        if ('enabled' not in params or
                params['enabled'] is None):
            raise ValueError("Missing the required parameter `enabled` when calling `update_dispatch_hash_user_info`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'dispatch_id' in params:
            path_params['dispatchId'] = params['dispatch_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'enabled' in params:
            body_params = params['enabled']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APP_NORMAL', 'OAUTH']  # noqa: E501

        return self.api_client.call_api(
            '/dispatch/dispatches/{dispatchId}/hashUserInfo', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_dispatches(self, dispatch_properties, **kwargs):  # noqa: E501
        """Update a group of Dispatches   # noqa: E501

        Updates information about a group of dispatches, such as registration cap, expiration date, and postback information. Can be filtered using the request parameters to provide a subset of results.  >**Note:** >One of the filter parameters (i.e. `courseId`, `since`/`until`, `tags`, or `filter`) needs to be provided.  This is to prevent accidental modification of all dispatches.  If you do wish to update all dispatches, try setting the since parameter to a value prior to the creation of any dispatches.  >**Info:** >If using one of our client libraries, refer to its README for additional information on how to work with the `X-Total-Count` header.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_dispatches(dispatch_properties, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param UpdateDispatchSchema dispatch_properties: (required)
        :param str course_id: Only retrieve resources having `courseId`
        :param datetime since: Filter by ISO 8601 TimeStamp inclusive (defaults to UTC)
        :param datetime until: Filter by ISO 8601 TimeStamp inclusive (defaults to UTC)
        :param str datetime_filter: Specifies field that `since` and `until` parameters are applied against
        :param list[str] tags: Filter items matching any tag provided (not all)
        :param str filter: Optional string which filters results by a specified field (described by filterBy).
        :param str filter_by: Optional enum parameter for specifying the field on which to run the filter. 
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_dispatches_with_http_info(dispatch_properties, **kwargs)  # noqa: E501
        else:
            (data) = self.update_dispatches_with_http_info(dispatch_properties, **kwargs)  # noqa: E501
            return data

    def update_dispatches_with_http_info(self, dispatch_properties, **kwargs):  # noqa: E501
        """Update a group of Dispatches   # noqa: E501

        Updates information about a group of dispatches, such as registration cap, expiration date, and postback information. Can be filtered using the request parameters to provide a subset of results.  >**Note:** >One of the filter parameters (i.e. `courseId`, `since`/`until`, `tags`, or `filter`) needs to be provided.  This is to prevent accidental modification of all dispatches.  If you do wish to update all dispatches, try setting the since parameter to a value prior to the creation of any dispatches.  >**Info:** >If using one of our client libraries, refer to its README for additional information on how to work with the `X-Total-Count` header.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_dispatches_with_http_info(dispatch_properties, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param UpdateDispatchSchema dispatch_properties: (required)
        :param str course_id: Only retrieve resources having `courseId`
        :param datetime since: Filter by ISO 8601 TimeStamp inclusive (defaults to UTC)
        :param datetime until: Filter by ISO 8601 TimeStamp inclusive (defaults to UTC)
        :param str datetime_filter: Specifies field that `since` and `until` parameters are applied against
        :param list[str] tags: Filter items matching any tag provided (not all)
        :param str filter: Optional string which filters results by a specified field (described by filterBy).
        :param str filter_by: Optional enum parameter for specifying the field on which to run the filter. 
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['dispatch_properties', 'course_id', 'since', 'until', 'datetime_filter', 'tags', 'filter', 'filter_by']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_dispatches" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'dispatch_properties' is set
        if ('dispatch_properties' not in params or
                params['dispatch_properties'] is None):
            raise ValueError("Missing the required parameter `dispatch_properties` when calling `update_dispatches`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'course_id' in params:
            query_params.append(('courseId', params['course_id']))  # noqa: E501
        if 'since' in params:
            query_params.append(('since', params['since']))  # noqa: E501
        if 'until' in params:
            query_params.append(('until', params['until']))  # noqa: E501
        if 'datetime_filter' in params:
            query_params.append(('datetimeFilter', params['datetime_filter']))  # noqa: E501
        if 'tags' in params:
            query_params.append(('tags', params['tags']))  # noqa: E501
            collection_formats['tags'] = 'csv'  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501
        if 'filter_by' in params:
            query_params.append(('filterBy', params['filter_by']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'dispatch_properties' in params:
            body_params = params['dispatch_properties']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APP_NORMAL', 'OAUTH']  # noqa: E501

        return self.api_client.call_api(
            '/dispatch/dispatches', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
