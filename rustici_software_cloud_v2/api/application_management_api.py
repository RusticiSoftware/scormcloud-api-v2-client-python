# coding: utf-8

"""
    SCORM Cloud Rest API

    REST API used for SCORM Cloud integrations.  # noqa: E501

    OpenAPI spec version: 2.0
    Contact: systems@rusticisoftware.com
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


from __future__ import absolute_import
from deprecated import deprecated

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from rustici_software_cloud_v2.api_client import ApiClient


class ApplicationManagementApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def create_application(self, application_request, **kwargs):  # noqa: E501
        """Use the Application Management App to create a new Application   # noqa: E501

        Creates an application.  Applications are how resources are grouped together in SCORM Cloud.  Any courses, registrations, etc. will only be accessible via the credentials for the application they belong to.  >**Note:** >Application IDs are unique in that we do not allow the user to supply a custom value for this field.  The ID of the newly created application will be specified in the response from this method.  >**Note:** >Each Realm has a special application called the **Application Management Application**.  When using this special application's credentials to authenticate with the API, you are able to perform actions on all the other applications within that Realm (and only those actions, this isn't a general purpose credential).  You can list, add, update, and delete both applications and credentials with this API resource.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_application(application_request, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ApplicationRequestSchema application_request: (required)
        :return: ApplicationSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_application_with_http_info(application_request, **kwargs)  # noqa: E501
        else:
            (data) = self.create_application_with_http_info(application_request, **kwargs)  # noqa: E501
            return data

    def create_application_with_http_info(self, application_request, **kwargs):  # noqa: E501
        """Use the Application Management App to create a new Application   # noqa: E501

        Creates an application.  Applications are how resources are grouped together in SCORM Cloud.  Any courses, registrations, etc. will only be accessible via the credentials for the application they belong to.  >**Note:** >Application IDs are unique in that we do not allow the user to supply a custom value for this field.  The ID of the newly created application will be specified in the response from this method.  >**Note:** >Each Realm has a special application called the **Application Management Application**.  When using this special application's credentials to authenticate with the API, you are able to perform actions on all the other applications within that Realm (and only those actions, this isn't a general purpose credential).  You can list, add, update, and delete both applications and credentials with this API resource.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_application_with_http_info(application_request, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ApplicationRequestSchema application_request: (required)
        :return: ApplicationSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['application_request']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_application" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'application_request' is set
        if ('application_request' not in params or
                params['application_request'] is None):
            raise ValueError("Missing the required parameter `application_request` when calling `create_application`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'application_request' in params:
            body_params = params['application_request']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APP_MANAGEMENT', 'OAUTH']  # noqa: E501

        return self.api_client.call_api(
            '/appManagement/applications', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ApplicationSchema',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_credential(self, child_app_id, credential_request, **kwargs):  # noqa: E501
        """Use the Application Manager App to create a new secret key for an Application   # noqa: E501

        Creates a new credential (aka secret key) for use with the child application.  The credential will be used alongside the `childAppId` for basic auth requests.  >**Note:** >Each Realm has a special application called the **Application Management Application**.  When using this special application's credentials to authenticate with the API, you are able to perform actions on all the other applications within that Realm (and only those actions, this isn't a general purpose credential).  You can list, add, update, and delete both applications and credentials with this API resource.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_credential(child_app_id, credential_request, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str child_app_id: (required)
        :param CredentialRequestSchema credential_request: (required)
        :return: CredentialCreatedSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_credential_with_http_info(child_app_id, credential_request, **kwargs)  # noqa: E501
        else:
            (data) = self.create_credential_with_http_info(child_app_id, credential_request, **kwargs)  # noqa: E501
            return data

    def create_credential_with_http_info(self, child_app_id, credential_request, **kwargs):  # noqa: E501
        """Use the Application Manager App to create a new secret key for an Application   # noqa: E501

        Creates a new credential (aka secret key) for use with the child application.  The credential will be used alongside the `childAppId` for basic auth requests.  >**Note:** >Each Realm has a special application called the **Application Management Application**.  When using this special application's credentials to authenticate with the API, you are able to perform actions on all the other applications within that Realm (and only those actions, this isn't a general purpose credential).  You can list, add, update, and delete both applications and credentials with this API resource.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_credential_with_http_info(child_app_id, credential_request, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str child_app_id: (required)
        :param CredentialRequestSchema credential_request: (required)
        :return: CredentialCreatedSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['child_app_id', 'credential_request']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_credential" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'child_app_id' is set
        if ('child_app_id' not in params or
                params['child_app_id'] is None):
            raise ValueError("Missing the required parameter `child_app_id` when calling `create_credential`")  # noqa: E501
        # verify the required parameter 'credential_request' is set
        if ('credential_request' not in params or
                params['credential_request'] is None):
            raise ValueError("Missing the required parameter `credential_request` when calling `create_credential`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'child_app_id' in params:
            path_params['childAppId'] = params['child_app_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'credential_request' in params:
            body_params = params['credential_request']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APP_MANAGEMENT', 'OAUTH']  # noqa: E501

        return self.api_client.call_api(
            '/appManagement/{childAppId}/credentials', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CredentialCreatedSchema',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_token(self, token_request, **kwargs):  # noqa: E501
        """Obtain an OAuth token for scoped access to an Application   # noqa: E501

        Creates, signs and returns an OAuth2 token based on the provided permissions, if the credentials used to request the token have the permissions being requested.  >**Note:** >The token is not stored and therefore can not be modified or deleted.  The requested permissions are encoded in the token which is then signed.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_token(token_request, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param TokenRequestSchema token_request: (required)
        :return: StringResultSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_token_with_http_info(token_request, **kwargs)  # noqa: E501
        else:
            (data) = self.create_token_with_http_info(token_request, **kwargs)  # noqa: E501
            return data

    def create_token_with_http_info(self, token_request, **kwargs):  # noqa: E501
        """Obtain an OAuth token for scoped access to an Application   # noqa: E501

        Creates, signs and returns an OAuth2 token based on the provided permissions, if the credentials used to request the token have the permissions being requested.  >**Note:** >The token is not stored and therefore can not be modified or deleted.  The requested permissions are encoded in the token which is then signed.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_token_with_http_info(token_request, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param TokenRequestSchema token_request: (required)
        :return: StringResultSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['token_request']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_token" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'token_request' is set
        if ('token_request' not in params or
                params['token_request'] is None):
            raise ValueError("Missing the required parameter `token_request` when calling `create_token`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'token_request' in params:
            body_params = params['token_request']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APP_NORMAL']  # noqa: E501

        return self.api_client.call_api(
            '/appManagement/token', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='StringResultSchema',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_application(self, child_app_id, **kwargs):  # noqa: E501
        """Use the Application Management App to delete an Application   # noqa: E501

        Deletes the specified application.  All content within an application must be removed in order to allow deletion.  >**Note:** >Each Realm has a special application called the **Application Management Application**.  When using this special application's credentials to authenticate with the API, you are able to perform actions on all the other applications within that Realm (and only those actions, this isn't a general purpose credential).  You can list, add, update, and delete both applications and credentials with this API resource.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_application(child_app_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str child_app_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_application_with_http_info(child_app_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_application_with_http_info(child_app_id, **kwargs)  # noqa: E501
            return data

    def delete_application_with_http_info(self, child_app_id, **kwargs):  # noqa: E501
        """Use the Application Management App to delete an Application   # noqa: E501

        Deletes the specified application.  All content within an application must be removed in order to allow deletion.  >**Note:** >Each Realm has a special application called the **Application Management Application**.  When using this special application's credentials to authenticate with the API, you are able to perform actions on all the other applications within that Realm (and only those actions, this isn't a general purpose credential).  You can list, add, update, and delete both applications and credentials with this API resource.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_application_with_http_info(child_app_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str child_app_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['child_app_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_application" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'child_app_id' is set
        if ('child_app_id' not in params or
                params['child_app_id'] is None):
            raise ValueError("Missing the required parameter `child_app_id` when calling `delete_application`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'child_app_id' in params:
            path_params['childAppId'] = params['child_app_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APP_MANAGEMENT', 'OAUTH']  # noqa: E501

        return self.api_client.call_api(
            '/appManagement/applications/{childAppId}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_application_configuration_setting(self, setting_id, **kwargs):  # noqa: E501
        """Delete a configuration setting explicitly set for an Application   # noqa: E501

        Clears the specified setting from the application.  This causes the setting to inherit a value from a higher level (e.g. system default if deleting from application, application level if deleting from learning standard). If the configuration setting was not set at the application level it will continue to persist and will require deletion from the level it was set.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_application_configuration_setting(setting_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str setting_id: (required)
        :param str learning_standard: If specified, the request will be scoped to the provided learning standard.
        :param bool single_sco: Required if `learningStandard` is specified. Scopes settings to either single or multi-SCO content. 
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_application_configuration_setting_with_http_info(setting_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_application_configuration_setting_with_http_info(setting_id, **kwargs)  # noqa: E501
            return data

    def delete_application_configuration_setting_with_http_info(self, setting_id, **kwargs):  # noqa: E501
        """Delete a configuration setting explicitly set for an Application   # noqa: E501

        Clears the specified setting from the application.  This causes the setting to inherit a value from a higher level (e.g. system default if deleting from application, application level if deleting from learning standard). If the configuration setting was not set at the application level it will continue to persist and will require deletion from the level it was set.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_application_configuration_setting_with_http_info(setting_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str setting_id: (required)
        :param str learning_standard: If specified, the request will be scoped to the provided learning standard.
        :param bool single_sco: Required if `learningStandard` is specified. Scopes settings to either single or multi-SCO content. 
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['setting_id', 'learning_standard', 'single_sco']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_application_configuration_setting" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'setting_id' is set
        if ('setting_id' not in params or
                params['setting_id'] is None):
            raise ValueError("Missing the required parameter `setting_id` when calling `delete_application_configuration_setting`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'setting_id' in params:
            path_params['settingId'] = params['setting_id']  # noqa: E501

        query_params = []
        if 'learning_standard' in params:
            query_params.append(('learningStandard', params['learning_standard']))  # noqa: E501
        if 'single_sco' in params:
            query_params.append(('singleSco', params['single_sco']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APP_NORMAL', 'OAUTH']  # noqa: E501

        return self.api_client.call_api(
            '/appManagement/configuration/{settingId}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_credential(self, child_app_id, credential_id, **kwargs):  # noqa: E501
        """Use the Application Management App to delete a secret key from an Application   # noqa: E501

        Deletes a credential belonging to the child application.  >**Caution:** >If the last secret key for an application is deleted it will not be able to use the SCORM Cloud API until another key is granted to it via `CreateCredential`.  It may also disable some website privileges.  >**Note:** >Each Realm has a special application called the **Application Management Application**.  When using this special application's credentials to authenticate with the API, you are able to perform actions on all the other applications within that Realm (and only those actions, this isn't a general purpose credential).  You can list, add, update, and delete both applications and credentials with this API resource.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_credential(child_app_id, credential_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str child_app_id: (required)
        :param str credential_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_credential_with_http_info(child_app_id, credential_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_credential_with_http_info(child_app_id, credential_id, **kwargs)  # noqa: E501
            return data

    def delete_credential_with_http_info(self, child_app_id, credential_id, **kwargs):  # noqa: E501
        """Use the Application Management App to delete a secret key from an Application   # noqa: E501

        Deletes a credential belonging to the child application.  >**Caution:** >If the last secret key for an application is deleted it will not be able to use the SCORM Cloud API until another key is granted to it via `CreateCredential`.  It may also disable some website privileges.  >**Note:** >Each Realm has a special application called the **Application Management Application**.  When using this special application's credentials to authenticate with the API, you are able to perform actions on all the other applications within that Realm (and only those actions, this isn't a general purpose credential).  You can list, add, update, and delete both applications and credentials with this API resource.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_credential_with_http_info(child_app_id, credential_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str child_app_id: (required)
        :param str credential_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['child_app_id', 'credential_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_credential" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'child_app_id' is set
        if ('child_app_id' not in params or
                params['child_app_id'] is None):
            raise ValueError("Missing the required parameter `child_app_id` when calling `delete_credential`")  # noqa: E501
        # verify the required parameter 'credential_id' is set
        if ('credential_id' not in params or
                params['credential_id'] is None):
            raise ValueError("Missing the required parameter `credential_id` when calling `delete_credential`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'child_app_id' in params:
            path_params['childAppId'] = params['child_app_id']  # noqa: E501
        if 'credential_id' in params:
            path_params['credentialId'] = params['credential_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APP_MANAGEMENT', 'OAUTH']  # noqa: E501

        return self.api_client.call_api(
            '/appManagement/{childAppId}/credentials/{credentialId}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_application_configuration(self, **kwargs):  # noqa: E501
        """Get effective configuration settings for an Application   # noqa: E501

        Returns the effective configuration settings for the application.  Configuration settings at the application level will apply to all items within that application (courses, registrations, etc.).  If there is a configuration setting present at a more specific level (course, registration, etc.), that setting will override the one set at the application level.  >**Note:** >This resource lists configuration for two groupings of content: >- ALL content in an application.  This is achieved by leaving `learningStandard` and   `singleSco` as `null`.  Anything set at the learningStandard/singleSco level will take precedence over these   settings. >- Content falling into a learningStandard/singleSco category.  This allows setting more specific   defaults for a particular learningStandard/singleSco combination.   _Note: both `learningStandard` and `singleSco` must be provided, as this level is considered to be   identified by those items joined._   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_application_configuration(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str learning_standard: If specified, the request will be scoped to the provided learning standard.
        :param bool single_sco: Required if `learningStandard` is specified. Scopes settings to either single or multi-SCO content. 
        :param bool include_metadata:
        :return: SettingListSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_application_configuration_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_application_configuration_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_application_configuration_with_http_info(self, **kwargs):  # noqa: E501
        """Get effective configuration settings for an Application   # noqa: E501

        Returns the effective configuration settings for the application.  Configuration settings at the application level will apply to all items within that application (courses, registrations, etc.).  If there is a configuration setting present at a more specific level (course, registration, etc.), that setting will override the one set at the application level.  >**Note:** >This resource lists configuration for two groupings of content: >- ALL content in an application.  This is achieved by leaving `learningStandard` and   `singleSco` as `null`.  Anything set at the learningStandard/singleSco level will take precedence over these   settings. >- Content falling into a learningStandard/singleSco category.  This allows setting more specific   defaults for a particular learningStandard/singleSco combination.   _Note: both `learningStandard` and `singleSco` must be provided, as this level is considered to be   identified by those items joined._   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_application_configuration_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str learning_standard: If specified, the request will be scoped to the provided learning standard.
        :param bool single_sco: Required if `learningStandard` is specified. Scopes settings to either single or multi-SCO content. 
        :param bool include_metadata:
        :return: SettingListSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['learning_standard', 'single_sco', 'include_metadata']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_application_configuration" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'learning_standard' in params:
            query_params.append(('learningStandard', params['learning_standard']))  # noqa: E501
        if 'single_sco' in params:
            query_params.append(('singleSco', params['single_sco']))  # noqa: E501
        if 'include_metadata' in params:
            query_params.append(('includeMetadata', params['include_metadata']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APP_NORMAL', 'OAUTH']  # noqa: E501

        return self.api_client.call_api(
            '/appManagement/configuration', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SettingListSchema',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_application_info(self, child_app_id, **kwargs):  # noqa: E501
        """Use the Application Management App to get detailed information about an Application   # noqa: E501

        Returns detailed information about the application.  This includes name, create date, and delete permissions.  >**Note:** >Each Realm has a special application called the **Application Management Application**.  When using this special application's credentials to authenticate with the API, you are able to perform actions on all the other applications within that Realm (and only those actions, this isn't a general purpose credential).  You can list, add, update, and delete both applications and credentials with this API resource.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_application_info(child_app_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str child_app_id: (required)
        :param bool include_course_count: Include a count of courses for the application.
        :param bool include_registration_count: Include a count of registrations created for the application during the current billing period.
        :return: ApplicationInfoSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_application_info_with_http_info(child_app_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_application_info_with_http_info(child_app_id, **kwargs)  # noqa: E501
            return data

    def get_application_info_with_http_info(self, child_app_id, **kwargs):  # noqa: E501
        """Use the Application Management App to get detailed information about an Application   # noqa: E501

        Returns detailed information about the application.  This includes name, create date, and delete permissions.  >**Note:** >Each Realm has a special application called the **Application Management Application**.  When using this special application's credentials to authenticate with the API, you are able to perform actions on all the other applications within that Realm (and only those actions, this isn't a general purpose credential).  You can list, add, update, and delete both applications and credentials with this API resource.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_application_info_with_http_info(child_app_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str child_app_id: (required)
        :param bool include_course_count: Include a count of courses for the application.
        :param bool include_registration_count: Include a count of registrations created for the application during the current billing period.
        :return: ApplicationInfoSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['child_app_id', 'include_course_count', 'include_registration_count']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_application_info" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'child_app_id' is set
        if ('child_app_id' not in params or
                params['child_app_id'] is None):
            raise ValueError("Missing the required parameter `child_app_id` when calling `get_application_info`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'child_app_id' in params:
            path_params['childAppId'] = params['child_app_id']  # noqa: E501

        query_params = []
        if 'include_course_count' in params:
            query_params.append(('includeCourseCount', params['include_course_count']))  # noqa: E501
        if 'include_registration_count' in params:
            query_params.append(('includeRegistrationCount', params['include_registration_count']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APP_MANAGEMENT', 'OAUTH']  # noqa: E501

        return self.api_client.call_api(
            '/appManagement/applications/{childAppId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ApplicationInfoSchema',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    @deprecated(reason="Use GetApplications instead.")
    def get_application_list(self, **kwargs):  # noqa: E501
        """(Deprecated) Use the Application Management App to get basic data about all Applications in a Realm   # noqa: E501

        Returns a list of all applications which are in this Realm.  >**Deprecated:** >It is advised to use GetApplications instead of this endpoint, as this one now exists for backwards  compatibility.  This endpoint returns very limited data about **all** applications in a Realm and is not  paginated.  Because of this, this endpoint can run into issues and have very slow performance when attempting to  pull data for accounts with many applications.  The GetApplications endpoint alleviates this problem by using pagination to return a limited amount of applications at once, while also providing much more detail about every  application present in a Realm.  >**Note:** >Each Realm has a special application called the **Application Management Application**.  When using this special application's credentials to authenticate with the API, you are able to perform actions on all the other applications within that Realm (and only those actions, this isn't a general purpose credential).  You can list, add, update, and delete both applications and credentials with this API resource.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_application_list(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: ApplicationListSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_application_list_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_application_list_with_http_info(**kwargs)  # noqa: E501
            return data

    @deprecated(reason="Use GetApplicationsWithHttpInfo instead.")
    def get_application_list_with_http_info(self, **kwargs):  # noqa: E501
        """(Deprecated) Use the Application Management App to get basic data about all Applications in a Realm   # noqa: E501

        Returns a list of all applications which are in this Realm.  >**Deprecated:** >It is advised to use GetApplications instead of this endpoint, as this one now exists for backwards  compatibility.  This endpoint returns very limited data about **all** applications in a Realm and is not  paginated.  Because of this, this endpoint can run into issues and have very slow performance when attempting to  pull data for accounts with many applications.  The GetApplications endpoint alleviates this problem by using pagination to return a limited amount of applications at once, while also providing much more detail about every  application present in a Realm.  >**Note:** >Each Realm has a special application called the **Application Management Application**.  When using this special application's credentials to authenticate with the API, you are able to perform actions on all the other applications within that Realm (and only those actions, this isn't a general purpose credential).  You can list, add, update, and delete both applications and credentials with this API resource.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_application_list_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: ApplicationListSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_application_list" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APP_MANAGEMENT', 'OAUTH']  # noqa: E501

        return self.api_client.call_api(
            '/appManagement/applications', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ApplicationListSchema',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_applications(self, **kwargs):  # noqa: E501
        """Use the Application Management App to get a detailed list of Applications   # noqa: E501

        Returns a list of applications. Can be filtered using the request parameters to provide a subset of results.  This endpoint caches the course and registration counts of an application for 24 hours if either  `includeCourseCount` or `includeRegistrationCount` parameters, respectively, are set to `true`. Since these values are cached for an extended period, any changes made to the number of courses or  registrations in an application will not be reflected in the results of this endpoint until the caching period has passed.  >**Note:** >This request is paginated and will only provide a limited amount of resources at a time. If there are more results to be collected, a `more` token provided with the response which can be passed to get the next page of results. When passing this token, no other filter parameters can be sent as part of the request. The resources will continue to respect the filters passed in by the original request.  >**Note:** >Each Realm has a special application called the **Application Management Application**.  When using this special application's credentials to authenticate with the API, you are able to perform actions on all the other applications within that Realm (and only those actions, this isn't a general purpose credential).  You can list, add, update, and delete both applications and credentials with this API resource.  >**Info:** >If you want to get an up-to-date value of the course or registration count for a single application within the caching period, use the GetApplicationInfo endpoint with `includeCourseCount` and/or `includeRegistrationCount` set to `true`.  GetApplicationInfo *always* gathers the most up-to-date values and overwrites them in the cache, resetting the caching period for that application.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_applications(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param datetime since: Filter by ISO 8601 TimeStamp inclusive (defaults to UTC)
        :param datetime until: Filter by ISO 8601 TimeStamp inclusive (defaults to UTC)
        :param str datetime_filter: Specifies field that `since` and `until` parameters are applied against
        :param str filter: Optional string which filters results by a specified field (described by filterBy).
        :param str filter_by: Optional enum parameter for specifying the field on which to run the filter. 
        :param str order_by: Optional enum parameter for specifying the field and order by which to sort the results. 
        :param str more: Pagination token returned as `more` property of multi page list requests
        :param bool include_course_count: Include a count of courses for the application.
        :param bool include_registration_count: Include a count of registrations created for the application during the current billing period.
        :param bool include_total_count: Include the total count of results matching the provided filters as a header on the initial request.  The header will not be present on subsequent requests resulting from passing the `more` token. 
        :return: ApplicationInfoListSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_applications_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_applications_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_applications_with_http_info(self, **kwargs):  # noqa: E501
        """Use the Application Management App to get a detailed list of Applications   # noqa: E501

        Returns a list of applications. Can be filtered using the request parameters to provide a subset of results.  This endpoint caches the course and registration counts of an application for 24 hours if either  `includeCourseCount` or `includeRegistrationCount` parameters, respectively, are set to `true`. Since these values are cached for an extended period, any changes made to the number of courses or  registrations in an application will not be reflected in the results of this endpoint until the caching period has passed.  >**Note:** >This request is paginated and will only provide a limited amount of resources at a time. If there are more results to be collected, a `more` token provided with the response which can be passed to get the next page of results. When passing this token, no other filter parameters can be sent as part of the request. The resources will continue to respect the filters passed in by the original request.  >**Note:** >Each Realm has a special application called the **Application Management Application**.  When using this special application's credentials to authenticate with the API, you are able to perform actions on all the other applications within that Realm (and only those actions, this isn't a general purpose credential).  You can list, add, update, and delete both applications and credentials with this API resource.  >**Info:** >If you want to get an up-to-date value of the course or registration count for a single application within the caching period, use the GetApplicationInfo endpoint with `includeCourseCount` and/or `includeRegistrationCount` set to `true`.  GetApplicationInfo *always* gathers the most up-to-date values and overwrites them in the cache, resetting the caching period for that application.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_applications_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param datetime since: Filter by ISO 8601 TimeStamp inclusive (defaults to UTC)
        :param datetime until: Filter by ISO 8601 TimeStamp inclusive (defaults to UTC)
        :param str datetime_filter: Specifies field that `since` and `until` parameters are applied against
        :param str filter: Optional string which filters results by a specified field (described by filterBy).
        :param str filter_by: Optional enum parameter for specifying the field on which to run the filter. 
        :param str order_by: Optional enum parameter for specifying the field and order by which to sort the results. 
        :param str more: Pagination token returned as `more` property of multi page list requests
        :param bool include_course_count: Include a count of courses for the application.
        :param bool include_registration_count: Include a count of registrations created for the application during the current billing period.
        :param bool include_total_count: Include the total count of results matching the provided filters as a header on the initial request.  The header will not be present on subsequent requests resulting from passing the `more` token. 
        :return: ApplicationInfoListSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['since', 'until', 'datetime_filter', 'filter', 'filter_by', 'order_by', 'more', 'include_course_count', 'include_registration_count', 'include_total_count']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_applications" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'since' in params:
            query_params.append(('since', params['since']))  # noqa: E501
        if 'until' in params:
            query_params.append(('until', params['until']))  # noqa: E501
        if 'datetime_filter' in params:
            query_params.append(('datetimeFilter', params['datetime_filter']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501
        if 'filter_by' in params:
            query_params.append(('filterBy', params['filter_by']))  # noqa: E501
        if 'order_by' in params:
            query_params.append(('orderBy', params['order_by']))  # noqa: E501
        if 'more' in params:
            query_params.append(('more', params['more']))  # noqa: E501
        if 'include_course_count' in params:
            query_params.append(('includeCourseCount', params['include_course_count']))  # noqa: E501
        if 'include_registration_count' in params:
            query_params.append(('includeRegistrationCount', params['include_registration_count']))  # noqa: E501
        if 'include_total_count' in params:
            query_params.append(('includeTotalCount', params['include_total_count']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APP_MANAGEMENT', 'OAUTH']  # noqa: E501

        return self.api_client.call_api(
            '/appManagement/applicationList', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ApplicationInfoListSchema',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_credentials(self, child_app_id, **kwargs):  # noqa: E501
        """Use the Application Manager App to get a list of secret keys for an Application   # noqa: E501

        Returns a list of all the credentials (aka secret keys) belonging to the child application.  >**Note:** >Each Realm has a special application called the **Application Management Application**.  When using this special application's credentials to authenticate with the API, you are able to perform actions on all the other applications within that Realm (and only those actions, this isn't a general purpose credential).  You can list, add, update, and delete both applications and credentials with this API resource.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_credentials(child_app_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str child_app_id: (required)
        :return: CredentialListSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_credentials_with_http_info(child_app_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_credentials_with_http_info(child_app_id, **kwargs)  # noqa: E501
            return data

    def get_credentials_with_http_info(self, child_app_id, **kwargs):  # noqa: E501
        """Use the Application Manager App to get a list of secret keys for an Application   # noqa: E501

        Returns a list of all the credentials (aka secret keys) belonging to the child application.  >**Note:** >Each Realm has a special application called the **Application Management Application**.  When using this special application's credentials to authenticate with the API, you are able to perform actions on all the other applications within that Realm (and only those actions, this isn't a general purpose credential).  You can list, add, update, and delete both applications and credentials with this API resource.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_credentials_with_http_info(child_app_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str child_app_id: (required)
        :return: CredentialListSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['child_app_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_credentials" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'child_app_id' is set
        if ('child_app_id' not in params or
                params['child_app_id'] is None):
            raise ValueError("Missing the required parameter `child_app_id` when calling `get_credentials`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'child_app_id' in params:
            path_params['childAppId'] = params['child_app_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APP_MANAGEMENT', 'OAUTH']  # noqa: E501

        return self.api_client.call_api(
            '/appManagement/{childAppId}/credentials', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CredentialListSchema',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def set_application_configuration(self, configuration_settings, **kwargs):  # noqa: E501
        """Update configuration settings for an Application   # noqa: E501

        Updates configuration settings at the application level.  This will explicitly set a value at the applicaiton level.  These settings will affect all items within the application which do not have their own explicit configuration set.  This can effectively be used to set application level defaults.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_application_configuration(configuration_settings, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param SettingsPostSchema configuration_settings: (required)
        :param str learning_standard: If specified, the request will be scoped to the provided learning standard.
        :param bool single_sco: Required if `learningStandard` is specified. Scopes settings to either single or multi-SCO content. 
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.set_application_configuration_with_http_info(configuration_settings, **kwargs)  # noqa: E501
        else:
            (data) = self.set_application_configuration_with_http_info(configuration_settings, **kwargs)  # noqa: E501
            return data

    def set_application_configuration_with_http_info(self, configuration_settings, **kwargs):  # noqa: E501
        """Update configuration settings for an Application   # noqa: E501

        Updates configuration settings at the application level.  This will explicitly set a value at the applicaiton level.  These settings will affect all items within the application which do not have their own explicit configuration set.  This can effectively be used to set application level defaults.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_application_configuration_with_http_info(configuration_settings, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param SettingsPostSchema configuration_settings: (required)
        :param str learning_standard: If specified, the request will be scoped to the provided learning standard.
        :param bool single_sco: Required if `learningStandard` is specified. Scopes settings to either single or multi-SCO content. 
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['configuration_settings', 'learning_standard', 'single_sco']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method set_application_configuration" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'configuration_settings' is set
        if ('configuration_settings' not in params or
                params['configuration_settings'] is None):
            raise ValueError("Missing the required parameter `configuration_settings` when calling `set_application_configuration`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'learning_standard' in params:
            query_params.append(('learningStandard', params['learning_standard']))  # noqa: E501
        if 'single_sco' in params:
            query_params.append(('singleSco', params['single_sco']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'configuration_settings' in params:
            body_params = params['configuration_settings']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APP_NORMAL', 'OAUTH']  # noqa: E501

        return self.api_client.call_api(
            '/appManagement/configuration', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_application(self, child_app_id, application_properties, **kwargs):  # noqa: E501
        """Use the Application Management App to update information about an Application   # noqa: E501

        Updates information about the application, such as the name and enabling/ disabling deletion operations for the application.  >**Note:** >Each Realm has a special application called the **Application Management Application**.  When using this special application's credentials to authenticate with the API, you are able to perform actions on all the other applications within that Realm (and only those actions, this isn't a general purpose credential).  You can list, add, update, and delete both applications and credentials with this API resource.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_application(child_app_id, application_properties, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str child_app_id: (required)
        :param UpdateApplicationSchema application_properties: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_application_with_http_info(child_app_id, application_properties, **kwargs)  # noqa: E501
        else:
            (data) = self.update_application_with_http_info(child_app_id, application_properties, **kwargs)  # noqa: E501
            return data

    def update_application_with_http_info(self, child_app_id, application_properties, **kwargs):  # noqa: E501
        """Use the Application Management App to update information about an Application   # noqa: E501

        Updates information about the application, such as the name and enabling/ disabling deletion operations for the application.  >**Note:** >Each Realm has a special application called the **Application Management Application**.  When using this special application's credentials to authenticate with the API, you are able to perform actions on all the other applications within that Realm (and only those actions, this isn't a general purpose credential).  You can list, add, update, and delete both applications and credentials with this API resource.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_application_with_http_info(child_app_id, application_properties, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str child_app_id: (required)
        :param UpdateApplicationSchema application_properties: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['child_app_id', 'application_properties']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_application" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'child_app_id' is set
        if ('child_app_id' not in params or
                params['child_app_id'] is None):
            raise ValueError("Missing the required parameter `child_app_id` when calling `update_application`")  # noqa: E501
        # verify the required parameter 'application_properties' is set
        if ('application_properties' not in params or
                params['application_properties'] is None):
            raise ValueError("Missing the required parameter `application_properties` when calling `update_application`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'child_app_id' in params:
            path_params['childAppId'] = params['child_app_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'application_properties' in params:
            body_params = params['application_properties']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APP_MANAGEMENT', 'OAUTH']  # noqa: E501

        return self.api_client.call_api(
            '/appManagement/applications/{childAppId}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_credential(self, child_app_id, credential_id, credential_update, **kwargs):  # noqa: E501
        """Use the Application Manager App to update an existing secret key for an Application   # noqa: E501

        Updates the name or status associated with the credential.  Disabling a credential will cause it to no longer be valid for authorization through the API.  >**Caution:** >If the last (or only) key for an application is disabled it may affect some website privileges.  >**Note:** >Each Realm has a special application called the **Application Management Application**.  When using this special application's credentials to authenticate with the API, you are able to perform actions on all the other applications within that Realm (and only those actions, this isn't a general purpose credential).  You can list, add, update, and delete both applications and credentials with this API resource.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_credential(child_app_id, credential_id, credential_update, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str child_app_id: (required)
        :param str credential_id: (required)
        :param CredentialRequestSchema credential_update: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_credential_with_http_info(child_app_id, credential_id, credential_update, **kwargs)  # noqa: E501
        else:
            (data) = self.update_credential_with_http_info(child_app_id, credential_id, credential_update, **kwargs)  # noqa: E501
            return data

    def update_credential_with_http_info(self, child_app_id, credential_id, credential_update, **kwargs):  # noqa: E501
        """Use the Application Manager App to update an existing secret key for an Application   # noqa: E501

        Updates the name or status associated with the credential.  Disabling a credential will cause it to no longer be valid for authorization through the API.  >**Caution:** >If the last (or only) key for an application is disabled it may affect some website privileges.  >**Note:** >Each Realm has a special application called the **Application Management Application**.  When using this special application's credentials to authenticate with the API, you are able to perform actions on all the other applications within that Realm (and only those actions, this isn't a general purpose credential).  You can list, add, update, and delete both applications and credentials with this API resource.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_credential_with_http_info(child_app_id, credential_id, credential_update, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str child_app_id: (required)
        :param str credential_id: (required)
        :param CredentialRequestSchema credential_update: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['child_app_id', 'credential_id', 'credential_update']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_credential" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'child_app_id' is set
        if ('child_app_id' not in params or
                params['child_app_id'] is None):
            raise ValueError("Missing the required parameter `child_app_id` when calling `update_credential`")  # noqa: E501
        # verify the required parameter 'credential_id' is set
        if ('credential_id' not in params or
                params['credential_id'] is None):
            raise ValueError("Missing the required parameter `credential_id` when calling `update_credential`")  # noqa: E501
        # verify the required parameter 'credential_update' is set
        if ('credential_update' not in params or
                params['credential_update'] is None):
            raise ValueError("Missing the required parameter `credential_update` when calling `update_credential`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'child_app_id' in params:
            path_params['childAppId'] = params['child_app_id']  # noqa: E501
        if 'credential_id' in params:
            path_params['credentialId'] = params['credential_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'credential_update' in params:
            body_params = params['credential_update']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APP_MANAGEMENT', 'OAUTH']  # noqa: E501

        return self.api_client.call_api(
            '/appManagement/{childAppId}/credentials/{credentialId}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
